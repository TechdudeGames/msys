diff -urN rxvt-2.7.2-orig/CYGWIN-PATCHES/rxvt-2.7.2.README rxvt-2.7.2/CYGWIN-PATCHES/rxvt-2.7.2.README
--- rxvt-2.7.2-orig/CYGWIN-PATCHES/rxvt-2.7.2.README	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/CYGWIN-PATCHES/rxvt-2.7.2.README	Fri May 25 09:54:08 2001
@@ -0,0 +1,166 @@
+
+Win32 enabled rxvt README
+
+rxvt is a color vt102 terminal emulator intended as a replacement
+for xterm(1) and cmd.com.
+
+
+Quick start, from a bash shell try running:
+
+rxvt -e /usr/bin/bash --login -i
+
+If this doesn't work, you may not have cygwin 1.1 or better 
+installed on your PC.  Visit: 
+   http://www.cygwin.com/
+
+If rxvt complains that it can't open the display, check that
+you are using the Win32 enabled rxvt, and that DISPLAY is either
+not set, or set to:
+  :0
+
+Setting DISPLAY to anything else causes the Win32 enabled rxvt 
+to revert to its traditional X behavior.
+
+You may set DISPLAY from the command line like so:
+
+  rxvt -display :0
+
+
+Shortcut:
+
+If you create a shortcut to the rxvt app, you should be able to 
+use it to launch a terminal.  A black console window may appear
+and quickly disappear when you run rxvt this way, this is ok.
+
+ rxvt -tn xterm -e /usr/bin/bash --login -i
+
+
+
+Fonts:
+
+You can experiment with different fonts with the -fn switch. 
+However, the font parsing code is pretty primitive.  These
+should work if you have the fonts installed:
+  rxvt -fn "Courier-bold-13" -e ...
+  rxvt -fn "-*-Courier-medium-r-*-13-*" -e ...
+  rxvt -fn "Lucida Console-10" -e ...
+
+You can also put the font definitions in your .Xdefaults to avoid
+cluttering up the command line.  An example:
+
+cat >> $HOME/.Xdefaults
+*font: -*-lucidatypewriter-medium-r-*-*-16-*-*-*-*-*-*-*
+^D
+
+If you like the DOS look, Dan Kaminsky suggests:
+  rxvt -fn fixedsys -bg black -fg grey 
+Or
+  rxvt -fn fixedsys -rv 
+
+
+
+Coloring:
+
+To make your bash prompt colorful try putting this in your .profile:
+  export PS1="\e[34m\]\w\[\e[0m\]> "
+
+File listing can be in color with the following alias:
+  alias ls=ls\ -F\ --color
+
+vi will color your source code if you set your TERM to linux
+or patch the xterm /etc/termcap entry.  As Dan recommends,
+add: 
+   xn@:op=\E[39;49m:Km=\E[M:tc=linux:
+after the line:
+   xterm-r6|xterm|xterm X11R6 version:\
+
+
+
+General Unix Shell:
+
+If you're new to bash or color xterm, try putting this in your
+.profile:
+
+ stty intr ^c susp ^z start ^q stop ^s quit ^\\ erase ^?
+
+Also, rxvt/bash uses some environmental variables which are 
+commonplace in Unix, but rare in Windows.   These are:
+  USER  set to your username
+  SHELL set to /bin/bash 
+  HOME  set to /home/username
+If you set these variables either in the autoexec.bat or 
+by right clicking "My Computer", you'll find that things
+work better.
+
+
+
+How to Insert/Paste:
+
+If you have a two button mouse and wish to paste, you may
+use Sh-Insert, or use a windows mouse program to simulate
+the middle mouse button when both buttons are pressed. 
+
+
+
+Display, or "how can I get rxvt to connect to my X-server at :0"
+
+Here's some options:
+1) run your X-server as :1 (it is, after all, the second display)
+2) set DISPLAY to localhost:0
+3) set W11_LIBRARY to libX11
+
+
+Recent fixes:
+
+- added icon
+- reverted to building as a console app.  Windows treats console
+  apps differently somehow as far as childern inheriting the console.
+- put a special case in the event code to better handle selections
+- added switching between Win32 and X libraries
+- trying -mwindows to see if console is no longer necessary
+- Mousewheel support
+- Ctrl-Space now works (thanks to Patrick Doyle for the bug report)
+- Ctrl-S doesn't hang the program (thanks to cygwin improvements)
+- Builds with cygwin-1.1.8 (thanks to Axel Kowald for the alert)
+- Fixes for supporting Japanese Fonts (thanks to Genzoo.A)
+
+
+
+Building:
+
+ 1) apply patch
+ 2) configure
+
+      ./configure --x-includes="../W11 -IW11" \
+       --x-libraries="../W11/lib -mwindows ../W11/wrap/rxvt_res.o -Wl,--subsystem,console" \
+       --with-xpm-includes=../W11 \
+       --with-xpm-library=../W11/lib \
+       --enable-menubar \
+       --enable-xpm-background 
+
+ 3) run make, you should get a couple warnings and no errors.
+
+
+Credits, bugs, updates:
+
+rxvt is used out-of-the-box from http://www.rxvt.org/
+and linked with a fake X-library that uses the Windows API.  
+
+The fake X-library is a heavily modified version of:
+ ftp://ftp.microsoft.com/developr/drg/UNIX-to-Windows/Ports/Xlib/ntxlib.zip
+
+xpm-3.4k is used out of the box and statically linked to rxvt.
+
+bugs in windows support:
+- large pastes can cause the window to hang.
+- pixmaps are experimental, must be multiple of 8 pixels wide.
+- locales are not supported.
+- native-console accesses (ReadConsole(), WriteConsole()) are not supported.
+    This is particularly true when non-cygwin programs ask for passwords.
+- expose events get lost under certain circumstances.
+- if rxvt doesn't allocate a console occasionally an unexpected
+    console will pop up while running non-cygwin apps.
+
+Check http://www.io.com/~bub/rxvt.html for updates and source.
+If you fix something, please let me know (Steve O <bub@io.com>).
+Thanks.
diff -urN rxvt-2.7.2-orig/Makefile.in rxvt-2.7.2/Makefile.in
--- rxvt-2.7.2-orig/Makefile.in	Tue Dec 21 02:07:54 1999
+++ rxvt-2.7.2/Makefile.in	Sat Apr 14 16:50:38 2001
@@ -9,7 +9,7 @@
 first_rule: all
 dummy:
 
-subdirs = src doc rclock src/graphics src/test
+subdirs = W11 src doc rclock src/graphics src/test
 
 DIST =	INSTALL README.configure configure Makefile Makefile.in ChangeLog
 
diff -urN rxvt-2.7.2-orig/W11/Makefile.in rxvt-2.7.2/W11/Makefile.in
--- rxvt-2.7.2-orig/W11/Makefile.in	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/Makefile.in	Mon May 14 08:54:02 2001
@@ -0,0 +1,18 @@
+
+@MCOMMON@
+
+first_rule: all
+
+all allbin alldoc:
+	cd xpm-3.4k/lib; make -f Makefile.noX all install
+	cd wrap; make $@
+	cd w32; make $@
+
+tags clean:
+	cd xpm-3.4k/lib; make -f Makefile.noX $@
+	cd wrap; make $@
+	cd w32; make $@
+
+install:
+	$(INSTALL_PROGRAM) lib/libW11.dll $(bindir)/libW11.dll
+	$(INSTALL) ../CYGWIN-PATCHES/rxvt-2.7.2.README $(prefix)/doc/Cygwin
diff -urN rxvt-2.7.2-orig/W11/X11/Intrinsic.h rxvt-2.7.2/W11/X11/Intrinsic.h
--- rxvt-2.7.2-orig/W11/X11/Intrinsic.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/X11/Intrinsic.h	Sat Apr 14 16:49:08 2001
@@ -0,0 +1,2 @@
+#include <X11/xlib.h>
+
diff -urN rxvt-2.7.2-orig/W11/X11/Xatom.h rxvt-2.7.2/W11/X11/Xatom.h
--- rxvt-2.7.2-orig/W11/X11/Xatom.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/X11/Xatom.h	Sat Apr 14 16:49:08 2001
@@ -0,0 +1,4 @@
+
+typedef int CARD32;
+
+#define XA_PRIMARY ((Atom) 1)
diff -urN rxvt-2.7.2-orig/W11/X11/Xlib.h rxvt-2.7.2/W11/X11/Xlib.h
--- rxvt-2.7.2-orig/W11/X11/Xlib.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/X11/Xlib.h	Sat Apr 14 16:49:08 2001
@@ -0,0 +1,2239 @@
+/* 
+
+Copyright 1985, 1986, 1987, 1991, 1998  The Open Group
+
+All Rights Reserved.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+#ifndef __XLIB_H
+#define __XLIB_H
+
+/* typedef struct _XrmHashBucketRec; */
+typedef unsigned long Atom;
+typedef unsigned long Time;
+typedef unsigned long XID;
+
+#ifndef Bool
+#define Bool int
+#endif
+
+typedef int BoolDef;
+
+typedef XID Window;
+typedef XID Drawable;
+typedef XID Font;
+typedef XID Pixmap;
+typedef XID Cursor;
+typedef XID Colormap;
+typedef XID KeySym;
+typedef XID GContext;
+
+typedef unsigned char KeyCode;
+
+typedef char *XPointer;
+typedef unsigned long VisualID;
+
+#define PIXEL_ALREADY_TYPEDEFED
+typedef unsigned long Pixel;
+
+#define XDestroyImage(ximage) \
+	((*((ximage)->f.destroy_image))((ximage)))
+#define XPutPixel(ximage, x, y, pixel) \
+	((*((ximage)->f.put_pixel))((ximage), (x), (y), (pixel)))
+
+#define AllPlanes 		((unsigned long)~0L)
+#define ScreenOfDisplay(dpy, scr)(&((_XPrivDisplay)dpy)->screens[scr])
+#define DefaultVisual(dpy, scr) (ScreenOfDisplay(dpy,scr)->root_visual)
+#define DefaultDepth(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->root_depth)
+#define DefaultColormap(dpy, scr)(ScreenOfDisplay(dpy,scr)->cmap)
+#define DefaultScreen(dpy) 	(((_XPrivDisplay)dpy)->default_screen)
+#define RootWindow(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->root)
+#define DefaultRootWindow(dpy) 	(ScreenOfDisplay(dpy,DefaultScreen(dpy))->root)
+#define DisplayWidth(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->width)
+#define DisplayHeight(dpy, scr) (ScreenOfDisplay(dpy,scr)->height)
+
+#ifndef None
+#define None                 0L	/* universal null resource or null atom */
+#endif
+
+#define ParentRelative       1L	
+#define CopyFromParent       0L	
+#define PointerWindow        0L	/* destination window in SendEvent */
+#define InputFocus           1L	/* destination window in SendEvent */
+#define PointerRoot          1L	/* focus window in SetInputFocus */
+#define AnyPropertyType      0L	/* special Atom, passed to GetProperty */
+#define AnyKey		     0L	/* special Key Code, passed to GrabKey */
+#define AnyButton            0L	/* special Button Code, passed to GrabButton */
+#define AllTemporary         0L	/* special Resource ID passed to KillClient */
+#define CurrentTime          0L	/* special Time */
+#define NoSymbol	     0L	/* special KeySym */
+#define NoEventMask			0L
+#define KeyPressMask			(1L<<0)  
+#define KeyReleaseMask			(1L<<1)  
+#define ButtonPressMask			(1L<<2)  
+#define ButtonReleaseMask		(1L<<3)  
+#define EnterWindowMask			(1L<<4)  
+#define LeaveWindowMask			(1L<<5)  
+#define PointerMotionMask		(1L<<6)  
+#define PointerMotionHintMask		(1L<<7)  
+#define Button1MotionMask		(1L<<8)  
+#define Button2MotionMask		(1L<<9)  
+#define Button3MotionMask		(1L<<10) 
+#define Button4MotionMask		(1L<<11) 
+#define Button5MotionMask		(1L<<12) 
+#define ButtonMotionMask		(1L<<13) 
+#define KeymapStateMask			(1L<<14)
+#define ExposureMask			(1L<<15) 
+#define VisibilityChangeMask		(1L<<16) 
+#define StructureNotifyMask		(1L<<17) 
+#define ResizeRedirectMask		(1L<<18) 
+#define SubstructureNotifyMask		(1L<<19) 
+#define SubstructureRedirectMask	(1L<<20) 
+#define FocusChangeMask			(1L<<21) 
+#define PropertyChangeMask		(1L<<22) 
+#define ColormapChangeMask		(1L<<23) 
+#define OwnerGrabButtonMask		(1L<<24) 
+#define KeyPress		2
+#define KeyRelease		3
+#define ButtonPress		4
+#define ButtonRelease		5
+#define MotionNotify		6
+#define EnterNotify		7
+#define LeaveNotify		8
+#define FocusIn			9
+#define FocusOut		10
+#define KeymapNotify		11
+#define Expose			12
+#define GraphicsExpose		13
+#define NoExpose		14
+#define VisibilityNotify	15
+#define CreateNotify		16
+#define DestroyNotify		17
+#define UnmapNotify		18
+#define MapNotify		19
+#define MapRequest		20
+#define ReparentNotify		21
+#define ConfigureNotify		22
+#define ConfigureRequest	23
+#define GravityNotify		24
+#define ResizeRequest		25
+#define CirculateNotify		26
+#define CirculateRequest	27
+#define PropertyNotify		28
+#define SelectionClear		29
+#define SelectionRequest	30
+#define SelectionNotify		31
+#define ColormapNotify		32
+#define ClientMessage		33
+#define MappingNotify		34
+#define LASTEvent		35	/* must be bigger than any event # */
+#define ShiftMask		(1<<0)
+#define LockMask		(1<<1)
+#define ControlMask		(1<<2)
+#define Mod1Mask		(1<<3)
+#define Mod2Mask		(1<<4)
+#define Mod3Mask		(1<<5)
+#define Mod4Mask		(1<<6)
+#define Mod5Mask		(1<<7)
+#define ShiftMapIndex		0
+#define LockMapIndex		1
+#define ControlMapIndex		2
+#define Mod1MapIndex		3
+#define Mod2MapIndex		4
+#define Mod3MapIndex		5
+#define Mod4MapIndex		6
+#define Mod5MapIndex		7
+#define Button1Mask		(1<<8)
+#define Button2Mask		(1<<9)
+#define Button3Mask		(1<<10)
+#define Button4Mask		(1<<11)
+#define Button5Mask		(1<<12)
+#define AnyModifier		(1<<15)  /* used in GrabButton, GrabKey */
+#define Button1			1
+#define Button2			2
+#define Button3			3
+#define Button4			4
+#define Button5			5
+#define NotifyNormal		0
+#define NotifyGrab		1
+#define NotifyUngrab		2
+#define NotifyWhileGrabbed	3
+#define NotifyHint		1	/* for MotionNotify events */
+#define NotifyAncestor		0
+#define NotifyVirtual		1
+#define NotifyInferior		2
+#define NotifyNonlinear		3
+#define NotifyNonlinearVirtual	4
+#define NotifyPointer		5
+#define NotifyPointerRoot	6
+#define NotifyDetailNone	7
+#define VisibilityUnobscured		0
+#define VisibilityPartiallyObscured	1
+#define VisibilityFullyObscured		2
+#define PlaceOnTop		0
+#define PlaceOnBottom		1
+#define FamilyInternet		0
+#define FamilyDECnet		1
+#define FamilyChaos		2
+#define PropertyNewValue	0
+#define PropertyDelete		1
+#define ColormapUninstalled	0
+#define ColormapInstalled	1
+#define GrabModeSync		0
+#define GrabModeAsync		1
+#define GrabSuccess		0
+#define AlreadyGrabbed		1
+#define GrabInvalidTime		2
+#define GrabNotViewable		3
+#define GrabFrozen		4
+#define AsyncPointer		0
+#define SyncPointer		1
+#define ReplayPointer		2
+#define AsyncKeyboard		3
+#define SyncKeyboard		4
+#define ReplayKeyboard		5
+#define AsyncBoth		6
+#define SyncBoth		7
+#define RevertToNone		(int)None
+#define RevertToPointerRoot	(int)PointerRoot
+#define RevertToParent		2
+#define Success		   0	/* everything's okay */
+#define BadRequest	   1	/* bad request code */
+#define BadValue	   2	/* int parameter out of range */
+#define BadWindow	   3	/* parameter not a Window */
+#define BadPixmap	   4	/* parameter not a Pixmap */
+#define BadAtom		   5	/* parameter not an Atom */
+#define BadCursor	   6	/* parameter not a Cursor */
+#define BadFont		   7	/* parameter not a Font */
+#define BadMatch	   8	/* parameter mismatch */
+#define BadDrawable	   9	/* parameter not a Pixmap or Window */
+#define BadAccess	  10   
+#define BadAlloc	  11	/* insufficient resources */
+#define BadColor	  12	/* no such colormap */
+#define BadGC		  13	/* parameter not a GC */
+#define BadIDChoice	  14	/* choice not in range or already used */
+#define BadName		  15	/* font or color name doesn't exist */
+#define BadLength	  16	/* Request length incorrect */
+#define BadImplementation 17	/* server is defective */
+#define FirstExtensionError	128
+#define LastExtensionError	255
+#define InputOutput		1
+#define InputOnly		2
+#define CWBackPixmap		(1L<<0)
+#define CWBackPixel		(1L<<1)
+#define CWBorderPixmap		(1L<<2)
+#define CWBorderPixel           (1L<<3)
+#define CWBitGravity		(1L<<4)
+#define CWWinGravity		(1L<<5)
+#define CWBackingStore          (1L<<6)
+#define CWBackingPlanes	        (1L<<7)
+#define CWBackingPixel	        (1L<<8)
+#define CWOverrideRedirect	(1L<<9)
+#define CWSaveUnder		(1L<<10)
+#define CWEventMask		(1L<<11)
+#define CWDontPropagate	        (1L<<12)
+#define CWColormap		(1L<<13)
+#define CWCursor	        (1L<<14)
+#define CWX			(1<<0)
+#define CWY			(1<<1)
+#define CWWidth			(1<<2)
+#define CWHeight		(1<<3)
+#define CWBorderWidth		(1<<4)
+#define CWSibling		(1<<5)
+#define CWStackMode		(1<<6)
+#define ForgetGravity		0
+#define NorthWestGravity	1
+#define NorthGravity		2
+#define NorthEastGravity	3
+#define WestGravity		4
+#define CenterGravity		5
+#define EastGravity		6
+#define SouthWestGravity	7
+#define SouthGravity		8
+#define SouthEastGravity	9
+#define StaticGravity		10
+#define UnmapGravity		0
+#define NotUseful               0
+#define WhenMapped              1
+#define Always                  2
+#define IsUnmapped		0
+#define IsUnviewable		1
+#define IsViewable		2
+#define SetModeInsert           0
+#define SetModeDelete           1
+#define DestroyAll              0
+#define RetainPermanent         1
+#define RetainTemporary         2
+#define Above                   0
+#define Below                   1
+#define TopIf                   2
+#define BottomIf                3
+#define Opposite                4
+#define RaiseLowest             0
+#define LowerHighest            1
+#define PropModeReplace         0
+#define PropModePrepend         1
+#define PropModeAppend          2
+#define	GXclear			0x0		/* 0 */
+#define GXand			0x1		/* src AND dst */
+#define GXandReverse		0x2		/* src AND NOT dst */
+#define GXcopy			0x3		/* src */
+#define GXandInverted		0x4		/* NOT src AND dst */
+#define	GXnoop			0x5		/* dst */
+#define GXxor			0x6		/* src XOR dst */
+#define GXor			0x7		/* src OR dst */
+#define GXnor			0x8		/* NOT src AND NOT dst */
+#define GXequiv			0x9		/* NOT src XOR dst */
+#define GXinvert		0xa		/* NOT dst */
+#define GXorReverse		0xb		/* src OR NOT dst */
+#define GXcopyInverted		0xc		/* NOT src */
+#define GXorInverted		0xd		/* NOT src OR dst */
+#define GXnand			0xe		/* NOT src OR NOT dst */
+#define GXset			0xf		/* 1 */
+#define LineSolid		0
+#define LineOnOffDash		1
+#define LineDoubleDash		2
+#define CapNotLast		0
+#define CapButt			1
+#define CapRound		2
+#define CapProjecting		3
+#define JoinMiter		0
+#define JoinRound		1
+#define JoinBevel		2
+#define FillSolid		0
+#define FillTiled		1
+#define FillStippled		2
+#define FillOpaqueStippled	3
+#define EvenOddRule		0
+#define WindingRule		1
+#define ClipByChildren		0
+#define IncludeInferiors	1
+#define Unsorted		0
+#define YSorted			1
+#define YXSorted		2
+#define YXBanded		3
+#define CoordModeOrigin		0	/* relative to the origin */
+#define CoordModePrevious       1	/* relative to previous point */
+#define Complex			0	/* paths may intersect */
+#define Nonconvex		1	/* no paths intersect, but not convex */
+#define Convex			2	/* wholly convex */
+#define ArcChord		0	/* join endpoints of arc */
+#define ArcPieSlice		1	/* join endpoints to center of arc */
+#define GCFunction              (1L<<0)
+#define GCPlaneMask             (1L<<1)
+#define GCForeground            (1L<<2)
+#define GCBackground            (1L<<3)
+#define GCLineWidth             (1L<<4)
+#define GCLineStyle             (1L<<5)
+#define GCCapStyle              (1L<<6)
+#define GCJoinStyle		(1L<<7)
+#define GCFillStyle		(1L<<8)
+#define GCFillRule		(1L<<9) 
+#define GCTile			(1L<<10)
+#define GCStipple		(1L<<11)
+#define GCTileStipXOrigin	(1L<<12)
+#define GCTileStipYOrigin	(1L<<13)
+#define GCFont 			(1L<<14)
+#define GCSubwindowMode		(1L<<15)
+#define GCGraphicsExposures     (1L<<16)
+#define GCClipXOrigin		(1L<<17)
+#define GCClipYOrigin		(1L<<18)
+#define GCClipMask		(1L<<19)
+#define GCDashOffset		(1L<<20)
+#define GCDashList		(1L<<21)
+#define GCArcMode		(1L<<22)
+#define GCLastBit		22
+#define FontLeftToRight		0
+#define FontRightToLeft		1
+#define FontChange		255
+#define XYBitmap		0	/* depth 1, XYFormat */
+#define XYPixmap		1	/* depth == drawable depth */
+#define ZPixmap			2	/* depth == drawable depth */
+#define AllocNone		0	/* create map with no entries */
+#define AllocAll		1	/* allocate entire map writeable */
+#define DoRed			(1<<0)
+#define DoGreen			(1<<1)
+#define DoBlue			(1<<2)
+#define CursorShape		0	/* largest size that can be displayed */
+#define TileShape		1	/* size tiled fastest */
+#define StippleShape		2	/* size stippled fastest */
+#define AutoRepeatModeOff	0
+#define AutoRepeatModeOn	1
+#define AutoRepeatModeDefault	2
+#define LedModeOff		0
+#define LedModeOn		1
+#define KBKeyClickPercent	(1L<<0)
+#define KBBellPercent		(1L<<1)
+#define KBBellPitch		(1L<<2)
+#define KBBellDuration		(1L<<3)
+#define KBLed			(1L<<4)
+#define KBLedMode		(1L<<5)
+#define KBKey			(1L<<6)
+#define KBAutoRepeatMode	(1L<<7)
+#define MappingSuccess     	0
+#define MappingBusy        	1
+#define MappingFailed		2
+#define MappingModifier		0
+#define MappingKeyboard		1
+#define MappingPointer		2
+#define DontPreferBlanking	0
+#define PreferBlanking		1
+#define DefaultBlanking		2
+#define DisableScreenSaver	0
+#define DisableScreenInterval	0
+#define DontAllowExposures	0
+#define AllowExposures		1
+#define DefaultExposures	2
+#define ScreenSaverReset 0
+#define ScreenSaverActive 1
+#define HostInsert		0
+#define HostDelete		1
+#define EnableAccess		1      
+#define DisableAccess		0
+#define StaticGray		0
+#define GrayScale		1
+#define StaticColor		2
+#define PseudoColor		3
+#define TrueColor		4
+#define DirectColor		5
+#define LSBFirst		0
+#define MSBFirst		1
+
+#define True 1
+#define False 0
+
+#define XK_Alt_L		0xFFE9	/* Left alt */
+
+#define XK_BackSpace		0xFF08	/* back space, back char */
+#define XK_Tab			0xFF09
+#define XK_Linefeed		0xFF0A	/* Linefeed, LF */
+#define XK_Clear		0xFF0B
+#define XK_Return		0xFF0D	/* Return, enter */
+#define XK_Pause		0xFF13	/* Pause, hold */
+#define XK_Scroll_Lock		0xFF14
+#define XK_Sys_Req		0xFF15
+#define XK_Escape		0xFF1B
+#define XK_Delete		0xFFFF	/* Delete, rubout */
+
+#define XK_Home			0xFF50
+#define XK_Left			0xFF51	/* Move left, left arrow */
+#define XK_Up			0xFF52	/* Move up, up arrow */
+#define XK_Right		0xFF53	/* Move right, right arrow */
+#define XK_Down			0xFF54	/* Move down, down arrow */
+#define XK_Prior		0xFF55	/* Prior, previous */
+#define XK_Page_Up		0xFF55
+#define XK_Next			0xFF56	/* Next */
+#define XK_Page_Down		0xFF56
+#define XK_End			0xFF57	/* EOL */
+#define XK_Begin		0xFF58	/* BOL */
+
+#define XK_Select		0xFF60	/* Select, mark */
+#define XK_Print		0xFF61
+#define XK_Execute		0xFF62	/* Execute, run, do */
+#define XK_Insert		0xFF63	/* Insert, insert here */
+#define XK_Undo			0xFF65	/* Undo, oops */
+#define XK_Redo			0xFF66	/* redo, again */
+#define XK_Menu			0xFF67
+#define XK_Find			0xFF68	/* Find, search */
+#define XK_Cancel		0xFF69	/* Cancel, stop, abort, exit */
+#define XK_Help			0xFF6A	/* Help */
+#define XK_Break		0xFF6B
+#define XK_Mode_switch		0xFF7E	/* Character set switch */
+#define XK_script_switch        0xFF7E  /* Alias for mode_switch */
+#define XK_Num_Lock		0xFF7F
+
+#define XK_F1			0xFFBE
+#define XK_F2			0xFFBF
+#define XK_F3			0xFFC0
+#define XK_F4			0xFFC1
+#define XK_F5			0xFFC2
+#define XK_F6			0xFFC3
+#define XK_F7			0xFFC4
+#define XK_F8			0xFFC5
+#define XK_F9			0xFFC6
+#define XK_F10			0xFFC7
+#define XK_F11			0xFFC8
+#define XK_L1			0xFFC8
+#define XK_F12			0xFFC9
+
+#define VisualNoMask		0x0
+#define VisualIDMask 		0x1
+#define VisualScreenMask	0x2
+#define VisualDepthMask		0x4
+#define VisualClassMask		0x8
+#define VisualRedMaskMask	0x10
+#define VisualGreenMaskMask	0x20
+#define VisualBlueMaskMask	0x40
+#define VisualColormapSizeMask	0x80
+#define VisualBitsPerRGBMask	0x100
+#define VisualAllMask		0x1FF
+
+#define USPosition	(1L << 0) /* user specified x, y */
+#define USSize		(1L << 1) /* user specified width, height */
+
+#define PPosition	(1L << 2) /* program specified position */
+#define PSize		(1L << 3) /* program specified size */
+#define PMinSize	(1L << 4) /* program specified minimum size */
+#define PMaxSize	(1L << 5) /* program specified maximum size */
+#define PResizeInc	(1L << 6) /* program specified resize increments */
+#define PAspect		(1L << 7) /* program specified min and max aspect ratios */
+#define PBaseSize	(1L << 8) /* program specified base for incrementing */
+#define PWinGravity	(1L << 9) /* program specified window gravity */
+
+#define NoValue		0x0000
+#define XValue  	0x0001
+#define YValue		0x0002
+#define WidthValue  	0x0004
+#define HeightValue  	0x0008
+#define AllValues 	0x000F
+#define XNegative 	0x0010
+#define YNegative 	0x0020
+
+#define XA_CUT_BUFFER0 ((Atom) 9)
+#define XA_STRING ((Atom) 31)
+#define XA_LAST_PREDEFINED ((Atom) 68)
+
+#define XNoMemory -1
+#define XLocaleNotSupported -2
+#define XConverterNotFound -3
+
+#define LC_CTYPE 2
+
+/* used by rxvt/src/main.c */
+#define NormalState 1
+#define IconicState 3
+#define InputHint (1L << 0)
+#define StateHint (1L << 1)
+#define WindowGroupHint (1L << 6)
+#define XC_left_ptr 68
+#define XC_xterm 152
+
+typedef struct _XRegion *Region;
+typedef struct _XOC *XOC, *XFontSet;
+
+typedef struct _XExtData {
+	int number;		/* number returned by XRegisterExtension */
+	struct _XExtData *next;	/* next item on list of data for structure */
+	int (*free_private)(	/* called to free private storage */
+	struct _XExtData *extension
+	);
+	XPointer private_data;	/* data private to this extension. */
+} XExtData;
+
+typedef struct {		/* public to extension, cannot be changed */
+	int extension;		/* extension number */
+	int major_opcode;	/* major op-code assigned by server */
+	int first_event;	/* first event number for the extension */
+	int first_error;	/* first error number for the extension */
+} XExtCodes;
+
+typedef struct {
+	XExtData *ext_data;	/* hook for extension to hang data */
+	VisualID visualid;	/* visual id of this visual */
+#if defined(__cplusplus) || defined(c_plusplus)
+	int c_class;		/* C++ class of screen (monochrome, etc.) */
+#else
+	int class;		/* class of screen (monochrome, etc.) */
+#endif
+	unsigned long red_mask, green_mask, blue_mask;	/* mask values */
+	int bits_per_rgb;	/* log base 2 of distinct color values */
+	int map_entries;	/* color map entries */
+} Visual;
+
+typedef struct {
+	int depth;		/* this depth (Z) of the depth */
+	int nvisuals;		/* number of Visual types at this depth */
+	Visual *visuals;	/* list of visuals possible at this depth */
+} Depth;
+
+typedef struct {
+	int function;		/* logical operation */
+	unsigned long plane_mask;/* plane mask */
+	unsigned long foreground;/* foreground pixel */
+	unsigned long background;/* background pixel */
+	int line_width;		/* line width */
+	int line_style;	 	/* LineSolid, LineOnOffDash, LineDoubleDash */
+	int cap_style;	  	/* CapNotLast, CapButt, 
+				   CapRound, CapProjecting */
+	int join_style;	 	/* JoinMiter, JoinRound, JoinBevel */
+	int fill_style;	 	/* FillSolid, FillTiled, 
+				   FillStippled, FillOpaeueStippled */
+	int fill_rule;	  	/* EvenOddRule, WindingRule */
+	int arc_mode;		/* ArcChord, ArcPieSlice */
+	Pixmap tile;		/* tile pixmap for tiling operations */
+	Pixmap stipple;		/* stipple 1 plane pixmap for stipping */
+	int ts_x_origin;	/* offset for tile or stipple operations */
+	int ts_y_origin;
+        Font font;	        /* default text font for text operations */
+	int subwindow_mode;     /* ClipByChildren, IncludeInferiors */
+	BoolDef graphics_exposures;/* boolean, should exposures be generated */
+	int clip_x_origin;	/* origin for clipping */
+	int clip_y_origin;
+	Pixmap clip_mask;	/* bitmap clipping; other calls for rects */
+	int dash_offset;	/* patterned/dashed line information */
+	char dashes;
+} XGCValues;
+
+typedef struct _XGC
+{
+    XExtData *ext_data;	/* hook for extension to hang data */
+    GContext gid;	/* protocol ID for graphics context */
+	int rects;
+	int dashes;
+	XGCValues values;
+	int dirty;
+} *GC;
+
+typedef struct {
+	XExtData *ext_data;	/* hook for extension to hang data */
+	struct _XDisplay *display;/* back pointer to display structure */
+	Window root;		/* Root window id. */
+	int width, height;	/* width and height of screen */
+	int mwidth, mheight;	/* width and height of  in millimeters */
+	int ndepths;		/* number of depths possible */
+	Depth *depths;		/* list of allowable depths on the screen */
+	int root_depth;		/* bits per pixel */
+	Visual *root_visual;	/* root visual */
+	GC default_gc;		/* GC for the root root visual */
+	Colormap cmap;		/* default color map */
+	unsigned long white_pixel;
+	unsigned long black_pixel;	/* White and Black pixel values */
+	int max_maps, min_maps;	/* max and min color maps */
+	int backing_store;	/* Never, WhenMapped, Always */
+	BoolDef save_unders;	
+	long root_input_mask;	/* initial root input mask */
+} Screen;
+
+typedef struct {
+	XExtData *ext_data;	/* hook for extension to hang data */
+	int depth;		/* depth of this image format */
+	int bits_per_pixel;	/* bits/pixel at this depth */
+	int scanline_pad;	/* scanline must padded to this multiple */
+} ScreenFormat;
+
+typedef struct _XDisplay
+{
+	XExtData *ext_data;	/* hook for extension to hang data */
+	struct _XPrivate *private1;
+	int fd;			/* Network socket. */
+	int private2;
+	int proto_major_version;/* major version of server's X protocol */
+	int proto_minor_version;/* minor version of servers X protocol */
+	char *vendor;		/* vendor of the server hardware */
+	XID private3;
+	XID private4;
+	XID private5;
+	int private6;
+	XID (*resource_alloc)(	/* allocator function */
+		struct _XDisplay*
+	);
+	int byte_order;		/* screen byte order, LSBFirst, MSBFirst */
+	int bitmap_unit;	/* padding and data requirements */
+	int bitmap_pad;		/* padding requirements on bitmaps */
+	int bitmap_bit_order;	/* LeastSignificant or MostSignificant */
+	int nformats;		/* number of pixmap formats in list */
+	ScreenFormat *pixmap_format;	/* pixmap format list */
+	int private8;
+	int release;		/* release of the server */
+	struct _XPrivate *private9, *private10;
+	int qlen;		/* Length of input event queue */
+	unsigned long last_request_read; /* seq number of last event read */
+	unsigned long request;	/* sequence number of last request. */
+	XPointer private11;
+	XPointer private12;
+	XPointer private13;
+	XPointer private14;
+	unsigned max_request_size; /* maximum number 32 bit words in request*/
+	struct _XrmHashBucketRec *db;
+	int (*private15)(
+		struct _XDisplay*
+		);
+	char *display_name;	/* "host:display" string used on this connect*/
+	int default_screen;	/* default screen for operations */
+	int nscreens;		/* number of screens on this server*/
+	Screen *screens;	/* pointer to list of screens */
+	unsigned long motion_buffer;	/* size of motion buffer */
+	unsigned long private16;
+	int min_keycode;	/* minimum defined keycode */
+	int max_keycode;	/* maximum defined keycode */
+	XPointer private17;
+	XPointer private18;
+	int private19;
+	char *xdefaults;	/* contents of defaults from server */
+	/* there is more to this structure, but it is private to Xlib */
+}
+Display, *_XPrivDisplay;
+
+typedef int StatusDef;
+
+typedef struct {		/* normal 16 bit characters are two bytes */
+    unsigned char byte1;
+    unsigned char byte2;
+} XChar2b;
+
+typedef struct {
+    short	lbearing;	/* origin to left edge of raster */
+    short	rbearing;	/* origin to right edge of raster */
+    short	width;		/* advance to next char's origin */
+    short	ascent;		/* baseline to top edge of raster */
+    short	descent;	/* baseline to bottom edge of raster */
+    unsigned short attributes;	/* per char flags (not predefined) */
+} XCharStruct;
+
+typedef struct {
+	char *res_name;
+	char *res_class;
+} XClassHint;
+
+typedef struct {
+	unsigned long pixel;
+	unsigned short red, green, blue;
+	char flags;  /* do_red, do_green, do_blue */
+	char pad;
+} XColor;
+
+typedef struct _XComposeStatus {
+    XPointer compose_ptr;	/* state table pointer */
+    int chars_matched;		/* match state */
+} XComposeStatus;
+
+/* events --- goes on for a bit */
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* "event" window it is reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	unsigned int state;	/* key or button mask */
+	unsigned int keycode;	/* detail */
+	BoolDef same_screen;	/* same screen flag */
+} XKeyEvent;
+
+typedef XKeyEvent XKeyPressedEvent;
+typedef XKeyEvent XKeyReleasedEvent;
+
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* "event" window it is reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	unsigned int state;	/* key or button mask */
+	unsigned int button;	/* detail */
+	BoolDef same_screen;	/* same screen flag */
+} XButtonEvent;
+typedef XButtonEvent XButtonPressedEvent;
+typedef XButtonEvent XButtonReleasedEvent;
+
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* "event" window reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	unsigned int state;	/* key or button mask */
+	char is_hint;		/* detail */
+	BoolDef same_screen;	/* same screen flag */
+} XMotionEvent;
+typedef XMotionEvent XPointerMovedEvent;
+
+typedef struct {
+	int type;		/* of event */
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;	        /* "event" window reported relative to */
+	Window root;	        /* root window that the event occurred on */
+	Window subwindow;	/* child window */
+	Time time;		/* milliseconds */
+	int x, y;		/* pointer x, y coordinates in event window */
+	int x_root, y_root;	/* coordinates relative to root */
+	int mode;		/* NotifyNormal, NotifyGrab, NotifyUngrab */
+	int detail;
+	/*
+	 * NotifyAncestor, NotifyVirtual, NotifyInferior, 
+	 * NotifyNonlinear,NotifyNonlinearVirtual
+	 */
+	BoolDef same_screen;	/* same screen flag */
+	BoolDef focus;		/* boolean focus */
+	unsigned int state;	/* key or button mask */
+} XCrossingEvent;
+typedef XCrossingEvent XEnterWindowEvent;
+typedef XCrossingEvent XLeaveWindowEvent;
+
+typedef struct {
+	int type;		/* FocusIn or FocusOut */
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;		/* window of event */
+	int mode;		/* NotifyNormal, NotifyGrab, NotifyUngrab */
+	int detail;
+	/*
+	 * NotifyAncestor, NotifyVirtual, NotifyInferior, 
+	 * NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
+	 * NotifyPointerRoot, NotifyDetailNone 
+	 */
+} XFocusChangeEvent;
+typedef XFocusChangeEvent XFocusInEvent;
+typedef XFocusChangeEvent XFocusOutEvent;
+
+/* generated on EnterWindow and FocusIn  when KeyMapState selected */
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	char key_vector[32];
+} XKeymapEvent;	
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	int x, y;
+	int width, height;
+	int count;		/* if non-zero, at least this many more */
+} XExposeEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Drawable drawable;
+	int x, y;
+	int width, height;
+	int count;		/* if non-zero, at least this many more */
+	int major_code;		/* core is CopyArea or CopyPlane */
+	int minor_code;		/* not defined in the core */
+} XGraphicsExposeEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Drawable drawable;
+	int major_code;		/* core is CopyArea or CopyPlane */
+	int minor_code;		/* not defined in the core */
+} XNoExposeEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	int state;		/* Visibility state */
+} XVisibilityEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;		/* parent of the window */
+	Window window;		/* window id of window created */
+	int x, y;		/* window location */
+	int width, height;	/* size of window */
+	int border_width;	/* border width */
+	BoolDef override_redirect;	/* creation should be overridden */
+} XCreateWindowEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+} XDestroyWindowEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	BoolDef from_configure;
+} XUnmapEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	BoolDef override_redirect;	/* boolean, is override set... */
+} XMapEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;
+	Window window;
+} XMapRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	Window parent;
+	int x, y;
+	BoolDef override_redirect;
+} XReparentEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	int x, y;
+	int width, height;
+	int border_width;
+	Window above;
+	BoolDef override_redirect;
+} XConfigureEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	int x, y;
+} XGravityEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	int width, height;
+} XResizeRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;
+	Window window;
+	int x, y;
+	int width, height;
+	int border_width;
+	Window above;
+	int detail;		/* Above, Below, TopIf, BottomIf, Opposite */
+	unsigned long value_mask;
+} XConfigureRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window event;
+	Window window;
+	int place;		/* PlaceOnTop, PlaceOnBottom */
+} XCirculateEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window parent;
+	Window window;
+	int place;		/* PlaceOnTop, PlaceOnBottom */
+} XCirculateRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Atom atom;
+	Time time;
+	int state;		/* NewValue, Deleted */
+} XPropertyEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Atom selection;
+	Time time;
+} XSelectionClearEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window owner;
+	Window requestor;
+	Atom selection;
+	Atom target;
+	Atom property;
+	Time time;
+} XSelectionRequestEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window requestor;
+	Atom selection;
+	Atom target;
+	Atom property;		/* ATOM or None */
+	Time time;
+} XSelectionEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Colormap colormap;	/* COLORMAP or None */
+#if defined(__cplusplus) || defined(c_plusplus)
+	BoolDef c_new;		/* C++ */
+#else
+	BoolDef new;
+#endif
+	int state;		/* ColormapInstalled, ColormapUninstalled */
+} XColormapEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;
+	Atom message_type;
+	int format;
+	union {
+		char b[20];
+		short s[10];
+		long l[5];
+		} data;
+} XClientMessageEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;	/* Display the event was read from */
+	Window window;		/* unused */
+	int request;		/* one of MappingModifier, MappingKeyboard,
+				   MappingPointer */
+	int first_keycode;	/* first keycode */
+	int count;		/* defines range of change w. first_keycode*/
+} XMappingEvent;
+
+typedef struct {
+	int type;
+	Display *display;	/* Display the event was read from */
+	XID resourceid;		/* resource id */
+	unsigned long serial;	/* serial number of failed request */
+	unsigned char error_code;	/* error code of failed request */
+	unsigned char request_code;	/* Major op-code of failed request */
+	unsigned char minor_code;	/* Minor op-code of failed request */
+} XErrorEvent;
+
+typedef struct {
+	int type;
+	unsigned long serial;	/* # of last request processed by server */
+	BoolDef send_event;	/* true if this came from a SendEvent request */
+	Display *display;/* Display the event was read from */
+	Window window;	/* window on which event was requested in event mask */
+} XAnyEvent;
+
+/*
+ * this union is defined so Xlib can always use the same sized
+ * event structure internally, to avoid memory fragmentation.
+ */
+typedef union _XEvent {
+        int type;		/* must not be changed; first element */
+	XAnyEvent xany;
+	XKeyEvent xkey;
+	XButtonEvent xbutton;
+	XMotionEvent xmotion;
+	XCrossingEvent xcrossing;
+	XFocusChangeEvent xfocus;
+	XExposeEvent xexpose;
+	XGraphicsExposeEvent xgraphicsexpose;
+	XNoExposeEvent xnoexpose;
+	XVisibilityEvent xvisibility;
+	XCreateWindowEvent xcreatewindow;
+	XDestroyWindowEvent xdestroywindow;
+	XUnmapEvent xunmap;
+	XMapEvent xmap;
+	XMapRequestEvent xmaprequest;
+	XReparentEvent xreparent;
+	XConfigureEvent xconfigure;
+	XGravityEvent xgravity;
+	XResizeRequestEvent xresizerequest;
+	XConfigureRequestEvent xconfigurerequest;
+	XCirculateEvent xcirculate;
+	XCirculateRequestEvent xcirculaterequest;
+	XPropertyEvent xproperty;
+	XSelectionClearEvent xselectionclear;
+	XSelectionRequestEvent xselectionrequest;
+	XSelectionEvent xselection;
+	XColormapEvent xcolormap;
+	XClientMessageEvent xclient;
+	XMappingEvent xmapping;
+	XErrorEvent xerror;
+	XKeymapEvent xkeymap;
+	long pad[24];
+} XEvent;
+
+typedef int (*XErrorHandler) (	    /* WARNING, this type not in Xlib spec */
+    Display*		/* display */,
+    XErrorEvent*	/* error_event */
+);
+
+
+typedef struct {
+    Atom name;
+    unsigned long card32;
+} XFontProp;
+
+typedef struct {
+    XExtData	*ext_data;	/* hook for extension to hang data */
+    Font        fid;            /* Font id for this font */
+    unsigned	direction;	/* hint about direction the font is painted */
+    unsigned	min_char_or_byte2;/* first character */
+    unsigned	max_char_or_byte2;/* last character */
+    unsigned	min_byte1;	/* first row that exists */
+    unsigned	max_byte1;	/* last row that exists */
+    BoolDef all_chars_exist;/* flag if all characters have non-zero size*/
+    unsigned	default_char;	/* char to print for undefined character */
+    int         n_properties;   /* how many properties there are */
+    XFontProp	*properties;	/* pointer to array of additional properties*/
+    XCharStruct	min_bounds;	/* minimum bounds over all existing char*/
+    XCharStruct	max_bounds;	/* maximum bounds over all existing char*/
+    XCharStruct	*per_char;	/* first_char to last_char information */
+    int		ascent;		/* log. extent above baseline for spacing */
+    int		descent;	/* log. descent below baseline for spacing */
+} XFontStruct;
+
+typedef enum {
+    XStringStyle,		/* STRING */
+    XCompoundTextStyle,		/* COMPOUND_TEXT */
+    XTextStyle,			/* text in owner's encoding (current locale)*/
+    XStdICCTextStyle,		/* STRING, else COMPOUND_TEXT */
+    XUTF8StringStyle		/* UTF8_STRING */
+} XICCEncodingStyle;
+
+typedef struct _XIM *XIM;
+typedef struct _XIC *XIC;
+
+/*
+ * Data structure for "image" data, used by image manipulation routines.
+ */
+typedef struct _XImage {
+    int width, height;		/* size of image */
+    int xoffset;		/* number of pixels offset in X direction */
+    int format;			/* XYBitmap, XYPixmap, ZPixmap */
+    char *data;			/* pointer to image data */
+    int byte_order;		/* data byte order, LSBFirst, MSBFirst */
+    int bitmap_unit;		/* quant. of scanline 8, 16, 32 */
+    int bitmap_bit_order;	/* LSBFirst, MSBFirst */
+    int bitmap_pad;		/* 8, 16, 32 either XY or ZPixmap */
+    int depth;			/* depth of image */
+    int bytes_per_line;		/* accelarator to next line */
+    int bits_per_pixel;		/* bits per pixel (ZPixmap) */
+    unsigned long red_mask;	/* bits in z arrangment */
+    unsigned long green_mask;
+    unsigned long blue_mask;
+    XPointer obdata;		/* hook for the object routines to hang on */
+    struct funcs {		/* image manipulation routines */
+	struct _XImage *(*create_image)(
+		struct _XDisplay* /* display */,
+		Visual*		/* visual */,
+		unsigned int	/* depth */,
+		int		/* format */,
+		int		/* offset */,
+		char*		/* data */,
+		unsigned int	/* width */,
+		unsigned int	/* height */,
+		int		/* bitmap_pad */,
+		int		/* bytes_per_line */);
+	int (*destroy_image)        (struct _XImage *);
+	unsigned long (*get_pixel)  (struct _XImage *, int, int);
+	int (*put_pixel)            (struct _XImage *, int, int, unsigned long);
+	struct _XImage *(*sub_image)(struct _XImage *, int, int, unsigned int, unsigned int);
+	int (*add_pixel)            (struct _XImage *, long);
+	} f;
+} XImage;
+
+typedef struct {
+ 	int max_keypermod;	/* The server's max # of keys per modifier */
+ 	KeyCode *modifiermap;	/* An 8 by max_keypermod array of modifiers */
+} XModifierKeymap;
+
+typedef struct {
+    short x, y;
+} XPoint;
+
+typedef struct {
+    short x, y;
+    unsigned short width, height;
+} XRectangle;
+
+typedef struct {
+    short x1, y1, x2, y2;
+} XSegment;
+
+typedef struct {
+    Pixmap background_pixmap;	/* background or None or ParentRelative */
+    unsigned long background_pixel;	/* background pixel */
+    Pixmap border_pixmap;	/* border of the window */
+    unsigned long border_pixel;	/* border pixel value */
+    int bit_gravity;		/* one of bit gravity values */
+    int win_gravity;		/* one of the window gravity values */
+    int backing_store;		/* NotUseful, WhenMapped, Always */
+    unsigned long backing_planes;/* planes to be preseved if possible */
+    unsigned long backing_pixel;/* value to use in restoring planes */
+    BoolDef save_under;		/* should bits under be saved? (popups) */
+    long event_mask;		/* set of events that should be saved */
+    long do_not_propagate_mask;	/* set of events that should not propagate */
+    BoolDef override_redirect;	/* boolean value for override-redirect */
+    Colormap colormap;		/* color map to be associated with window */
+    Cursor cursor;		/* cursor to be displayed (or None) */
+} XSetWindowAttributes;
+
+typedef struct {
+	long flags;	/* marks which fields in this structure are defined */
+	int x, y;		/* obsolete for new window mgrs, but clients */
+	int width, height;	/* should set so old wm's don't mess up */
+	int min_width, min_height;
+	int max_width, max_height;
+    	int width_inc, height_inc;
+	struct {
+		int x;	/* numerator */
+		int y;	/* denominator */
+	} min_aspect, max_aspect;
+	int base_width, base_height;		/* added by ICCCM version 1 */
+	int win_gravity;			/* added by ICCCM version 1 */
+} XSizeHints;
+
+typedef struct {
+	Colormap colormap;
+	unsigned long red_max;
+	unsigned long red_mult;
+	unsigned long green_max;
+	unsigned long green_mult;
+	unsigned long blue_max;
+	unsigned long blue_mult;
+	unsigned long base_pixel;
+	VisualID visualid;		/* added by ICCCM version 1 */
+	XID killid;			/* added by ICCCM version 1 */
+} XStandardColormap;
+
+typedef struct {
+    unsigned char *value;		/* same as Property routines */
+    Atom encoding;			/* prop type */
+    int format;				/* prop data format: 8, 16, or 32 */
+    unsigned long nitems;		/* number of data items in value */
+} XTextProperty;
+
+typedef struct {
+  Visual *visual;
+  VisualID visualid;
+  int screen;
+  int depth;
+#if defined(__cplusplus) || defined(c_plusplus)
+  int c_class;					/* C++ */
+#else
+  int class;
+#endif
+  unsigned long red_mask;
+  unsigned long green_mask;
+  unsigned long blue_mask;
+  int colormap_size;
+  int bits_per_rgb;
+} XVisualInfo;
+
+typedef struct {
+	long flags;	/* marks which fields in this structure are defined */
+	BoolDef input;	/* does this application rely on the window manager to
+			get keyboard input? */
+	int initial_state;	/* see below */
+	Pixmap icon_pixmap;	/* pixmap to be used as icon */
+	Window icon_window; 	/* window to be used as icon */
+	int icon_x, icon_y; 	/* initial position of icon */
+	Pixmap icon_mask;	/* icon mask bitmap */
+	XID window_group;	/* id of related window group */
+	/* this structure may be extended in the future */
+} XWMHints;
+
+typedef struct {
+    int x, y;			/* location of window */
+    int width, height;		/* width and height of window */
+    int border_width;		/* border width of window */
+    int depth;          	/* depth of window */
+    Visual *visual;		/* the associated visual structure */
+    Window root;        	/* root of screen containing window */
+#if defined(__cplusplus) || defined(c_plusplus)
+    int c_class;		/* C++ InputOutput, InputOnly*/
+#else
+    int class;			/* InputOutput, InputOnly*/
+#endif
+    int bit_gravity;		/* one of bit gravity values */
+    int win_gravity;		/* one of the window gravity values */
+    int backing_store;		/* NotUseful, WhenMapped, Always */
+    unsigned long backing_planes;/* planes to be preserved if possible */
+    unsigned long backing_pixel;/* value to be used when restoring planes */
+    BoolDef save_under;		/* boolean, should bits under be saved? */
+    Colormap colormap;		/* color map to be associated with window */
+    BoolDef map_installed;		/* boolean, is color map currently installed*/
+    int map_state;		/* IsUnmapped, IsUnviewable, IsViewable */
+    long all_event_masks;	/* set of events all people have interest in*/
+    long your_event_mask;	/* my event mask */
+    long do_not_propagate_mask; /* set of events that should not propagate */
+    BoolDef override_redirect;	/* boolean value for override-redirect */
+    Screen *screen;		/* back pointer to correct screen */
+} XWindowAttributes;
+
+struct _XrmHashBucketRec;
+
+/* needed for xdefaults.c */
+typedef struct _XrmHashBucketRec *XrmDatabase;
+typedef enum {XrmBindTightly, XrmBindLoosely} XrmBinding, *XrmBindingList;
+typedef int       XrmQuark, *XrmQuarkList;
+#define NULLQUARK ((XrmQuark) 0)
+typedef XrmQuark     XrmRepresentation;
+typedef struct {
+    unsigned int    size;
+    XPointer	    addr;
+} XrmValue, *XrmValuePtr;
+
+/* functions */
+
+Display *XOpenDisplay(const char *name);
+
+int XCloseDisplay(Display *display);
+
+char *XDisplayString(Display *display);
+
+int XSync(Display *display,int discard);
+
+int XFlush(Display *display);
+
+XVisualInfo *XGetVisualInfo(
+			    Display *display,
+			    long vinm,
+			    XVisualInfo *vint,
+			    int *n);
+
+StatusDef XMatchVisualInfo(
+    Display*		display,
+    int			screen,
+    int			depth,
+    int			class,
+    XVisualInfo*	vinfo_return);
+
+int XClearWindow(Display *display, Window w);
+
+Window XCreateSimpleWindow(
+		    Display *display,
+		    Window  parent,
+		    int     x, 
+		    int y,
+		    unsigned int brd,
+		    unsigned int w,
+		    unsigned int h,
+		    unsigned long bg, 
+		    unsigned long brd_col);
+
+Window XCreateWindow(
+	      Display *display,
+	      Window  parent,
+	      int x,
+	      int y,
+	      unsigned int width,
+	      unsigned int height,
+	      unsigned int bw,
+	      int depth,
+	      unsigned int class,
+	      Visual *visual,
+	      unsigned long valuemask,
+	      XSetWindowAttributes *attr);
+
+int XDestroyWindow(
+	       Display *display,
+	       Window w);
+
+StatusDef XGetGeometry(
+	     Display *display,
+	     Drawable w,
+	     Window *root,
+	     int *x,
+	     int *y,
+	     unsigned int *width,
+	     unsigned int *height,
+	     unsigned int *bw,
+	     unsigned int *depth);
+
+StatusDef XGetWindowAttributes(Display *display,
+		     Window w,
+		     XWindowAttributes *wattr);
+
+int XSelectInput(Display *display,
+	     Window  window,
+	     long    mask);
+
+int XMapWindow(Display *display,
+	   Window window);
+
+int XIconifyWindow(Display *display,
+	       Window w,
+	       int screen_number);
+GC XCreateGC(
+	  Display *display,
+	  Drawable window,
+	  unsigned long mask,
+	  XGCValues *gc_values);
+
+int XFreeGC(
+	Display *display,
+	GC gc);
+
+int XSetForeground(
+	       Display *display,
+	       GC gc,
+	       unsigned long    color);
+int XDrawString(Display *display, 
+	    Drawable window,
+	    GC gc, 
+	    int x, 
+	    int y, 
+	    const char* str, 
+	    int len);
+int XDrawString16(Display *display, 
+	      Drawable window,
+	      GC gc, int x, int y,
+	      const XChar2b* str,
+	      int len);
+
+int XDrawImageString(
+	Display* display,
+	Drawable d,
+	GC gc,
+	int x,
+	int y,
+	const char* string,
+	int length);
+
+int XDrawImageString16(Display *display, 
+		   Drawable window,
+		   GC gc, int x, int y,
+		   const XChar2b* str,
+		   int len);
+
+int XFillRectangle(
+	       Display *display,
+	       Drawable window,
+	       GC gc,
+	       int x, int y,
+	       unsigned int w, unsigned int h);
+int XClearArea(
+	   Display *display,
+	   Window w,
+	   int x, int y,
+	   unsigned int width, unsigned int height,
+	   BoolDef exposures);
+
+Region XCreateRegion();
+
+int XClipBox(
+	 Region hrgn,
+	 XRectangle *rect);
+
+int XSetRegion(
+	   Display *display,
+	   GC gc,
+	   Region hrgn);
+
+int XDestroyRegion(Region hrgn);
+
+int XUnionRectWithRegion(XRectangle *rect,
+		     Region hrgnsrc,
+		     Region hrgndest);
+int XDrawArc(
+	 Display *display,
+	 Drawable w,
+	 GC gc,
+	 int x, int y,
+	 unsigned int width,unsigned int height,
+	 int a1, int a2);
+
+int XFillArc(
+	 Display *display,
+	 Drawable w,
+	 GC gc,
+	 int x, int y,
+	 unsigned int width,unsigned height,
+	 int a1, int a2);
+
+int XFillPolygon(
+	     Display *display,
+	     Drawable w,
+	     GC gc,
+	     XPoint *points,
+	     int nps, int shape, int mode);
+
+int XDrawLine(
+	  Display *display,
+	  Drawable w,
+	  GC gc,
+	  int x1,int y1, int x2,int y2);
+
+int XDrawLines(
+	   Display *display,
+	   Drawable w,
+	   GC gc,
+	   XPoint *points,
+	   int nps,int mode);
+
+int XDrawPoints(
+	    Display *display,
+	    Drawable w,
+	    GC gc,
+	    XPoint *points,
+	    int nps, int mode);
+
+int XDrawPoint(
+	   Display *display,
+	   Drawable w,
+	   GC gc,
+	   int x, int y);
+int XDrawRectangle(
+	       Display *display,
+	       Drawable w,
+	       GC gc,
+	       int x, int y,
+	       unsigned int width, unsigned int height);
+
+int XDrawSegments(
+	      Display *display,
+	      Drawable w,
+	      GC gc,
+	      XSegment *segs,
+	      int nsegs);
+
+Pixmap XCreatePixmap(
+	      Display *display,
+	      Drawable drawable,
+	      unsigned int width, unsigned int height,
+	      unsigned int depth);
+
+Pixmap XCreateBitmapFromData(Display *display,
+		      Drawable drawable, const char *data,
+		      unsigned int width, unsigned int height);
+int XFreePixmap(
+	 Display *display,
+	 Pixmap pixmap);
+
+int XCopyArea(
+	  Display *display,
+	  Drawable src,
+	  Drawable dest,
+	  GC gc,
+	  int src_x, int src_y,
+	  unsigned int width, unsigned int height,
+	  int dest_x, int dest_y);
+
+XImage *XGetImage(
+		  Display *display,
+		  Drawable drawable,
+		  int x, int y,
+		  unsigned int width, unsigned int height,
+		  unsigned long plane_mask,
+		  int format);
+
+XImage *XCreateImage(
+	     Display *display,
+	     Visual *visual,
+	     unsigned int depth,
+	     int format,
+	     int offset,
+	     char *data,
+	     unsigned int width, unsigned int height,
+	     int bitmap_pad, int bytes_per_line);
+int XPutImage(
+	  Display *display,
+	  Drawable w,
+	  GC gc,
+	  XImage *image,
+	  int sx,int sy,int dx,int dy,
+	  unsigned int width,unsigned int height);
+
+int XSetWindowBackground(
+		     Display *display,
+		     Window w,
+		     unsigned long bg);
+
+int XSetWindowBackgroundPixmap(
+			   Display *display,
+			   Window w,
+			   Pixmap background_tile);
+
+int XSetFillStyle(
+	      Display *display,
+	      GC gc,
+	      int fs);
+
+int XSetDashes(Display *display,
+	   GC gc, int dash_offset,
+	   const char * dash_list,
+	   int n);
+
+int XChangeWindowAttributes(
+			Display *display,
+			Window w,
+			unsigned long vmask,
+			XSetWindowAttributes *attr);
+
+int XLowerWindow(Display *display,
+	     Window w);
+
+int XMapRaised(
+	   Display *display,
+	   Window w);
+
+int
+XMapSubwindows(
+	       Display *display,
+	       Window w);
+
+StatusDef
+XQueryTree(
+	   Display *display,
+	   Window w,
+	   Window* root,
+	   Window* parent,
+	   Window** ch,
+	   unsigned int *n);
+int
+XRaiseWindow(
+	     Display *display,
+	     Window w);
+
+Window
+XRootWindow(
+	    Display *display,
+	    int scr);
+Window
+XRootWindowOfScreen(Screen *scr);
+
+BoolDef XTranslateCoordinates(
+		      Display *display,
+		      Window sw, Window dw,
+		      int sx, int sy, int *dx, int *dy,
+		      Window *ch);
+
+int
+XUnmapWindow(Display *display,
+	     Window w);
+int
+XCopyGC(
+	Display *display,
+	GC sgc,
+	unsigned long vmask,
+	GC dgc);
+int
+XSetClipMask(
+	     Display *display,
+	     GC gc,
+	     Pixmap cmask);
+
+int
+XSetClipRectangles(
+		   Display *display,
+		   GC gc,
+		   int clx, int cly,
+		   XRectangle *rs,
+		   int n, int order);
+int
+XSetFunction(
+	     Display *display,
+	     GC gc,
+	     int fn);
+int
+XSetLineAttributes(
+		   Display *display,
+		   GC gc,
+		   unsigned int lw,
+		   int ls, int cs, int js);
+int
+XSetPlaneMask(
+	      Display *display,
+	      GC gc,
+	      unsigned long pmask);
+int XSetTile(
+	     Display *display,
+	     GC gc,
+	     Pixmap tile);
+StatusDef
+XAllocColorCells(
+		 Display *display,
+		 Colormap cmap,
+		 BoolDef cont,
+		 unsigned long *pmasks,
+		 unsigned int np,
+		 unsigned long *pixels,
+		 unsigned int nc);
+StatusDef
+XAllocColorPlanes(
+		  Display *display,
+		  Colormap cmap,
+		  BoolDef cont,
+		  unsigned long *pixels,
+		  int nc,
+		  int nr,int ng,int nb,
+		  unsigned long *rmask,
+		  unsigned long *gmask,
+		  unsigned long *bmask);
+StatusDef
+XAllocNamedColor(Display *display,
+		 Colormap cmap, const char *cname,
+		 XColor *cell, XColor *rgb);
+Colormap
+XCreateColormap(
+		Display *display,
+		Window w,
+		Visual *visual,
+		int alloc);
+StatusDef
+XGetStandardColormap(
+		     Display *display,
+		     Window w,
+		     XStandardColormap *cmapinf,
+		     Atom prop);
+StatusDef
+XAllocColor(
+	    Display *display,
+	    Colormap cmap,
+	    XColor *xc);
+int
+XQueryColor(
+	    Display *display,
+	    Colormap cmap,
+	    XColor *cell);
+int
+XQueryColors(
+	     Display *display,
+	     Colormap cmap,
+	     XColor *cells,
+	     int nc);
+int
+XStoreColor(
+	    Display *display,
+	    Colormap cmap,
+	    XColor *cell);
+int
+XStoreColors(
+	     Display *display,
+	     Colormap cmap,
+	     XColor *cells,
+	     int nc);
+char **
+XGetFontPath(
+	     Display *display,
+	     int *nps);
+BoolDef XGetFontProperty(
+		 XFontStruct *fstruct,
+		 Atom atom,
+		 unsigned long *val);
+
+XFontStruct *
+XLoadQueryFont(Display *display, const char *name);
+
+XFontStruct *
+XQueryFont(
+	   Display *display,
+	   XID     font_id);
+
+KeySym
+XKeycodeToKeysym(
+		 Display *display,
+		 unsigned int keycode,
+		 int     index);
+
+KeyCode
+XKeysymToKeycode(
+		 Display *display,
+		 KeySym keysym);
+
+KeySym
+XStringToKeysym(const char *str);
+
+XModifierKeymap *
+XGetModifierMapping(Display *display);
+
+int
+XFreeModifiermap(XModifierKeymap *modmap);
+
+int
+XSetFont(
+	 Display *display,
+	 GC gc,
+	 Font font);
+int
+XSetFontPath(
+	     Display *display,
+	     char **dirs,
+	     int nd);
+int
+XTextExtents(
+	     XFontStruct *fstruct,
+	     const char *str,
+	     int nc,
+	     int *dir,int *ascent,int *descent,
+	     XCharStruct *overall);
+int
+XTextExtents16(
+	       XFontStruct *fstruct,
+	       const XChar2b *str,
+	       int nc,
+	       int *dir, int *ascent, int *descent,
+	       XCharStruct *overall);
+
+int
+XTextWidth(
+	   XFontStruct *fstruct,
+	   const char *str,
+	   int co);
+int
+XTextWidth16(
+	     XFontStruct *fstruct,
+	     const XChar2b *str,
+	     int co);
+int
+XGetErrorDatabaseText(
+		      Display *display,
+		      const char *name, const char *msg,
+		      const char *defstr,
+		      char *buf,
+		      int len);
+
+int
+XGetErrorText(
+	      Display *display,
+	      int code,
+	      char *buf,
+	      int len);
+
+XErrorHandler
+XSetErrorHandler(XErrorHandler handler);
+
+int
+XDefaultScreen(Display *display);
+
+Visual *
+XDefaultVisual(
+	       Display *display,
+	       int screen);
+
+int
+XDefaultDepth(
+	      Display *display,
+	      int screen);
+
+Colormap
+XDefaultColormap(
+		 Display *display,
+		 int screen);
+Screen *
+XScreenOfDisplay(
+		 Display *display,
+		 int scr);
+Cursor
+XCreateFontCursor(
+		  Display *display,
+		  unsigned int shape);
+int
+XRecolorCursor(
+	       Display *display,
+	       Cursor cursor,
+	       XColor *fg,XColor *bg);
+
+int
+XWarpPointer(
+	     Display *display,
+	     Window sw,Window dw,
+	     int sx,int sy,
+	     unsigned int swidth,unsigned int sheight,
+	     int dx, int dy);
+int
+XBell(
+      Display *display,
+      int pc);
+
+int
+XGetInputFocus(
+	       Display *display,
+	       Window *focus,
+	       int *revto);
+int
+XSetInputFocus(
+	       Display *display,
+	       Window focus,
+	       int revto,
+	       Time time);
+int
+XLookupString(
+	      XKeyEvent *event,
+	      char *buf,
+	      int nbytes,
+	      KeySym *keysym,
+	      XComposeStatus *status);
+
+int
+XRefreshKeyboardMapping(XMappingEvent *event);
+
+int
+XSetClassHint(
+	      Display *display,
+	      Window w,
+	      XClassHint *chints);
+int
+XSetNormalHints(
+		Display *display,
+		Window w,
+		XSizeHints *hints);
+
+int
+XSetWMHints(
+	    Display *display,
+	    Window w,
+	    XWMHints *wmhints);
+StatusDef
+XSetWMProtocols(
+		Display *display,
+		Window w,
+		Atom *prots,
+		int co);
+int
+XStoreName(Display *display,
+	   Window w,
+	   const char *wname);
+StatusDef
+XFetchName(
+    Display *display,
+    Window w,
+    char **window_name_return);
+
+int
+XDoesBackingStore(Screen *scr);
+
+XExtCodes *
+XInitExtension(Display *display,
+	       const char *name);
+int
+XFree(void *data);
+
+char *
+XServerVendor(Display *display);
+
+int
+XSetIconName(Display *display,
+	     Window w,
+	     const char *iname);
+int
+XGetIconName(
+	     Display *display,
+	     Window w,
+	     char **iname);
+int
+XSetSelectionOwner(
+		   Display* display,
+		   Atom sel,
+		   Window owner,
+		   Time time);
+Window
+XGetSelectionOwner(
+		   Display* display,
+		   Atom selection);
+
+int
+XConvertSelection(
+		  Display *display,
+		  Atom sel, Atom target, Atom prop,
+		  Window req,
+		  Time time);
+BoolDef XCheckTypedEvent(
+		 Display *display,
+		 int ev,
+		 XEvent *rep);
+BoolDef XCheckWindowEvent(
+		  Display *display,
+		  Window w,
+		  long emask,
+		  XEvent *ev);
+int
+XPending(Display *display);
+
+int
+XPutBackEvent(Display *display,
+	      XEvent *event);
+
+StatusDef
+XSendEvent(
+	   Display *display,
+	   Window w,
+	   BoolDef prop,
+	   long emask,
+	   XEvent *event);
+
+BoolDef XCheckTypedWindowEvent(
+	Display* display,
+	Window w,
+	int event_type,
+	XEvent* event_return);
+int
+XWindowEvent(
+	     Display *display,
+	     Window w,
+	     long emask,
+	     XEvent *rep);
+
+int
+XNextEvent(
+	   Display *display,
+	   XEvent  *event);
+
+Atom
+XInternAtom(
+	    Display *display,
+	    const char *property_name,
+	    BoolDef only_if_exists);
+char *
+XGetAtomName(
+	     Display *display,
+	     Atom atom);
+
+int
+XChangeProperty(
+	Display *display,
+	Window window,
+	Atom property,
+	Atom type,
+	int format,
+	int mode,
+	const unsigned char *data,
+	int nelements);
+
+int
+XGetWindowProperty(
+		   Display *display,
+		   Window window,
+		   Atom property,
+		   long long_offset,
+		   long long_length,
+		   BoolDef delete,
+		   Atom req_type,
+		   Atom *actual_type_return,
+		   int *actual_format_return,
+		   unsigned long *nitems_return,
+		   unsigned long *bytes_after_return,
+		   unsigned char **prop_return);
+
+char **
+XListExtensions(
+		Display *display,
+		int *ret_num);
+
+int XFreeExtensionList(char **list);
+
+int
+XChangeGC(
+	Display* display,
+	GC gc,
+	unsigned long mask,
+	XGCValues* gc_values);
+
+int
+XConnectionNumber(Display* display);
+
+int
+XFreeFont(Display* display,XFontStruct* font_struct);
+
+char *
+XSetLocaleModifiers(const char* modifier_list);
+
+XIM
+XOpenIM(
+	Display* dpy,
+	struct _XrmHashBucketRec* rdb,
+	char* res_name,
+	char* res_class);
+
+char *
+XGetIMValues(XIM im , ...);
+
+XIC XCreateIC(XIM im , ...);
+
+StatusDef
+XCloseIM(XIM im);
+
+BoolDef XFilterEvent(XEvent* event,Window window);
+
+char *
+XrmQuarkToString(void *quark);
+
+int
+XmbLookupString(
+	XIC ic,
+	XKeyPressedEvent* event,
+	char* buffer_return,
+	int bytes_buffer,
+	KeySym* keysym_return,
+	StatusDef* status_return);
+int
+XmbTextPropertyToTextList(
+	Display *display,
+	XTextProperty *text_prop,
+	char ***list_return,
+	int *count_return);
+
+int XmbTextListToTextProperty(
+	 Display *display,
+	 char **list,
+	 int count,
+	 XICCEncodingStyle style,
+	 XTextProperty *text_prop_return);
+
+void
+XSetICFocus(XIC ic);
+
+void
+XUnsetICFocus(XIC ic);
+
+BoolDef XQueryPointer(
+	Display* display,
+	Window w,
+	Window* root_return,
+	Window* child_return,
+	int* root_x_return,
+	int* root_y_return,
+	int* win_x_return,
+	int* win_y_return,
+	unsigned int* mask_return);
+
+int XParseGeometry(
+	const char* string,
+	int* x,
+	int* y,
+	unsigned int* width,
+	unsigned int* height);
+
+int XResizeWindow(
+	Display* display,
+	Window w,
+	unsigned int width,
+	unsigned int height);
+
+void XSetWMNormalHints(Display* display,Window w,XSizeHints* hints);
+
+void XSetWMProperties(
+	Display* display,
+	Window w,
+	XTextProperty* window_name,
+	XTextProperty* icon_name,
+	char** argv,
+	int argc,
+	XSizeHints* normal_hints,
+	XWMHints* wm_hints,
+	XClassHint* class_hints);
+
+int XDefineCursor(Display* display,Window w,Cursor cursor);
+
+int XMoveResizeWindow(
+	Display* display,
+	Window w,
+	int x,
+	int y,
+	unsigned int width,
+	unsigned int height);
+
+int XMoveWindow(
+	Display* display,
+	Window w,
+	int x,
+	int y);
+
+StatusDef
+XParseColor(
+    Display *display,
+    Colormap map,
+    const char* spec,
+    XColor *colorPtr);
+
+int
+XFreeColors(Display *display,
+	    Colormap cmap,
+	    unsigned long pixels[],
+	    int npixels,
+	    unsigned long planes);
+int
+XGrabServer(Display *display);
+
+int
+XUngrabServer(Display *display);
+
+
+#endif
diff -urN rxvt-2.7.2-orig/W11/X11/keysymdef.h rxvt-2.7.2/W11/X11/keysymdef.h
--- rxvt-2.7.2-orig/W11/X11/keysymdef.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/X11/keysymdef.h	Sat Apr 14 16:49:08 2001
@@ -0,0 +1,97 @@
+
+#define XK_Meta_L		0xFFE7	/* Left meta */
+#define XK_Meta_R		0xFFE8	/* Right meta */
+#define XK_Alt_R		0xFFEA	/* Right alt */
+#define XK_Super_L		0xFFEB	/* Left super */
+#define XK_Super_R		0xFFEC	/* Right super */
+#define XK_Hyper_L		0xFFED	/* Left hyper */
+#define XK_Hyper_R		0xFFEE	/* Right hyper */
+
+#define XK_KP_Space		0xFF80	/* space */
+#define XK_KP_Tab		0xFF89
+#define XK_KP_Enter		0xFF8D	/* enter */
+#define XK_KP_F1		0xFF91	/* PF1, KP_A, ... */
+#define XK_KP_F2		0xFF92
+#define XK_KP_F3		0xFF93
+#define XK_KP_F4		0xFF94
+#define XK_KP_Home		0xFF95
+#define XK_KP_Left		0xFF96
+#define XK_KP_Up		0xFF97
+#define XK_KP_Right		0xFF98
+#define XK_KP_Down		0xFF99
+#define XK_KP_Prior		0xFF9A
+#define XK_KP_Page_Up		0xFF9A
+#define XK_KP_Next		0xFF9B
+#define XK_KP_Page_Down		0xFF9B
+#define XK_KP_End		0xFF9C
+#define XK_KP_Begin		0xFF9D
+#define XK_KP_Insert		0xFF9E
+#define XK_KP_Delete		0xFF9F
+#define XK_KP_Equal		0xFFBD	/* equals */
+#define XK_KP_Multiply		0xFFAA
+#define XK_KP_Add		0xFFAB
+#define XK_KP_Separator		0xFFAC	/* separator, often comma */
+#define XK_KP_Subtract		0xFFAD
+#define XK_KP_Decimal		0xFFAE
+#define XK_KP_Divide		0xFFAF
+#define XK_minus               0x02d
+
+#define XK_KP_0			0xFFB0
+#define XK_KP_1			0xFFB1
+#define XK_KP_2			0xFFB2
+#define XK_KP_3			0xFFB3
+#define XK_KP_4			0xFFB4
+#define XK_KP_5			0xFFB5
+#define XK_KP_6			0xFFB6
+#define XK_KP_7			0xFFB7
+#define XK_KP_8			0xFFB8
+#define XK_KP_9			0xFFB9
+
+#define XK_L1			0xFFC8
+#define XK_L2			0xFFC9
+#define XK_F13			0xFFCA
+#define XK_L3			0xFFCA
+#define XK_F14			0xFFCB
+#define XK_L4			0xFFCB
+#define XK_F15			0xFFCC
+#define XK_L5			0xFFCC
+#define XK_F16			0xFFCD
+#define XK_L6			0xFFCD
+#define XK_F17			0xFFCE
+#define XK_L7			0xFFCE
+#define XK_F18			0xFFCF
+#define XK_L8			0xFFCF
+#define XK_F19			0xFFD0
+#define XK_L9			0xFFD0
+#define XK_F20			0xFFD1
+#define XK_L10			0xFFD1
+#define XK_F21			0xFFD2
+#define XK_R1			0xFFD2
+#define XK_F22			0xFFD3
+#define XK_R2			0xFFD3
+#define XK_F23			0xFFD4
+#define XK_R3			0xFFD4
+#define XK_F24			0xFFD5
+#define XK_R4			0xFFD5
+#define XK_F25			0xFFD6
+#define XK_R5			0xFFD6
+#define XK_F26			0xFFD7
+#define XK_R6			0xFFD7
+#define XK_F27			0xFFD8
+#define XK_R7			0xFFD8
+#define XK_F28			0xFFD9
+#define XK_R8			0xFFD9
+#define XK_F29			0xFFDA
+#define XK_R9			0xFFDA
+#define XK_F30			0xFFDB
+#define XK_R10			0xFFDB
+#define XK_F31			0xFFDC
+#define XK_R11			0xFFDC
+#define XK_F32			0xFFDD
+#define XK_R12			0xFFDD
+#define XK_F33			0xFFDE
+#define XK_R13			0xFFDE
+#define XK_F34			0xFFDF
+#define XK_R14			0xFFDF
+#define XK_F35			0xFFE0
+#define XK_R15			0xFFE0
diff -urN rxvt-2.7.2-orig/W11/X11/xpm.h rxvt-2.7.2/W11/X11/xpm.h
--- rxvt-2.7.2-orig/W11/X11/xpm.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/X11/xpm.h	Sat Apr 14 16:49:08 2001
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* xpm.h:                                                                      *
+*                                                                             *
+*  XPM library                                                                *
+*  Include file                                                               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+/*
+ * The code related to AMIGA has been added by
+ * Lorens Younes (d93-hyo@nada.kth.se) 4/96
+ */
+
+#ifndef XPM_h
+#define XPM_h
+
+/*
+ * first some identification numbers:
+ * the version and revision numbers are determined with the following rule:
+ * SO Major number = LIB minor version number.
+ * SO Minor number = LIB sub-minor version number.
+ * e.g: Xpm version 3.2f
+ *      we forget the 3 which is the format number, 2 gives 2, and f gives 6.
+ *      thus we have XpmVersion = 2 and XpmRevision = 6
+ *      which gives  SOXPMLIBREV = 2.6
+ *
+ * Then the XpmIncludeVersion number is built from these numbers.
+ */
+#define XpmFormat 3
+#define XpmVersion 4
+#define XpmRevision 11
+#define XpmIncludeVersion ((XpmFormat * 100 + XpmVersion) * 100 + XpmRevision)
+
+#ifndef XPM_NUMBERS
+
+#ifdef FOR_MSW
+# define SYSV			/* uses memcpy string.h etc. */
+# include <malloc.h>
+# include "simx.h"		/* defines some X stuff using MSW types */
+#define NEED_STRCASECMP		/* at least for MSVC++ */
+#else /* FOR_MSW */
+# ifdef AMIGA
+#  include "amigax.h"
+# else /* not AMIGA */
+#  include <X11/Xlib.h>
+#  include <X11/Xutil.h>
+# endif /* not AMIGA */
+#endif /* FOR_MSW */
+
+/* let's define Pixel if it is not done yet */
+#if ! defined(_XtIntrinsic_h) && ! defined(PIXEL_ALREADY_TYPEDEFED)
+typedef unsigned long Pixel;	/* Index into colormap */
+# define PIXEL_ALREADY_TYPEDEFED
+#endif
+
+/* make sure we know whether function prototypes are needed or not */
+#ifndef NeedFunctionPrototypes
+# if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus)
+#  define NeedFunctionPrototypes 1
+# else
+#  define NeedFunctionPrototypes 0
+# endif
+#endif
+
+
+/* Return ErrorStatus codes:
+ * null     if full success
+ * positive if partial success
+ * negative if failure
+ */
+
+#define XpmColorError    1
+#define XpmSuccess       0
+#define XpmOpenFailed   -1
+#define XpmFileInvalid  -2
+#define XpmNoMemory     -3
+#define XpmColorFailed  -4
+
+typedef struct {
+    char *name;			/* Symbolic color name */
+    char *value;		/* Color value */
+    Pixel pixel;		/* Color pixel */
+}      XpmColorSymbol;
+
+typedef struct {
+    char *name;			/* name of the extension */
+    unsigned int nlines;	/* number of lines in this extension */
+    char **lines;		/* pointer to the extension array of strings */
+}      XpmExtension;
+
+typedef struct {
+    char *string;		/* characters string */
+    char *symbolic;		/* symbolic name */
+    char *m_color;		/* monochrom default */
+    char *g4_color;		/* 4 level grayscale default */
+    char *g_color;		/* other level grayscale default */
+    char *c_color;		/* color default */
+}      XpmColor;
+
+typedef struct {
+    unsigned int width;		/* image width */
+    unsigned int height;	/* image height */
+    unsigned int cpp;		/* number of characters per pixel */
+    unsigned int ncolors;	/* number of colors */
+    XpmColor *colorTable;	/* list of related colors */
+    unsigned int *data;		/* image data */
+}      XpmImage;
+
+typedef struct {
+    unsigned long valuemask;	/* Specifies which attributes are defined */
+    char *hints_cmt;		/* Comment of the hints section */
+    char *colors_cmt;		/* Comment of the colors section */
+    char *pixels_cmt;		/* Comment of the pixels section */
+    unsigned int x_hotspot;	/* Returns the x hotspot's coordinate */
+    unsigned int y_hotspot;	/* Returns the y hotspot's coordinate */
+    unsigned int nextensions;	/* number of extensions */
+    XpmExtension *extensions;	/* pointer to array of extensions */
+}      XpmInfo;
+
+typedef int (*XpmAllocColorFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    char*			/* colorname */,
+    XColor*			/* xcolor */,
+    void*			/* closure */
+#endif
+);
+
+typedef int (*XpmFreeColorsFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    Pixel*			/* pixels */,
+    int				/* npixels */,
+    void*			/* closure */
+#endif
+);
+
+typedef struct {
+    unsigned long valuemask;		/* Specifies which attributes are
+					   defined */
+
+    Visual *visual;			/* Specifies the visual to use */
+    Colormap colormap;			/* Specifies the colormap to use */
+    unsigned int depth;			/* Specifies the depth */
+    unsigned int width;			/* Returns the width of the created
+					   pixmap */
+    unsigned int height;		/* Returns the height of the created
+					   pixmap */
+    unsigned int x_hotspot;		/* Returns the x hotspot's
+					   coordinate */
+    unsigned int y_hotspot;		/* Returns the y hotspot's
+					   coordinate */
+    unsigned int cpp;			/* Specifies the number of char per
+					   pixel */
+    Pixel *pixels;			/* List of used color pixels */
+    unsigned int npixels;		/* Number of used pixels */
+    XpmColorSymbol *colorsymbols;	/* List of color symbols to override */
+    unsigned int numsymbols;		/* Number of symbols */
+    char *rgb_fname;			/* RGB text file name */
+    unsigned int nextensions;		/* Number of extensions */
+    XpmExtension *extensions;		/* List of extensions */
+
+    unsigned int ncolors;               /* Number of colors */
+    XpmColor *colorTable;               /* List of colors */
+/* 3.2 backward compatibility code */
+    char *hints_cmt;                    /* Comment of the hints section */
+    char *colors_cmt;                   /* Comment of the colors section */
+    char *pixels_cmt;                   /* Comment of the pixels section */
+/* end 3.2 bc */
+    unsigned int mask_pixel;            /* Color table index of transparent
+                                           color */
+
+    /* Color Allocation Directives */
+    Bool exactColors;			/* Only use exact colors for visual */
+    unsigned int closeness;		/* Allowable RGB deviation */
+    unsigned int red_closeness;		/* Allowable red deviation */
+    unsigned int green_closeness;	/* Allowable green deviation */
+    unsigned int blue_closeness;	/* Allowable blue deviation */
+    int color_key;			/* Use colors from this color set */
+
+    Pixel *alloc_pixels;		/* Returns the list of alloc'ed color
+					   pixels */
+    int nalloc_pixels;			/* Returns the number of alloc'ed
+					   color pixels */
+
+    Bool alloc_close_colors;    	/* Specify whether close colors should
+					   be allocated using XAllocColor
+					   or not */
+    int bitmap_format;			/* Specify the format of 1bit depth
+					   images: ZPixmap or XYBitmap */
+
+    /* Color functions */
+    XpmAllocColorFunc alloc_color;	/* Application color allocator */
+    XpmFreeColorsFunc free_colors;	/* Application color de-allocator */
+    void *color_closure;		/* Application private data to pass to
+					   alloc_color and free_colors */
+
+}      XpmAttributes;
+
+/* XpmAttributes value masks bits */
+#define XpmVisual	   (1L<<0)
+#define XpmColormap	   (1L<<1)
+#define XpmDepth	   (1L<<2)
+#define XpmSize		   (1L<<3)	/* width & height */
+#define XpmHotspot	   (1L<<4)	/* x_hotspot & y_hotspot */
+#define XpmCharsPerPixel   (1L<<5)
+#define XpmColorSymbols	   (1L<<6)
+#define XpmRgbFilename	   (1L<<7)
+/* 3.2 backward compatibility code */
+#define XpmInfos	   (1L<<8)
+#define XpmReturnInfos	   XpmInfos
+/* end 3.2 bc */
+#define XpmReturnPixels	   (1L<<9)
+#define XpmExtensions      (1L<<10)
+#define XpmReturnExtensions XpmExtensions
+
+#define XpmExactColors     (1L<<11)
+#define XpmCloseness	   (1L<<12)
+#define XpmRGBCloseness	   (1L<<13)
+#define XpmColorKey	   (1L<<14)
+
+#define XpmColorTable      (1L<<15)
+#define XpmReturnColorTable XpmColorTable
+
+#define XpmReturnAllocPixels (1L<<16)
+#define XpmAllocCloseColors (1L<<17)
+#define XpmBitmapFormat    (1L<<18)
+
+#define XpmAllocColor      (1L<<19)
+#define XpmFreeColors      (1L<<20)
+#define XpmColorClosure    (1L<<21)
+
+
+/* XpmInfo value masks bits */
+#define XpmComments        XpmInfos
+#define XpmReturnComments  XpmComments
+
+/* XpmAttributes mask_pixel value when there is no mask */
+#ifndef FOR_MSW
+#define XpmUndefPixel 0x80000000
+#else
+/* int is only 16 bit for MSW */
+#define XpmUndefPixel 0x8000
+#endif
+
+/*
+ * color keys for visual type, they must fit along with the number key of
+ * each related element in xpmColorKeys[] defined in XpmI.h
+ */
+#define XPM_MONO	2
+#define XPM_GREY4	3
+#define XPM_GRAY4	3
+#define XPM_GREY 	4
+#define XPM_GRAY 	4
+#define XPM_COLOR	5
+
+
+/* macros for forward declarations of functions with prototypes */
+#if NeedFunctionPrototypes
+#define FUNC(f, t, p) extern t f p
+#define LFUNC(f, t, p) static t f p
+#else
+#define FUNC(f, t, p) extern t f()
+#define LFUNC(f, t, p) static t f()
+#endif
+
+
+/*
+ * functions declarations
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* FOR_MSW, all ..Pixmap.. are excluded, only the ..XImage.. are used */
+/* Same for Amiga! */
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromData, int, (Display *display,
+					Drawable d,
+					char **data,
+					Pixmap *pixmap_return,
+					Pixmap *shapemask_return,
+					XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromPixmap, int, (Display *display,
+					char ***data_return,
+					Pixmap pixmap,
+					Pixmap shapemask,
+					XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToPixmap, int, (Display *display,
+				    Drawable d,
+				    char *filename,
+				    Pixmap *pixmap_return,
+				    Pixmap *shapemask_return,
+				    XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromPixmap, int, (Display *display,
+				       char *filename,
+				       Pixmap pixmap,
+				       Pixmap shapemask,
+				       XpmAttributes *attributes));
+#endif
+
+    FUNC(XpmCreateImageFromData, int, (Display *display,
+				       char **data,
+				       XImage **image_return,
+				       XImage **shapemask_return,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromImage, int, (Display *display,
+				       char ***data_return,
+				       XImage *image,
+				       XImage *shapeimage,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToImage, int, (Display *display,
+				   char *filename,
+				   XImage **image_return,
+				   XImage **shapeimage_return,
+				   XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromImage, int, (Display *display,
+				      char *filename,
+				      XImage *image,
+				      XImage *shapeimage,
+				      XpmAttributes *attributes));
+
+    FUNC(XpmCreateImageFromBuffer, int, (Display *display,
+					 char *buffer,
+					 XImage **image_return,
+					 XImage **shapemask_return,
+					 XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromBuffer, int, (Display *display,
+					  Drawable d,
+					  char *buffer,
+					  Pixmap *pixmap_return,
+					  Pixmap *shapemask_return,
+					  XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromImage, int, (Display *display,
+					 char **buffer_return,
+					 XImage *image,
+					 XImage *shapeimage,
+					 XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromPixmap, int, (Display *display,
+					  char **buffer_return,
+					  Pixmap pixmap,
+					  Pixmap shapemask,
+					  XpmAttributes *attributes));
+#endif
+    FUNC(XpmReadFileToBuffer, int, (char *filename, char **buffer_return));
+    FUNC(XpmWriteFileFromBuffer, int, (char *filename, char *buffer));
+
+    FUNC(XpmReadFileToData, int, (char *filename, char ***data_return));
+    FUNC(XpmWriteFileFromData, int, (char *filename, char **data));
+
+    FUNC(XpmAttributesSize, int, ());
+    FUNC(XpmFreeAttributes, void, (XpmAttributes *attributes));
+    FUNC(XpmFreeExtensions, void, (XpmExtension *extensions,
+				   int nextensions));
+
+    FUNC(XpmFreeXpmImage, void, (XpmImage *image));
+    FUNC(XpmFreeXpmInfo, void, (XpmInfo *info));
+    FUNC(XpmGetErrorString, char *, (int errcode));
+    FUNC(XpmLibraryVersion, int, ());
+
+    /* XpmImage functions */
+    FUNC(XpmReadFileToXpmImage, int, (char *filename,
+				      XpmImage *image,
+				      XpmInfo *info));
+
+    FUNC(XpmWriteFileFromXpmImage, int, (char *filename,
+					 XpmImage *image,
+					 XpmInfo *info));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromXpmImage, int, (Display *display,
+					    Drawable d,
+					    XpmImage *image,
+					    Pixmap *pixmap_return,
+					    Pixmap *shapemask_return,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateImageFromXpmImage, int, (Display *display,
+					   XpmImage *image,
+					   XImage **image_return,
+					   XImage **shapeimage_return,
+					   XpmAttributes *attributes));
+
+    FUNC(XpmCreateXpmImageFromImage, int, (Display *display,
+					   XImage *image,
+					   XImage *shapeimage,
+					   XpmImage *xpmimage,
+					   XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreateXpmImageFromPixmap, int, (Display *display,
+					    Pixmap pixmap,
+					    Pixmap shapemask,
+					    XpmImage *xpmimage,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateDataFromXpmImage, int, (char ***data_return,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromData, int, (char **data,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromBuffer, int, (char *buffer,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmCreateBufferFromXpmImage, int, (char **buffer_return,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmGetParseError, int, (char *filename,
+				 int *linenum_return,
+				 int *charnum_return));
+
+    FUNC(XpmFree, void, (void *ptr));
+
+#ifdef __cplusplus
+} /* for C++ V2.0 */
+#endif
+
+
+/* backward compatibility */
+
+/* for version 3.0c */
+#define XpmPixmapColorError  XpmColorError
+#define XpmPixmapSuccess     XpmSuccess
+#define XpmPixmapOpenFailed  XpmOpenFailed
+#define XpmPixmapFileInvalid XpmFileInvalid
+#define XpmPixmapNoMemory    XpmNoMemory
+#define XpmPixmapColorFailed XpmColorFailed
+
+#define XpmReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XpmWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+
+/* for version 3.0b */
+#define PixmapColorError  XpmColorError
+#define PixmapSuccess     XpmSuccess
+#define PixmapOpenFailed  XpmOpenFailed
+#define PixmapFileInvalid XpmFileInvalid
+#define PixmapNoMemory    XpmNoMemory
+#define PixmapColorFailed XpmColorFailed
+
+#define ColorSymbol XpmColorSymbol
+
+#define XReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+#define XCreatePixmapFromData(dpy, d, data, pix, mask, att) \
+    XpmCreatePixmapFromData(dpy, d, data, pix, mask, att)
+#define XCreateDataFromPixmap(dpy, data, pix, mask, att) \
+    XpmCreateDataFromPixmap(dpy, data, pix, mask, att)
+
+#endif /* XPM_NUMBERS */
+#endif
diff -urN rxvt-2.7.2-orig/W11/w32/Makefile rxvt-2.7.2/W11/w32/Makefile
--- rxvt-2.7.2-orig/W11/w32/Makefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/w32/Makefile	Sat Apr 14 17:00:34 2001
@@ -0,0 +1,24 @@
+
+first_rule: all
+
+all allbin: ../lib/libW11.dll
+
+alldoc tags:
+
+../lib/libW11.dll: xlib.o ntutil.o event.o
+	dllwrap --export-all-symbols -o ../lib/libW11.dll xlib.o ntutil.o event.o -mwindows
+
+xlib.o: xlib.c ntdef.h
+	gcc -c xlib.c -O -I.. -mwin32
+
+ntutil.o: ntutil.c ntdef.h
+	gcc -c ntutil.c -O -I.. -mwin32
+
+event.o: event.c ntdef.h
+	gcc -c event.c -O -I.. -mwin32
+
+debug:
+	gcc -c xlib.c -g -I.. -mwin32
+
+clean:
+	rm ../lib/libW11.dll xlib.o ntutil.o event.o
diff -urN rxvt-2.7.2-orig/W11/w32/event.c rxvt-2.7.2/W11/w32/event.c
--- rxvt-2.7.2-orig/W11/w32/event.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/w32/event.c	Mon May 14 18:59:02 2001
@@ -0,0 +1,878 @@
+
+#include <X11/Xlib.h>
+#include "ntdef.h"
+
+/* a crude method to avoid losing the selection when
+   calling EmptyClipboard, which is necessary to do
+   every time the selection content changes, otherwise
+   windows apps use a cached copy of the selection */
+static volatile int destroyClipboardCatcher = 0;
+static NT_window *NT_CWIN = NULL;
+
+
+static unsigned int NT_get_state();
+
+typedef struct WinEvent_
+{
+	NT_window *window;
+	UINT message;
+	UINT wParam;
+	LONG lParam;
+} WinEvent;
+
+typedef struct WinEventQ_
+{
+	int num;
+	int avail;
+	int next;
+	int count;
+	WinEvent list[100];
+} WinEventQ;
+
+static WinEventQ *wineventq;
+
+void
+catchNextDestroyClipboard()
+{
+	destroyClipboardCatcher=1;
+}
+
+static void
+_initQ(WinEventQ **q)
+{
+	int i;
+	*q = (WinEventQ *)allocateMemory(sizeof(WinEventQ));
+	(*q)->num=99;
+	(*q)->avail=0;
+	(*q)->next=0;
+	(*q)->count=0;
+	for (i=0; i<100; i++) {
+		(*q)->list[i].message=0;
+		(*q)->list[i].window = NULL;
+	}
+}
+void
+initQ() { _initQ(&wineventq); }
+
+
+static void
+copyWinEvent(WinEvent *to, WinEvent *from)
+{
+	to->window = from->window;
+	to->message = from->message;
+	to->wParam = from->wParam;
+	to->lParam = from->lParam;
+}
+
+
+static int
+QEvent(WinEventQ *q, NT_window *window,UINT message,UINT wParam,LONG lParam)
+{
+	int i, j;
+	if (q->count>=q->num) {
+		for (i=0;i<q->num;i++) cjh_printf("%d, ",q->list[i].message);
+		cjh_printf("Queue count %d q->num %d\n", q->count, q->num);
+	}
+	if (q->count>1 && (message == WM_MOVE ||
+					   message == WM_PAINT)) {
+		/* only the most recent is interesting, so remove the previous
+		   event in the queue */
+		i = j = q->avail; i--; if (i<0) i=q->num;
+		while (i!=q->next && (q->list[i].message!=message || q->list[i].window!=window)) {
+			j=i; i--; if (i<0) i = q->num;
+		}
+		if (q->list[i].message==message && q->list[i].window==window) {
+			while(j!=q->avail) {
+				copyWinEvent(&q->list[i],&q->list[j]);
+				i=j; j++; if (j>q->num) j=0;
+			}
+			q->avail = i;
+			q->count --;
+		}
+	}
+	q->list[q->avail].window=window;
+	q->list[q->avail].message=message;
+	q->list[q->avail].wParam=wParam;
+	q->list[q->avail].lParam=lParam;
+	/* wake up app */
+	PostMessage(window->w,0x8053,wParam,lParam);
+	q->avail++; q->count++;
+	if (q->avail>q->num) q->avail=0;
+	return 1;
+}
+
+static int
+getQdEvent(WinEventQ *q, WinEvent *we)
+{
+	if (q->count<=0) {
+		cjh_printf("Queue is empty\n");
+		return 0;
+	}
+	we->window = q->list[q->next].window;
+	we->message = q->list[q->next].message;
+	we->wParam = q->list[q->next].wParam;
+	we->lParam = q->list[q->next].lParam;
+	q->next++; q->count--;
+	if (q->next>q->num) q->next=0;	
+	return 1;
+}
+/*****************************************************************\
+
+	Function: MainWndProc
+	Inputs:   Window handle, message, message parameters.
+
+	Comments: This is called when messages are sent to the application
+		  but not to the application's message queue.  If an
+		  event can be processed, it is done here.  The equivalent
+		  XEvent is filled out in l_event, which is picked up
+		  in the X event routines.  Some events are not received
+		  from Windows, eg Enter/LeaveNotify, so these are made
+		  up as required.
+
+	Caution:  The application does not see HWND, but Window.
+
+\*****************************************************************/
+
+/* queued messages
+   WM_KEYDOWN
+   WM_KEYUP
+   WM_CHAR
+   WM_MOUSEMOVE
+   WM_BUTTONxx
+   WM_TIMER
+   WM_PAINT
+   WM_QUIT
+   */
+
+LONG NT_handleMsg(
+	HWND hWnd,		  /* window handle		     */
+	UINT message,		  /* type of message		     */
+	UINT wParam,		  /* additional information	     */
+	LONG lParam)		  /* additional information	     */
+{
+	RECT rect;
+	WINDOWPOS *posStruct;
+	unsigned long int st=0L;
+	NT_window *window;
+	long mask;
+	PAINTSTRUCT paintStruct;
+
+	if (message == WM_CLOSE) exit(0);
+	
+	window = NT_find_window_from_id(hWnd);
+	if (window == NULL) return  (DefWindowProc(hWnd, message, wParam, lParam));
+
+	mask = window->mask;
+	
+    switch (message) {
+			/* we'll handle these, later */
+		case WM_KILLFOCUS:
+		case WM_SETFOCUS:
+		case WM_QUIT:
+		case WM_CLOSE:
+		case WM_DESTROY:
+		case WM_SYSCHAR: /* alt-keys go here */
+		case WM_CHAR:
+		case WM_LBUTTONDBLCLK:
+		case WM_MBUTTONDBLCLK:
+		case WM_RBUTTONDBLCLK:
+		case USR_MapNotify:
+		case USR_EnterNotify:
+		case WM_MOVE:
+#if defined(WIN9X)
+		case WM_SIZING:
+#endif			
+		case WM_SIZE:			
+			QEvent(wineventq,window,message,wParam,lParam);
+			break;
+		case WM_DESTROYCLIPBOARD:
+			if (destroyClipboardCatcher)
+				destroyClipboardCatcher=0;
+			else
+				QEvent(wineventq,window,message,wParam,lParam);
+			break;
+		case WM_PAINT:
+			BeginPaint(hWnd,&paintStruct);
+			FillRect(paintStruct.hdc, &paintStruct.rcPaint,window->bg);
+			QEvent(wineventq,window,message,
+				   (((paintStruct.rcPaint.right-paintStruct.rcPaint.left)&0xffff) |
+					(((paintStruct.rcPaint.bottom-paintStruct.rcPaint.top)&0xffff)<<16)),
+				   (((paintStruct.rcPaint.left)&0xffff) | (((paintStruct.rcPaint.top)&0xffff)<<16)));
+
+			EndPaint(hWnd,&paintStruct);
+			break;
+			/* capture the mouse on button down to emulate x */
+		case WM_LBUTTONDOWN:
+		case WM_MBUTTONDOWN:
+		case WM_RBUTTONDOWN:
+			SetCapture(hWnd);
+			QEvent(wineventq,window,message,wParam,lParam);
+			break;
+		case WM_MBUTTONUP:
+		case WM_LBUTTONUP:
+		case WM_RBUTTONUP:
+			ReleaseCapture();
+			QEvent(wineventq,window,message,wParam,lParam);
+			break;
+		case WM_MOUSEMOVE:
+			if ((mask&PointerMotionMask) ||
+				((mask&Button1MotionMask)&& (wParam&MK_LBUTTON)) ||
+				((mask&Button2MotionMask)&& (wParam&MK_MBUTTON)) ||
+				((mask&Button3MotionMask)&& (wParam&MK_RBUTTON)) ||
+				((mask&ButtonMotionMask)&&((wParam&(MK_LBUTTON|MK_MBUTTON|MK_RBUTTON))))
+				)
+				QEvent(wineventq,window,message,wParam,lParam);
+			else
+				return (DefWindowProc(hWnd, message, wParam, lParam));
+			break;
+		case WM_MOUSEWHEEL:
+			/* this event only seems to go to the top most window.
+			   see if child windows accept it. */
+			window = NT_find_child(window,ButtonPressMask|Button2MotionMask|Button3MotionMask,
+								   ButtonPressMask|Button3MotionMask );
+			if (window && ((window->mask)&ButtonPressMask)) 
+				QEvent(wineventq,window,message,wParam,lParam);
+			else
+				return (DefWindowProc(hWnd, message, wParam, lParam));
+			break;
+		case WM_ERASEBKGND:
+			/* don't erase the background */
+			return 1;
+			break;
+		case WM_KEYDOWN:
+			switch (wParam)
+			{
+				case VK_CANCEL:
+				case VK_CLEAR:
+				case VK_PAUSE:
+				case VK_PRIOR:
+				case VK_NEXT:
+				case VK_END:
+				case VK_HOME:
+				case VK_LEFT:
+				case VK_UP:
+				case VK_RIGHT:
+				case VK_DOWN:
+				case VK_SELECT:
+				case VK_PRINT:
+				case VK_EXECUTE:
+				case VK_INSERT:
+				case VK_DELETE:
+				case VK_HELP:
+				case VK_NUMLOCK:
+				case VK_SCROLL:
+                case VK_F1:
+                case VK_F2:
+                case VK_F3:
+                case VK_F4:
+                case VK_F5:
+                case VK_F6:
+                case VK_F7:
+                case VK_F8:
+                case VK_F9:
+                case VK_F10:
+                case VK_F11:
+                case VK_F12:
+					QEvent(wineventq,window,message,wParam,lParam);
+					break;
+				default:
+					return  (DefWindowProc(hWnd, message, wParam, lParam));
+					break;
+					
+			}
+			break;
+		default:			  /* Passes it on if unproccessed    */
+			return (DefWindowProc(hWnd, message, wParam, lParam));
+    }
+    return 0L;
+}
+
+int
+WinEventToXEvent(
+	WinEvent *we,
+	XEvent *event)
+{
+	POINT pt;
+	RECT rect;
+	unsigned long int st=0L;
+	UINT key;
+	HWND hWnd;
+	UINT wParam;
+	LONG lParam;
+	NT_window *window;
+	
+	do {		
+		if (event==NULL) break;
+		if (we == NULL) break;
+
+		window = we->window;
+		wParam = we->wParam;
+		lParam = we->lParam;
+		
+		event->type=-1;
+		event->xbutton.subwindow = None;
+		hWnd = window->w;
+		
+		switch (we->message) {
+			case WM_SETFOCUS:
+				event->type=FocusIn;
+				event->xfocus.window=(Window)window;
+				break;
+			case WM_KILLFOCUS:
+				event->type=FocusOut;
+				event->xfocus.window=(Window)window;
+				break;	
+				/*	case WM_ERASEBKGND: */
+			case WM_PAINT:
+				event->type=Expose;
+				event->xexpose.x=LOWORD(lParam); /* right */
+				event->xexpose.y=HIWORD(lParam); /* top */
+				event->xexpose.width=LOWORD(wParam);
+				event->xexpose.height=HIWORD(wParam);
+				event->xexpose.count=0;
+				event->xexpose.window=(Window)window;
+				break;
+			case WM_LBUTTONDOWN:
+			case WM_LBUTTONDBLCLK:
+				event->type = ButtonPress;
+				event->xbutton.x = LOWORD (lParam);
+				event->xbutton.y = HIWORD (lParam);
+				if ( wParam & MK_SHIFT )
+					event->xbutton.button=Button2;
+				else
+					event->xbutton.button=Button1;
+				event->xbutton.window = (Window)window;
+				event->xbutton.time=GetTickCount();
+				break;
+			case WM_LBUTTONUP:
+				event->type=ButtonRelease;
+				event->xbutton.x=LOWORD(lParam);
+				event->xbutton.y=HIWORD (lParam);
+				if ( wParam & MK_SHIFT )
+					event->xbutton.button=Button2;
+				else
+					event->xbutton.button=Button1;
+				event->xbutton.window=(Window)window;
+				event->xbutton.time=GetTickCount();
+				break;
+			case WM_MBUTTONDOWN:
+			case WM_MBUTTONDBLCLK:
+				event->type=ButtonPress;
+				event->xbutton.x=LOWORD(lParam);
+				event->xbutton.y=HIWORD (lParam);
+				event->xbutton.button=Button2;
+				event->xbutton.window=(Window)window;
+				event->xbutton.time=GetTickCount();
+				break;
+			case WM_MBUTTONUP:
+				event->type=ButtonRelease;
+				event->xbutton.x=LOWORD(lParam);
+				event->xbutton.y=HIWORD (lParam);
+				event->xbutton.button=Button2;
+				event->xbutton.window=(Window)window;
+				event->xbutton.time=GetTickCount();
+				break;
+			case WM_RBUTTONDOWN:
+			case WM_RBUTTONDBLCLK:
+				event->type=ButtonPress;
+				event->xbutton.x=LOWORD(lParam);
+				event->xbutton.y=HIWORD (lParam);
+				event->xbutton.button=Button3;
+				event->xbutton.window=(Window)window;
+				event->xbutton.time=GetTickCount();
+				break;
+			case WM_RBUTTONUP:
+				event->type=ButtonRelease;
+				event->xbutton.x=LOWORD(lParam);
+				event->xbutton.y=HIWORD (lParam);
+				event->xbutton.button=Button3;
+				event->xbutton.window=(Window)window;
+				event->xbutton.time=GetTickCount();
+				break;
+			case WM_MOUSEMOVE:
+				if (hWnd!=(HWND)NT_CWIN)  /* Mouse in different window? */
+				{
+					if (NT_CWIN==NULL) /* No previous window */
+					{
+						event->type = EnterNotify;
+						event->xcrossing.x = LOWORD(lParam);
+						event->xcrossing.y = HIWORD(lParam);
+						event->xcrossing.window = (Window)window;
+					}
+					else
+					{
+						event->type=LeaveNotify;
+						event->xcrossing.x=LOWORD(lParam);
+						event->xcrossing.y=HIWORD(lParam);
+						event->xcrossing.window = (Window)NT_find_window_from_id(NT_CWIN);
+					}
+				}
+				else
+				{
+					event->type=MotionNotify;    /* Fill out mouse event */
+					event->xmotion.window=(Window)window;
+					event->xmotion.x=pt.x=LOWORD(lParam);
+					event->xmotion.y=pt.y=HIWORD(lParam);
+					ClientToScreen(hWnd,&pt);     /* Translate coordinates */
+					event->xmotion.x_root=pt.x;
+					event->xmotion.y_root=pt.y;
+					if (wParam&MK_CONTROL)
+						st|=ControlMask;
+					if (wParam&MK_SHIFT)
+						st|=ShiftMask;
+					if (wParam&MK_LBUTTON)
+						st|=Button1Mask;
+					if (wParam&MK_MBUTTON)
+						st|=Button2Mask;
+					if (wParam&MK_RBUTTON)
+						st|=Button3Mask;
+					event->xmotion.state=st;
+				}
+				NT_CWIN=(NT_window *)hWnd;
+				break;
+			case WM_MOUSEWHEEL:
+				event->type=ButtonRelease;
+				event->xbutton.x=LOWORD(lParam);
+				event->xbutton.y=HIWORD (lParam);
+				event->xbutton.button=HIWORD(wParam)>32768?Button5:Button4;
+				event->xbutton.window=(Window)window;
+				event->xbutton.time=GetTickCount();
+				if (wParam&MK_CONTROL)
+					st|=ControlMask;
+				if (wParam&MK_SHIFT)
+					st|=ShiftMask;
+				if (wParam&MK_LBUTTON)
+					st|=Button1Mask;
+				if (wParam&MK_MBUTTON)
+					st|=Button2Mask;
+				if (wParam&MK_RBUTTON)
+					st|=Button3Mask;
+				event->xbutton.state=st;
+			break;
+			case WM_SYSCHAR:
+			case WM_CHAR:
+				event->type=KeyPress;
+				event->xkey.state=NT_get_state();
+				event->xkey.x=event->xkey.y=0; /* Inside the window */
+				event->xkey.keycode=LOWORD(wParam);
+				if (LOWORD(wParam==32) && (GetKeyState(VK_CONTROL) & 0x8000))
+				{
+					event->xkey.keycode=0;
+				}
+				event->xkey.window=(Window)window;
+				break;
+			case WM_KEYDOWN:
+				event->type=KeyPress;
+				switch (wParam)
+				{
+					case VK_CANCEL:  key=XK_Cancel;      break;
+					case VK_CLEAR:   key=XK_Clear;       break;
+				/*  causes AltGr to create a keypress */
+				/*  case VK_MENU:    key=XK_Alt_L;       break;*/
+					case VK_PAUSE:   key=XK_Pause;       break;
+					case VK_PRIOR:   key=XK_Prior;       break;
+					case VK_NEXT:    key=XK_Next;        break;
+					case VK_END:     key=XK_End;         break;
+					case VK_HOME:    key=XK_Home;        break;
+					case VK_LEFT:    key=XK_Left;        break;
+					case VK_UP:      key=XK_Up;          break;
+					case VK_RIGHT:   key=XK_Right;       break;
+					case VK_DOWN:    key=XK_Down;        break;
+					case VK_SELECT:  key=XK_Select;      break;
+					case VK_PRINT:   key=XK_Print;       break;
+					case VK_EXECUTE: key=XK_Execute;     break;
+					case VK_INSERT:  key=XK_Insert;      break;
+					case VK_DELETE:  key=XK_Delete;      break;
+					case VK_HELP:    key=XK_Help;        break;
+					case VK_NUMLOCK: key=XK_Num_Lock;    break;
+					case VK_SCROLL:  key=XK_Scroll_Lock; break;
+                    case VK_F1:      key=XK_F1;          break;
+                    case VK_F2:      key=XK_F2;          break;
+                    case VK_F3:      key=XK_F3;          break;
+                    case VK_F4:      key=XK_F4;          break;
+                    case VK_F5:      key=XK_F5;          break;
+                    case VK_F6:      key=XK_F6;          break;
+                    case VK_F7:      key=XK_F7;          break;
+                    case VK_F8:      key=XK_F8;          break;
+                    case VK_F9:      key=XK_F9;          break;
+                    case VK_F10:     key=XK_F10;         break;
+                    case VK_F11:     key=XK_F11;         break;
+                    case VK_F12:     key=XK_F12;         break;
+					default:         key=0;              break;
+				}
+				if (key == 0) {
+					event->type = -1;
+				}
+				else
+				{
+					event->xkey.keycode=key;
+					event->xkey.window=(Window)window;
+					event->xkey.state=NT_get_state();
+					event->xkey.x=event->xkey.y=0; /* Inside the window */
+				}
+				break;
+			case WM_DESTROY:
+			case WM_QUIT:
+			case WM_CLOSE:
+				event->type = ClientMessage;
+				event->xclient.format = 32;
+				event->xclient.data.l[0] = XInternAtom(NULL,"WM_DELETE_WINDOW", FALSE);
+				break;
+			case USR_EnterNotify:
+				event->type = EnterNotify;
+				event->xcrossing.x = LOWORD(lParam);
+				event->xcrossing.y = HIWORD(lParam);
+				event->xcrossing.window = (Window)window;
+				break;
+			case WM_MOVE:
+				if (window->min==0)
+				{
+					window->x =  LOWORD(lParam);
+					window->y =  HIWORD(lParam);
+					event->type = ConfigureNotify;
+					event->xconfigure.window = (Window)window;
+					event->xconfigure.x = 0;  /* client area is always @ 0 */
+					event->xconfigure.y = 0;
+					event->xconfigure.width = window->wdth;
+					event->xconfigure.height = window->hght;
+					event->xconfigure.above = Above;
+				}
+				break;
+			case WM_SIZING:
+					event->type = ConfigureNotify;
+					window->wdth =	LOWORD(lParam);
+					if (window->wdth<window->minx)
+						window->wdth = window->minx;
+					window->hght =	HIWORD(lParam);
+					if (window->hght<window->minx)
+						window->hght = window->miny;
+					event->xconfigure.window = (Window)window;
+					event->xconfigure.x = 0;
+					event->xconfigure.y = 0;
+					event->xconfigure.width = window->wdth;
+					event->xconfigure.height = window->hght;
+					event->xconfigure.above = Above;
+					break;
+			case WM_SIZE:
+				switch(wParam)
+				{
+					case SIZE_MINIMIZED:
+						event->type=UnmapNotify;
+						window->min=1;
+						break;
+					default:
+						event->type = ConfigureNotify;
+						window->wdth =  LOWORD(lParam);
+						if (window->wdth<window->minx)
+							window->wdth = window->minx;
+						window->hght =  HIWORD(lParam);
+						if (window->hght<window->minx)
+							window->hght = window->miny;
+						event->xconfigure.window = (Window)window;
+						event->xconfigure.x = 0;
+						event->xconfigure.y = 0;
+						event->xconfigure.width = window->wdth;
+						event->xconfigure.height = window->hght;
+						event->xconfigure.above = Above;
+#if !defined(WIN9X)						
+						if (window->min) event->type=MapNotify;
+#endif						
+						window->min=0;
+						break;
+				}
+				break;
+			case WM_DESTROYCLIPBOARD:
+				event->type = SelectionClear;
+				event->xselectionclear.time = GetTickCount();
+				break;
+			case USR_MapNotify:
+				event->type=MapNotify;
+				break;
+			default:
+				break;
+		}
+	} while(0);
+    return (event==NULL?0: (event->type==-1?0:1));
+}
+/*****************************************************************\
+
+
+	Function: XCheckWindowEvent
+	Inputs:   display, window, event mask.
+	Returned: pointer to filled in event structure, status.
+
+	Comments: This is fudged at the moment to work with the toolkit.
+		  The event system needs rewriting to account properly for
+		  event masks.
+
+\*****************************************************************/
+
+BoolDef
+XCheckTypedEvent(display,ev,rep)
+Display *display;
+int ev;
+XEvent *rep;
+{
+	xtrace("XCheckTypedEvent\n");
+	return (False);
+}
+
+BoolDef
+XCheckWindowEvent(display,w,emask,ev)
+Display *display;
+Window w;
+long emask;
+XEvent *ev;
+{
+	NT_window *ntw=(NT_window *)w;
+	MSG msg;
+	BoolDef status = 0;
+
+	xtrace("XCheckWindowEvent\n");
+	if (emask&0)
+		if (PeekMessage(&msg,ntw->w,USR_MapNotify,
+						USR_MapNotify,PM_REMOVE)||
+		    PeekMessage(&msg,ntw->w,WM_PAINT,WM_PAINT,PM_REMOVE))
+		{
+			cjh_printf("removed message\n");
+			ev->type=ConfigureNotify;
+			status = 1;
+		}
+	return(status);
+}
+
+/*
+  XPending checks for x events pending.
+  We don't know if we have x events until we process
+  the win events.
+  */
+int
+XPending (display)
+Display *display;
+{
+	MSG msg;
+	/*	xtrace("XPending\n"); */
+	while(wineventq->count<=0 && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
+	{
+		TranslateMessage(&msg);
+		DispatchMessage(&msg);
+	}
+	return wineventq->count;
+}
+
+int
+XPutBackEvent(display,event)
+Display *display;
+XEvent *event;
+{
+	xtrace("XPutBackEvent\n");
+	return 0;
+}
+
+
+StatusDef
+XSendEvent(display,w,prop,emask,event)
+Display *display;
+Window w;
+BoolDef prop;
+long emask;
+XEvent *event;
+{
+	xtrace("XSendEvent\n");
+	return 0;
+}
+
+/* I'm tempted to flush the windows queue
+**   before checking, but I think that would
+**   break the assumtion that most of the WM_PAINT
+**   messges are only going to be dispatched when
+**   the app is directly calling us.
+*/
+
+BoolDef
+XCheckTypedWindowEvent(
+	Display* display,
+	Window w,
+	int event_type,
+	XEvent* event_return)
+{
+	int i,j;
+	xtrace("XCheckTypedWindowEvent\n");
+	if (w==0) return 0;
+	i = wineventq->next;
+	while(i != wineventq->avail)
+	{
+		if (wineventq->list[i].window==(NT_window*)w)
+		{
+			WinEventToXEvent(&wineventq->list[i],event_return);
+			if (event_return->type == event_type)
+			{
+				break;
+			}
+		}
+		i++;
+		if (i>wineventq->num) i=0;
+	}
+	if (i != wineventq->avail)
+	{
+		while(i != wineventq->next)
+		{
+			j =i-1;
+			if (j<0) j= wineventq->num;
+			copyWinEvent(&wineventq->list[i],&wineventq->list[j]);
+			i = j;
+		}
+		wineventq->next++;
+		wineventq->count--;
+		cjh_printf("removed an event\n");
+		return 1;
+	}
+	return 0;
+}
+
+/*****************************************************************\
+
+
+	Function: XWindowEvent
+	Inputs:   display, window, event mask.
+	Returned: pointer to filled in event structure.
+
+	Comments: This is fudged at the moment to work with the toolkit.
+		  The event system needs rewriting to account properly for
+		  event masks.
+
+\*****************************************************************/
+
+int
+XWindowEvent(display,w,emask,rep)
+Display *display;
+Window w;
+long emask;
+XEvent *rep;
+{
+	NT_window *ntw=(NT_window *)w;
+	MSG msg;
+
+	xtrace("XWindowEvent\n");
+	if (emask&ExposureMask)
+	{
+		GetMessage(&msg,ntw->w,USR_MapNotify,USR_MapNotify);
+		rep->type=ConfigureNotify;
+	}
+	return 0;
+}
+
+
+
+/*****************************************************************\
+
+	Function: XNextEvent
+	Inputs:   display, event structure pointer.
+
+	Comments: Windows routines receive messages (events) in two ways:
+		  firstly by GetMessage, which takes messages from the
+		  calling thread's message queue, and secondly by the
+		  window function being called with events as arguments.
+		  To simulate the X system, we get messages from the queue
+		  and pass them to the window function anyway, which
+		  processes them and fills out the local XEvent structure.
+		  DispatchMessage calls the window procedure and waits until
+		  it returns. Translate message turns WM_KEYUP/DOWN messages
+		  into WM_CHAR.
+
+\*****************************************************************/
+
+int
+XNextEvent(display, event)
+Display *display;
+XEvent  *event;
+{
+	MSG msg;
+	WinEvent we;
+	
+	xtrace("XNextEvent\n");
+
+	/* if there isn't already an event in the pipe, this will block */
+	while(wineventq->count <= 0 && GetMessage(&msg, NULL, 0, 0)>0)
+	{		
+		TranslateMessage(&msg);
+		DispatchMessage(&msg);
+	}
+	if (wineventq->count>0)
+	{
+		getQdEvent(wineventq,&we);
+		WinEventToXEvent(&we,event);
+	}
+	else
+	{
+		/* hmm, GetMessage failed, maybe we're supposed to quit */
+		event->type=ClientMessage;
+		event->xclient.format = 32;
+		event->xclient.data.l[0] = XInternAtom(NULL,"WM_DELETE_WINDOW", FALSE);
+		return 1;
+	}
+	return 1;
+	
+}
+
+BoolDef
+XFilterEvent(XEvent* event,Window window)
+{
+	xtrace("XFilterEvent\n");
+	return 0;
+}
+
+BoolDef
+XQueryPointer(
+	Display* display,
+	Window w,
+	Window* root_return,
+	Window* child_return,
+	int* root_x_return,
+	int* root_y_return,
+	int* win_x_return,
+	int* win_y_return,
+	unsigned int* mask_return)
+{
+    POINT point;
+	RECT rect;
+	xtrace("XQueryPointer\n");
+    GetCursorPos(&point);
+    *root_x_return = point.x;
+    *root_y_return = point.y;
+	GetWindowRect(((NT_window*)w)->w,&rect);
+	*win_x_return= point.x - rect.left;
+	*win_y_return= point.y - rect.top;
+	*mask_return = NT_get_state();
+    return True;
+}
+
+/*****************************************************************\
+
+	Function: NT_get_state
+	Inputs: 
+
+	Comments: Get the keyboard state
+
+\*****************************************************************/
+
+static unsigned int
+NT_get_state()
+{
+	unsigned int state = 0;
+	if (GetKeyState(VK_SHIFT)   & 0x8000) state |= ShiftMask;
+	if (GetKeyState(VK_CONTROL) & 0x8000)
+	{
+		if (!(GetKeyState(VK_MENU) & 0x8000)) 
+			state |= ControlMask;
+	}
+	else if (GetKeyState(VK_MENU)    & 0x8000)
+		state |= Mod1Mask;
+	if (GetKeyState(VK_CAPITAL) & 0x0001) state |= LockMask;
+	if (GetKeyState(VK_NUMLOCK) & 0x0001) state |= Mod5Mask;
+	if (GetKeyState(VK_SCROLL)  & 0x0001) state |= Mod3Mask;
+	if (GetKeyState(VK_LBUTTON) & 0x8000) state |= Button1Mask;
+	if (GetKeyState(VK_MBUTTON) & 0x8000) state |= Button2Mask;
+	if (GetKeyState(VK_RBUTTON) & 0x8000) state |= Button3Mask;
+	return state;
+}
diff -urN rxvt-2.7.2-orig/W11/w32/ntdef.h rxvt-2.7.2/W11/w32/ntdef.h
--- rxvt-2.7.2-orig/W11/w32/ntdef.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/w32/ntdef.h	Sun Jun  3 21:30:54 2001
@@ -0,0 +1,68 @@
+
+
+#ifndef __NTDEF
+#define __NTDEF
+#include <windows.h>
+
+#define INVALID_HANDLE ((HANDLE) -2)
+#define NONMAPPED_HANDLE  ((HANDLE) -3)
+#define VALID_WINDOW(x) (x && (((NT_window *)x)->w != INVALID_HANDLE))
+#define xtrace
+#define cjh_printf
+
+#define CNUMTORGB(x) x
+	 /* #define printf(x)   *//* x */ 
+	 /* #define SetSystemPaletteUse(x) *//* x */
+
+/*	Windows NT Special event aliases	*/
+
+#define USR_MapNotify       0x0401
+#define USR_EnterNotify     0x0402
+#define USR_LeaveNotify     0x0403
+#define USR_Expose          0x0404
+#define USR_ResizeRequest   0x0405
+
+struct NT_child
+{
+	struct NT_window *w;
+	struct NT_child *next;
+} NT_child;
+
+typedef struct NT_window
+{
+	HWND w;
+	HBRUSH bg;
+	struct NT_window *parent;      /* parent of this window */
+	struct NT_window *next;        /* next window in list */
+	struct NT_child *child;        /* points to list of children */
+	int    x, y;                   /* Position */
+	unsigned int wdth, hght;       /* Dimensions */
+	char *title_text;
+	struct NT_prop_list *props;    /* linked list of properties.*/
+	HDC    hDC;
+	HBITMAP hBitmap;
+	int min;
+	int minx, miny;  /* minimum window size */
+	int top_flag;
+	long mask;   /* selectInputMask */
+} NT_window;
+
+/* Routine declarations */
+
+struct NT_window      *NT_find_window_from_id();
+int                    NT_delete_window();
+struct NT_window      *NT_new_window();
+int NT_add_child(NT_window *parent,NT_window *child);
+struct NT_window *NT_find_child(NT_window *w,unsigned long mask,
+								   unsigned long val);
+int NT_del_child(NT_window *parent,NT_window *child);
+void freeMemory(void *p);
+void *allocateMemory(int s);
+void initQ();
+void catchNextDestroyClipboard();
+
+void NT_SetAtom(ATOM class);
+HWND NT_create_window(char *title,DWORD style,int x,int y,int w, int h,HWND parent);
+LONG NT_handleMsg(HWND hWnd,UINT message,UINT wParam,LONG lParam);
+
+#endif
diff -urN rxvt-2.7.2-orig/W11/w32/ntutil.c rxvt-2.7.2/W11/w32/ntutil.c
--- rxvt-2.7.2-orig/W11/w32/ntutil.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/w32/ntutil.c	Thu May 17 23:05:46 2001
@@ -0,0 +1,286 @@
+#include "ntdef.h"
+
+static struct NT_window *window_list=NULL;
+
+void
+freeMemory(void *p) {
+	if (p!=NULL) free(p);
+}
+void *
+allocateMemory(int s) {
+	void *p=NULL;
+	if (s)
+	{
+		p=(void *)malloc(s);
+		if (p) memset(p,0,s);
+	}
+	return p;
+}
+
+
+/*---------------------------------------------------*\
+| Function: NT_new_window                             |
+| Purpose:  Add a new window id to the Window table   |
+| Return:   Pointer to the new Window structure.      |
+\*---------------------------------------------------*/
+struct NT_window *
+NT_new_window()
+{
+	struct NT_window *new;
+	xtrace("NT_new_window\n");
+	new = (struct NT_window *) allocateMemory (sizeof(struct NT_window));
+	new->next = window_list;
+	new->child=NULL;
+	new->min = 1;
+	new->minx =0;
+	new->miny =0;
+	new->w = INVALID_HANDLE;
+	new->hBitmap = INVALID_HANDLE;
+	new->hDC = INVALID_HANDLE;
+	window_list = new;
+	cjh_printf("NEW window %x\n",window_list);
+	return(window_list);
+}
+	
+/*---------------------------------------------------*\
+| Function: NT_delete_window                          |
+| Purpose:  Remove a window from the window list      |
+| Input:    w - pointer to window data                |
+| Return:   TRUE if deleted                           |
+\*---------------------------------------------------*/
+int
+NT_delete_window(struct NT_window *w)
+{
+	NT_window *f;
+	xtrace("NT_delete_window\n");
+	
+	if (w->w != INVALID_HANDLE)
+	{
+		/* ShowWindow(w->w,SW_HIDE);*/
+		DestroyWindow(w->w);
+		w->w=INVALID_HANDLE;
+	}
+	if (w->hBitmap != INVALID_HANDLE)
+	{
+		DeleteObject(w->hBitmap);
+		w->hBitmap = INVALID_HANDLE;
+	}
+	if (w->hDC != INVALID_HANDLE)
+	{
+		DeleteDC(w->hDC);
+		w->hDC=INVALID_HANDLE;
+	}
+	
+	if (window_list == w)
+		window_list=w->next;
+	else
+	{
+		for (f=window_list; f!=NULL && f->next!=w; f=f->next);
+		if (f!=NULL)
+			f->next = w->next;
+	}
+	freeMemory(w);
+	return TRUE;
+}
+
+/*------------------------------------------------*\
+| Function: NT_find_window_from_id                 |
+| Purpose:  Find the window in the window list     |
+|           from the HWND id of the window.        |
+| Input:    w - Window id (Windows HWND)           |
+| Return:   pointer to NT_window structure for w.  |
+\*------------------------------------------------*/
+struct NT_window *
+NT_find_window_from_id(HWND w)
+{
+	struct NT_window *current = window_list;
+	/* xtrace("NT_find_window_from_id\n"); */
+	
+	while ( current != NULL &&
+			current->w != w )
+		current = current->next;
+	if(current)
+		return(current);
+	current=window_list;
+	return NULL;
+}
+
+/*****************************************************************\
+
+	Function: NT_add_child
+	Inputs:   parent and child window IDs.
+	Returned: 1
+
+	Comments: When a child window is created (eg. client canvas) we
+		  update our internal list of windows and their children.
+		  New children are added to the front of the list.
+
+\*****************************************************************/
+
+int
+NT_add_child(parent,child)
+NT_window *parent,*child;
+{
+	struct NT_child *new;
+
+	new=(struct NT_child *) allocateMemory (sizeof(struct NT_child));
+	new->w=child;
+	new->next = parent->child;
+	parent->child=new;
+	return(1);
+}
+
+struct NT_window *
+NT_find_child(NT_window *w,unsigned long mask,
+								unsigned long val)
+{
+	struct NT_window *ret = NULL;
+	struct NT_child *child = NULL;
+	if (w)
+	{
+		if ((w->mask&mask)==val) ret=w;
+		child = w->child;
+		while(!ret && child) {
+			ret = NT_find_child(child->w, mask, val);
+			child=child->next;
+		}
+	}
+	return ret;
+}
+
+
+
+/*****************************************************************\
+
+	Function: NT_del_child
+	Inputs:   parent and child window IDs.
+	Returned: TRUE if window is removed, FALSE otherwise.
+
+	Comments: Finds child window if it exits, and it so removes it from
+		  the window list.
+
+\*****************************************************************/
+
+int
+NT_del_child(parent,child)
+struct NT_window *parent;
+struct NT_window *child;
+{
+	struct NT_child *current,*last;
+	int status=FALSE;
+
+	if (parent->child==NULL)
+	{
+	}
+	else if (parent->child->w==child)
+	{
+		current = parent->child;
+		parent->child=parent->child->next;
+		freeMemory(current);
+		status=TRUE;
+	}
+	else
+	{
+		last=parent->child;
+		current=parent->child->next;
+		while (current->w!=child && current!=NULL)
+		{
+			last=current;
+			current=current->next;
+		}
+		if (current!=NULL)
+		{
+			last->next=current->next;
+			freeMemory(current);
+			status=TRUE;
+		}
+	}
+	return(status);
+}
+
+/*****************************************************************\
+
+	Function: WinMain
+	Inputs:   instance, previous instance, command line arguments,
+		  default start up.
+
+	Comments: Called instead of main() as the execution entry point.
+
+\*****************************************************************/
+#ifdef NOTCYGWIN
+#define MAX_COMMAND_ARGS 20
+static HANDLE hInstance,hPrevInstance;
+int APIENTRY
+WinMain(HINSTANCE hInst,HINSTANCE hPrevInst,LPSTR lpCmdLine,int nCmdShow)
+{
+        static char *command_args[MAX_COMMAND_ARGS];
+        static int num_command_args;
+        static char proEng[] = "proe";
+        char *wordPtr,*tempPtr;
+        int i,quote;
+	hInstance=hInst;
+	hPrevInstance=hPrevInst;
+
+        for (i=0;i<MAX_COMMAND_ARGS;i++)
+          command_args[i] = NULL;
+
+        wordPtr = lpCmdLine;
+        quote = 0;
+        num_command_args = 1;
+        command_args[0] = proEng;
+        while  (*wordPtr && (*wordPtr == ' ' || *wordPtr == '\t'))
+           wordPtr++;
+        if (*wordPtr == '\"')
+        {
+          quote = 1;
+          wordPtr++;
+        }
+        if (!*wordPtr)
+          main(0,NULL);
+        else
+        {
+          while (*wordPtr && num_command_args < MAX_COMMAND_ARGS)
+          {
+            tempPtr = wordPtr;
+            if (quote)
+            {
+              while (*tempPtr && *tempPtr != '\"')
+                tempPtr++;
+              quote = 0;
+            }
+            else
+              while (*tempPtr && *tempPtr != ' ')
+                tempPtr++;
+            if (*tempPtr)
+              *(tempPtr++) = '\0';
+            command_args[num_command_args++] = wordPtr;
+            wordPtr = tempPtr;
+            while (*wordPtr && (*wordPtr == ' ' || *wordPtr == '\t'))
+              wordPtr++;
+            if (*wordPtr == '\"')
+            {
+              quote = 1;
+              wordPtr++;
+            }
+          }
+          main(num_command_args,command_args);
+        }
+
+}
+#endif
+
+static ATOM atom=0;
+void
+NT_SetAtom(ATOM class)
+{
+	atom = class;
+}
+
+HWND
+NT_create_window(char *title,DWORD style,int x,int y,int w, int h,HWND parent)
+{
+	HMODULE hInst = NULL; /* GetModuleHandleA(NULL); */
+	return CreateWindow((LPCTSTR)MAKELONG(atom,0),title,style,x,y,w,h,
+								 parent,NULL,hInst,NULL);
+}
+
diff -urN rxvt-2.7.2-orig/W11/w32/xlib.c rxvt-2.7.2/W11/w32/xlib.c
--- rxvt-2.7.2-orig/W11/w32/xlib.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/w32/xlib.c	Sun Jun  3 21:31:30 2001
@@ -0,0 +1,5044 @@
+/*****************************************************************\
+
+
+	Library of X window functions which call Windows 32
+	equivalent functions.
+
+	Some data structures are maintained by this code,
+	simulating the operation of an X server and window manager.
+
+	Aug/Sep-92	xyz	$$1 Created.
+        Oct-92  abc $$2 Added color stuff.
+
+\******************************************************************/
+
+#ifndef __XNT
+#define __XNT
+
+#include <X11/Xlib.h>
+
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+#include <fcntl.h>
+#include "ntdef.h"
+
+/* Local Data */
+
+static void                   NT_set_GC_pen();
+static void                   NT_set_GC_brush();
+static HPEN                   NT_get_GC_pen();
+static HBRUSH                 NT_get_GC_brush();
+
+void NT_set_rop();
+double NT_deg64_to_rad(int a);
+
+/*----------------------------------------------------------------*\
+| FUNCTIONS TO MAINTAIN AN INTERNAL LIST OF WINDOWS AND THEIR      |
+| ATTRIBUTES - AS WOULD BE MAINTAINED IN THE X SERVER.             |
+\*----------------------------------------------------------------*/
+
+/* Structure to hold pen and brush info in GC ext_data field */
+
+typedef struct NTGC_
+{
+	HPEN	pen;
+	HBRUSH	brush;
+} NTGC;
+
+HDC
+cjh_get_dc(NT_window *window)
+{
+	/* pixmaps have to do SelectObject() on their dc's */
+	if (window->hDC == INVALID_HANDLE)
+		if (window->w == INVALID_HANDLE)
+		{
+			window->hDC= CreateDC("DISPLAY", NULL, NULL, NULL);
+		}
+	else
+		window->hDC=GetDC(window->w);
+    return window->hDC;
+}
+
+int
+cjh_rel_dc(NT_window *window,HDC dc)
+{
+	return TRUE;
+	/*	return ReleaseDC(window, dc); */
+}
+
+HDC
+drawableGetDC(Drawable drawable)
+{
+	cjh_get_dc((NT_window *)drawable);
+}
+
+int
+drawableRelDC(Drawable drawable, HDC hDC)
+{
+	cjh_rel_dc((NT_window *)drawable, hDC);
+}
+
+
+
+/*****************************************************************\
+
+	Function: XOpenDisplay
+	Inputs:   Display name
+
+	Comments: Fills out a Display structure and a Visual and Screen.
+		  Hopefully all the X macros should work with this
+		  structure.  Note that the default visual is for a
+		  True colour screen (24bits).
+\*****************************************************************/
+Display *
+XOpenDisplay (name)
+const char *name;
+{
+	static char vstring[]="NT Xlibemu",
+		*vs,*dn;
+
+	Display *d = NULL;
+	Screen *scrd;
+	static Depth dlist[1];
+	static Visual vlist[1];
+	Colormap cmap;
+	RECT rect;
+	int depth;
+	HDC rootDC = CreateDC("DISPLAY",NULL,NULL,NULL);
+
+	depth = GetDeviceCaps(rootDC, BITSPIXEL);
+	
+	xtrace("XOpenDisplay\n");
+
+	initQ();
+	
+	dlist[0].depth=depth;
+	dlist[0].nvisuals=1;
+	dlist[0].visuals=vlist;
+	vlist[0].ext_data=NULL;
+	vlist[0].visualid=0;
+	vlist[0].class=PseudoColor;
+	vlist[0].bits_per_rgb=8;
+	vlist[0].map_entries=256;
+	vlist[0].red_mask=255;
+	vlist[0].green_mask=255<<8;
+	vlist[0].blue_mask=255<<16;
+	scrd=(Screen *) allocateMemory (sizeof (Screen));
+	(NT_window*)(scrd->root)= NT_new_window();
+	((NT_window*)(scrd->root))->w=GetDesktopWindow();
+	((NT_window*)(scrd->root))->parent=0;
+	GetWindowRect(GetDesktopWindow(),&rect);
+	scrd->width=rect.right-rect.left;
+	scrd->height=rect.bottom-rect.top;
+	scrd->mwidth=260;
+	scrd->mheight=190;
+	scrd->ndepths=1;
+	scrd->depths=dlist;
+	scrd->root_depth=depth;
+	scrd->root_visual=vlist;
+	scrd->default_gc=NULL;
+	scrd->cmap=cmap;
+	scrd->white_pixel=0xffffff;
+	scrd->black_pixel=0;
+
+	d=(Display *) allocateMemory (sizeof (Display));
+	scrd->display=d;
+	vs=(char *) allocateMemory (sizeof (char)*strlen (vstring)+1);
+	dn=(char *) allocateMemory (sizeof (char)*strlen (name)+1);
+	strcpy (vs,vstring);
+	strcpy (dn,name);
+	d->ext_data=NULL;
+	d->fd=0;
+	d->proto_major_version=11;
+	d->proto_minor_version=4;
+	d->vendor=vs;
+	d->release=4;
+	d->display_name=dn;
+	d->nscreens=1;
+	d->screens=scrd;
+	d->max_keycode=255;
+
+	return (d);
+}
+
+
+int
+XCloseDisplay(Display *display)
+{
+  NT_window *wanderer;
+
+  xtrace("XCloseDisplay\n");
+/* Do something ? */
+/* Must GlobalDelete all atoms/properties leftover */
+  return 0;
+}
+
+char *
+XDisplayString(Display *display)
+{
+	return (display->display_name);
+}
+
+
+int
+XFlush(Display *display)
+{
+	xtrace("XFlush\n");
+	return 0;
+}
+
+
+int
+XSync(display,discard)
+Display *display;
+int discard;
+{
+	/* Do nothing here either */
+	return 0;
+}
+
+/*****************************************************************\
+
+	Function: XGetVisualInfo
+	Inputs:   display, info mask, template, number of matches.
+	Returned: List of XVisualInfo structures, one for each matching
+		  Visual.
+
+	Comments: Behaves like X routine, but there is only ever one
+		  Visual, so the returned list is never longer than one.
+
+\*****************************************************************/
+XVisualInfo *
+XGetVisualInfo(display,vinm,vint,n)
+Display *display;
+long vinm;
+XVisualInfo *vint;
+int *n;
+{
+	static XVisualInfo xvi;
+	int status=1;
+	xtrace("XGetVisualInfo\n");
+
+	if ((vinm&VisualIDMask|vinm==VisualAllMask)&&
+            vint->visualid!=display->screens->root_visual->visualid)
+		status=0;
+	if ((vinm&VisualScreenMask|vinm==VisualAllMask)&&
+	    vint->screen!=0)
+		status=0;
+	if ((vinm&VisualDepthMask|vinm==VisualAllMask)&&
+	    vint->depth!=24)
+		status=0;
+	if ((vinm&VisualClassMask|vinm==VisualAllMask)&&
+	    vint->class!=display->screens->root_visual->class)
+		status=0;
+	if ((vinm&VisualRedMaskMask|vinm==VisualAllMask)&&
+	    vint->red_mask!=display->screens->root_visual->red_mask)
+		status=0;
+	if ((vinm&VisualGreenMaskMask|vinm==VisualAllMask)&&
+	    vint->green_mask!=display->screens->root_visual->green_mask)
+		status=0;
+	if ((vinm&VisualBlueMaskMask|vinm==VisualAllMask)&&
+	    vint->blue_mask!=display->screens->root_visual->blue_mask)
+		status=0;
+	if ((vinm&VisualColormapSizeMask|vinm==VisualAllMask)&&
+	    vint->colormap_size!=display->screens->root_visual->map_entries)
+		status=0;
+	if ((vinm&VisualBitsPerRGBMask|vinm==VisualAllMask)&&
+	    vint->bits_per_rgb!=display->screens->root_visual->bits_per_rgb)
+		status=0;
+	if (status==1)
+	{
+		xvi.visualid=display->screens->root_visual->visualid;
+		xvi.screen=0;
+		xvi.depth=display->screens->root_visual->bits_per_rgb;
+		xvi.class=display->screens->root_visual->class;
+		xvi.red_mask=display->screens->root_visual->red_mask;
+		xvi.green_mask=display->screens->root_visual->green_mask;
+		xvi.blue_mask=display->screens->root_visual->blue_mask;
+		xvi.colormap_size=display->screens->root_visual->map_entries;
+		xvi.bits_per_rgb=display->screens->root_visual->bits_per_rgb;
+		xvi.visual=display->screens->root_visual;
+		*n=1;
+		return (&xvi);
+	}
+	*n=0;
+	return (&xvi);
+}
+
+StatusDef XMatchVisualInfo(
+    Display*		display,
+    int			screen,
+    int			depth,
+    int			class,
+    XVisualInfo*	vinfo_return)
+{
+	int status=0;
+	xtrace("XMatchVisualInfo\n");
+	return status;
+}
+
+/*****************************************************************\
+
+	Function: XClearWindow
+	Inputs:   display, window
+
+	Comments: As mentioned, the Window structure is not the one windows
+		  recognises.  The background colour for the window is
+		  stored in this structure.
+
+		  The sequence of GetDC, CreateBrush/Pen, SelectObject,
+		  <draw stuff>, DeleteObject, ReleaseDC occurs in all the
+		  drawing functions.
+
+\*****************************************************************/
+int
+XClearWindow(display, w)
+Display *display;
+Window w;
+{
+	RECT  rRect;
+	HBRUSH hbrush;
+	HDC hDC;
+	HANDLE oldObj;
+	int oldROP;
+	NT_window *window = (NT_window *)w;
+	xtrace("XClearWindow\n");
+
+	if (VALID_WINDOW(window)) {
+		rRect.left= rRect.right=rRect.bottom=rRect.top =0;
+	
+		hDC = cjh_get_dc(window);
+		oldROP = SetROP2(hDC,R2_COPYPEN);
+		hbrush = window->bg;
+		oldObj = SelectObject(hDC, hbrush);
+		GetClientRect(window->w, &rRect);
+		FillRect(hDC, &rRect, hbrush);
+		SelectObject(hDC, oldObj);
+		//	DeleteObject(hbrush);
+		SetROP2(hDC,oldROP);
+		cjh_rel_dc(window,hDC);
+	}
+	
+	return 0;
+}
+
+/*****************************************************************\
+
+	Function: XCreateSimpleWindow
+	Inputs:   display, parent window, geometry, border width,
+		  border colour, background colour.
+	Returned: Window ID
+
+	Comments: The first time a window is made by the application, it
+		  has to be registered.
+		  To simulate the action of a window manager, the toplevel
+		  client window is reparented and a frame window is created.
+		  A MapNotify event is sent to the new client.
+		  Note that child windows are created in the manner of the
+		  default X behaviour, ie. each is clipped individually.
+
+
+        NOTE:     This routine has now changed. As part of our role as
+                  Window manager, we now defer creation of the windows until
+                  they are mapped. The fact that a window has been created
+                  and not mapped is flagged to other routines by setting the
+                  w element of the structure to -1.
+                  WE STILL CREATE THE Window STRUCTURES.
+                  (SEE XMapWindow)
+
+\*****************************************************************/
+
+Window
+XCreateSimpleWindow(display, parent,x, y, w, h, brd, brd_col, bg)
+Display *display;
+Window  parent;
+int     x, y;
+unsigned int brd,w,h;
+unsigned long bg, brd_col;
+{
+	NT_window  *canvas;
+	xtrace("XCreateSimpleWindow\n");
+
+	canvas = NT_new_window();
+	
+	canvas->x = x;
+	canvas->y = y;
+	canvas->wdth = w;
+	canvas->hght = h;
+	NT_add_child((NT_window *)parent,canvas);
+	canvas->bg=CreateSolidBrush (CNUMTORGB(bg));
+	canvas->parent=(NT_window *)parent;
+	canvas->title_text = NULL;
+	if (canvas->parent->w == GetDesktopWindow())
+	{
+		if (x==0 && y==0)
+		{
+			canvas->x = -1;
+			canvas->y = -1;
+		}
+		canvas->top_flag = TRUE;
+	}
+	else
+		canvas->top_flag = 0;
+	return ((Window)canvas);
+}
+
+
+/*****************************************************************\
+
+	Function: XCreateWindow
+	Inputs:   display, parent window, geometry, border width, depth,
+		  class, visual, attributes mask, attributes structure
+	Returned: Window ID
+
+	Comments: Simply calls XCreateSimpleWindow.  Some of the arguments
+		  are ignored :-).
+
+\*****************************************************************/
+
+Window
+XCreateWindow(display,parent,x,y,width,height,bw,depth,class,visual,
+			valuemask,attr)
+Display *display;
+Window  parent;
+int x,y;
+unsigned int width,height,bw;
+int depth;
+unsigned int class;
+Visual *visual;
+unsigned long valuemask;
+XSetWindowAttributes *attr;
+{
+	xtrace("XCreateWindow\n");
+	return (XCreateSimpleWindow(display,parent,x,y,width,height,bw,
+		attr->border_pixel,attr->background_pixel));
+}
+
+
+/*****************************************************************\
+
+	Function: XDestroyWindow
+	Inputs:   Display, window to be destroyed.
+
+	Comments: Removes a window from the server.  
+
+\*****************************************************************/
+int
+XDestroyWindow(display,w)
+Display *display;
+Window w;
+{
+	NT_window *ntw = (NT_window *)w;
+	xtrace("XDestroyWindow\n");
+        if (ntw->hDC != INVALID_HANDLE)
+		{
+          ReleaseDC(ntw->w,ntw->hDC);
+		  ntw->hDC =  INVALID_HANDLE;
+		}
+		
+	/*DestroyWindow(w->w);*/
+	NT_delete_window(ntw);   /* Remove window from data structure */
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XGetGeometry
+	Inputs:   display, window
+	Returned: root window, screen depth, geometry, border width
+
+	Comments: fetches information from the windows kernel and our
+		  display structure.
+
+\*****************************************************************/
+
+StatusDef
+XGetGeometry(display,w,root,x,y,width,height,bw,depth)
+Display *display;
+Drawable w;
+Window *root;
+int *x,*y;
+unsigned int *width,*height;
+unsigned int *bw,*depth;
+{
+	NT_window *ntw = (NT_window *)w;
+	RECT r;
+	xtrace("XGetGeometry\n");
+
+	*root=display->screens[0].root;
+	*depth=24;
+
+	GetWindowRect(ntw->w,&r);
+	*x=r.left;
+	*y=r.top;
+	GetClientRect(ntw->w,&r);
+	*width=r.right-r.left;
+	if (*width<ntw->minx)
+		*width=ntw->minx;
+	*height=r.bottom-r.top;
+	if (*height<ntw->miny)
+		*height=ntw->miny;
+	*bw=(*width-(r.right-r.left))/2;
+	
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XGetWindowAttributes
+	Inputs:   display, window, attributes
+	Returned: 1 = ok.
+
+	Comments: Fills out attributes structure.
+
+\*****************************************************************/
+
+StatusDef
+XGetWindowAttributes(display,w,wattr)
+Display *display;
+Window w;
+XWindowAttributes *wattr;
+{
+	xtrace("XGetWindowAttributes\n");
+	XGetGeometry(display,w,&wattr->root,&wattr->x,&wattr->y,&wattr->width,
+		&wattr->height,&wattr->border_width,&wattr->depth);
+	wattr->class=InputOutput;
+	wattr->bit_gravity=StaticGravity;
+	wattr->win_gravity=CenterGravity;
+	wattr->backing_store=NotUseful;
+	wattr->backing_planes=0;
+	wattr->backing_pixel=0;
+	wattr->save_under=0;
+	wattr->colormap=None;
+	wattr->map_installed=TRUE;
+	wattr->map_state=IsViewable;
+	wattr->override_redirect=FALSE;
+	wattr->screen=display->screens;
+	return (1);
+}
+
+
+
+int
+XSelectInput(display, window, mask)
+Display *display;
+Window  window;
+long    mask;
+{
+	NT_window *ntw = (NT_window *)window;
+	xtrace("XSelectInput\n");
+	ntw->mask=mask;
+	return 0;
+}
+
+void NT_dispError(char *msg)
+{
+	LPVOID lpMsgBuf=NULL;
+	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
+				  GetLastError(),
+				  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+				  (LPTSTR) &lpMsgBuf,
+				  0,
+				  NULL);
+	MessageBox( NULL, lpMsgBuf, msg, MB_OK|MB_ICONINFORMATION );
+	LocalFree( lpMsgBuf );
+}
+
+
+/*****************************************************************\
+
+	Function: XMapWindow
+	Inputs:   display, window to be mapped
+
+	Comments: If the specified window is not already mapped, this
+		  routine calls the Windows function which displays it.
+		  Again, frames have to be mapped as well as clients.
+
+\*****************************************************************/
+int
+XMapWindow(display, window)
+Display *display;
+Window window;
+{
+	NT_window *ntw = (NT_window *)window;
+	RECT rect;
+	unsigned char *hints;
+	Atom property;
+	Atom ret_type;
+	int ret_format;
+	DWORD frame_style;
+	long ret_nitems;
+	long ret_after;
+	HDC hDC;
+	char *title = "";
+	xtrace("XMapWindow\n");
+	
+	if (ntw->w == INVALID_HANDLE)
+	{
+		frame_style = WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
+		if (ntw->top_flag)
+		{
+			/* frame_style = WS_CLIPCHILDREN;
+			   frame_style |=  WS_BORDER;
+			   frame_style |= WS_THICKFRAME;
+			   frame_style |= WS_CAPTION;
+			   frame_style |= WS_POPUP;
+			   frame_style |= WS_SYSMENU;
+			   frame_style |= WS_MINIMIZEBOX;
+			   frame_style |= WS_MAXIMIZEBOX;
+			*/
+			frame_style = WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN;
+			ntw->hght +=  20+GetSystemMetrics(SM_CYSIZE)+(GetSystemMetrics(SM_CYEDGE)*2)+GetSystemMetrics(SM_CYFRAME);
+			ntw->wdth += 4+GetSystemMetrics(SM_CXEDGE)*2;
+			title = ntw->title_text;
+			if (ntw->x == -1 && ntw->y == -1)
+			{
+				ntw->x = CW_USEDEFAULT;
+				ntw->y = CW_USEDEFAULT;
+			}
+		}
+		else if (ntw->x == -1 && ntw->y == -1)
+		{
+			GetClientRect(ntw->parent->w,&rect);
+			ntw->x = rect.left;
+			ntw->y = rect.top;
+			ntw->wdth = rect.right-rect.left;
+			ntw->hght = rect.bottom - rect.top;
+		}
+
+		ntw->hDC = INVALID_HANDLE;
+		
+		if (ntw->parent->w == INVALID_HANDLE)
+		{
+			XMapWindow(display, (Window)ntw->parent);
+		}
+		ntw->w = NT_create_window(title,frame_style,
+								 ntw->x,ntw->y,ntw->wdth,ntw->hght,
+								 ntw->parent->w);
+		if (ntw->w==NULL) NT_dispError("create window1");
+		hDC = cjh_get_dc(ntw);
+		PostMessage(ntw->w,USR_MapNotify,0,0);
+	}
+	if (IsWindowVisible(ntw->w)==0)
+	{
+		ShowWindow(ntw->w, SW_SHOW);
+		PostMessage(ntw->w,USR_MapNotify,0,0);
+	}
+	UpdateWindow(ntw->w);
+	return 0;
+}
+
+int
+XIconifyWindow(Display *display,
+    Window w,
+    int screen_number)
+{
+	xtrace("XIconifyWindow\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XCreateGC
+	Inputs:   display, window, mask of setup values, setup values.
+	Returned: GC pointer.
+
+	Comments: Fills out a GC structure with the X defaults unless
+		  the caller specifies otherwise.
+
+\*****************************************************************/
+
+GC
+XCreateGC(display, window, mask, gc_values)
+Display *display;
+Drawable window;
+unsigned long mask;
+XGCValues *gc_values;
+{
+	GC	local_gc;
+	int	size;
+	char	*ptr;
+	xtrace("XCreateGC\n");
+
+	size = sizeof(GC);
+
+	ptr = (char *)allocateMemory((size_t)1000);
+	local_gc = (GC)ptr;
+	local_gc->ext_data = NULL;
+	local_gc->gid=(GContext) window;
+	local_gc->rects=FALSE;
+	local_gc->dashes=FALSE;
+
+	if (mask&GCArcMode)
+		local_gc->values.arc_mode=gc_values->arc_mode;
+	else
+		local_gc->values.arc_mode=ArcPieSlice;
+	if (mask&GCBackground)
+		local_gc->values.background=gc_values->background;
+	else
+		local_gc->values.background=display->screens->white_pixel;
+	if (mask&GCCapStyle)
+		local_gc->values.cap_style=gc_values->cap_style;
+	else
+		local_gc->values.cap_style=CapButt;
+	if (mask&GCClipMask)
+		local_gc->values.clip_mask=gc_values->clip_mask;
+	else
+		local_gc->values.clip_mask=None;
+	if (mask&GCClipXOrigin)
+		local_gc->values.clip_x_origin=gc_values->clip_x_origin;
+	else
+		local_gc->values.clip_x_origin=0;
+	if (mask&GCClipYOrigin)
+		local_gc->values.clip_y_origin=gc_values->clip_y_origin;
+	else
+		local_gc->values.clip_y_origin=0;
+	if (mask&GCDashList)
+		local_gc->values.dashes=gc_values->dashes;
+	else
+		local_gc->values.dashes=4;
+	if (mask&GCDashOffset)
+		local_gc->values.dash_offset=gc_values->dash_offset;
+	else
+		local_gc->values.dash_offset=0;
+	if (mask&GCFillRule)
+		local_gc->values.fill_rule=gc_values->fill_rule;
+	else
+		local_gc->values.fill_rule=EvenOddRule;
+	if (mask&GCFillStyle)
+		local_gc->values.fill_style=gc_values->fill_style;
+	else
+		local_gc->values.fill_style=FillSolid;
+	if (mask&GCFont)
+		local_gc->values.font=gc_values->font;
+	else
+		local_gc->values.font= 999;/*"fixed";*/
+	if (mask&GCForeground)
+		local_gc->values.foreground=gc_values->foreground;
+	else
+		local_gc->values.foreground=display->screens->black_pixel;
+	if (mask&GCFunction)
+		local_gc->values.function=gc_values->function;
+	else
+		local_gc->values.function=GXcopy;
+	if (mask&GCGraphicsExposures)
+		local_gc->values.graphics_exposures=gc_values->graphics_exposures;
+	else
+		local_gc->values.graphics_exposures=True;
+	if (mask&GCJoinStyle)
+		local_gc->values.join_style=gc_values->join_style;
+	else
+		local_gc->values.join_style=JoinMiter;
+	if (mask&GCLineStyle)
+		local_gc->values.line_style=gc_values->line_style;
+	else
+		local_gc->values.line_style=LineSolid;
+	if (mask&GCLineWidth)
+		local_gc->values.line_width=gc_values->line_width;
+	else
+		local_gc->values.line_width=0;
+	if (mask&GCPlaneMask)
+		local_gc->values.plane_mask=gc_values->plane_mask;
+	else
+		local_gc->values.plane_mask=255;
+	if (mask&GCStipple)
+		local_gc->values.stipple=gc_values->stipple;
+	else
+		local_gc->values.stipple=0;
+	if (mask&GCSubwindowMode)
+		local_gc->values.subwindow_mode=gc_values->subwindow_mode;
+	else
+		local_gc->values.subwindow_mode=ClipByChildren;
+	if (mask&GCTile)
+		local_gc->values.tile=gc_values->tile;
+	else
+		local_gc->values.tile=0;
+	if (mask&GCTileStipXOrigin)
+		local_gc->values.ts_x_origin=gc_values->ts_x_origin;
+	else
+		local_gc->values.ts_x_origin=0;
+	if (mask&GCTileStipYOrigin)
+		local_gc->values.ts_y_origin=gc_values->ts_y_origin;
+	else
+		local_gc->values.ts_y_origin=0;
+
+	local_gc->dirty = ~0;
+
+	return (local_gc);
+}
+
+int
+XFreeGC(display, gc)
+Display *display;
+GC gc;
+{
+	freeMemory(gc);
+}
+
+/*****************************************************************\
+
+	Function: XSetForeground
+	Inputs:   display, gc, colour.
+
+	Comments: Colour is an RGB triple (24bits).
+\*****************************************************************/
+int
+XSetForeground(display, gc, color)
+Display *display;
+GC gc;
+unsigned long    color;
+{
+	xtrace("XSetForegrond\n");
+	gc->values.foreground=color;
+	gc->dirty |= GCForeground;
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XDrawString
+	Inputs:   display, window, gc, position, string, length of string.
+
+	Comments: Writes text to the screen in the manner of X windows.
+		  Note that the y origin is on the text baseline, ie.
+		  the lowest part of a letter o rests on the baseline and
+		  descenders fall below it.
+		  The text is transparent.
+
+\*****************************************************************/
+
+int
+XDrawString(Display *display, Drawable window,
+    GC gc, int x, int y, const char* str, int len)
+{
+	HDC          hDC;
+	TEXTMETRIC   tmet;
+	HFONT old;
+	xtrace("XDrawString\n");
+
+	if (VALID_WINDOW(window))
+	{
+		hDC = drawableGetDC(window);
+		SetBkMode(hDC,TRANSPARENT);
+		SetTextColor(hDC,CNUMTORGB(gc->values.foreground));
+		old=SelectObject(hDC,(HFONT)gc->values.font);
+		GetTextMetrics(hDC,&tmet);
+		TextOut(hDC,x,y-tmet.tmAscent,str,len);
+		SelectObject(hDC,old);
+		drawableRelDC(window,hDC);
+	}
+	return 0;
+}
+
+
+
+int
+XDrawString16(Display *display, Drawable window,
+    GC gc, int x, int y,
+    const XChar2b* str,
+    int len)
+{
+	xtrace("XDrawString16\n");
+	return 0;
+}
+XDrawImageString(
+	Display* display,
+	Drawable d,
+	GC gc,
+	int x,
+	int y,
+	const char* string,
+	int length)
+{
+	HDC hDC = NULL;
+	TEXTMETRIC   tmet;
+	HFONT old;
+	xtrace("XDrawImageString\n");
+	if (VALID_WINDOW(d))
+	{
+		hDC = drawableGetDC(d);
+		SetBkMode(hDC,OPAQUE);
+		SetBkColor(hDC, CNUMTORGB(gc->values.background));	
+		SetTextColor(hDC,CNUMTORGB(gc->values.foreground));
+		old=SelectObject(hDC,(HFONT)gc->values.font);
+		GetTextMetrics(hDC,&tmet);
+		TextOut( hDC, x, y-tmet.tmAscent, string, length ); 
+		SelectObject(hDC,old);
+		drawableRelDC(d,hDC);
+	}
+	return 0;
+}
+
+int
+XDrawImageString16(Display *display, Drawable window,
+    GC gc, int x, int y,
+    const XChar2b* str,
+    int len)
+{
+	xtrace("XDrawImageString16\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XFillRectangle
+	Inputs:   display, window, gc, geometry.
+
+	Comments: fills rectangles in uniform colours.  No tiles/Pixmaps
+		  are implemented yet.
+
+\*****************************************************************/
+
+int
+XFillRectangle (display,window,gc,x,y,w,h)
+Display *display;
+Drawable window;
+GC gc;
+int x,y;
+unsigned int w,h;
+{
+	RECT rct;
+	HBRUSH hbrush;
+	HDC hDC;
+	HANDLE oldObj;
+	int ret;
+	xtrace("XFillRectangle\n");
+
+	if (VALID_WINDOW(window))
+	{
+		hDC = drawableGetDC(window);
+		NT_set_rop(hDC,gc);
+		hbrush = NT_get_GC_brush(hDC,gc);
+		oldObj = SelectObject(hDC, hbrush);
+		rct.left=(LONG) x;
+		rct.right=(LONG) (x+w);
+		rct.top=(LONG) y;
+		rct.bottom=(LONG) (y+h);
+		ret=FillRect(hDC, &rct, hbrush);
+		SelectObject(hDC, oldObj);
+		drawableRelDC(window,hDC);
+	}
+	return (ret);
+}
+
+
+/*****************************************************************\
+
+	Function: XClearArea
+	Inputs:   display, geometry, exposure events allowed.
+
+	Comments: Straightforward.
+
+\*****************************************************************/
+int
+XClearArea(display,w,x,y,width,height,exposures)
+Display *display;
+Window w;
+int x,y;
+unsigned int width,height;
+BoolDef exposures;
+{
+	NT_window *ntw = (NT_window *)w;
+	RECT rct;
+	HBRUSH hbrush;
+	HDC hDC;
+	HANDLE oldObj;
+	int oldROP;
+	xtrace("XClearArea\n");
+
+	if (VALID_WINDOW(ntw))
+	{
+		hDC = cjh_get_dc(ntw);
+		oldROP = SetROP2(hDC,R2_COPYPEN);
+		hbrush=ntw->bg;
+		oldObj = SelectObject(hDC,hbrush);
+		GetClientRect(ntw->w,&rct);
+
+		if (width!=0)
+		{
+			rct.left=(LONG)x;
+			rct.right=(LONG)(x+width+1);
+		}
+
+		if (height !=0)
+		{
+			rct.top=(LONG)y;
+			rct.bottom=(LONG)(y+height + 1);
+		}
+
+		FillRect(hDC,&rct,hbrush);
+		SelectObject(hDC, oldObj);
+		// DeleteObject(hbrush);
+		SetROP2(hDC,oldROP);
+		cjh_rel_dc(ntw,hDC);
+	}
+	return 0;
+}
+
+
+Region
+XCreateRegion()
+{
+	HRGN hrgn;
+	xtrace("XCreateRegion\n");
+
+	hrgn=CreateRectRgn(0,0,1,1);
+	return ((Region)hrgn);
+}
+
+
+/* Untested.  The Region stuff needs thinking about. */
+
+int
+XClipBox(hrgn,rect)
+Region hrgn;
+XRectangle *rect;
+{
+	RECT rct;
+	xtrace("XClipBox\n");
+
+	GetRgnBox((HRGN)hrgn,&rct);
+	rect->x=(short)rct.left;
+	rect->y=(short)rct.top;
+	rect->width=(unsigned short)(rct.right-rct.left);
+	rect->height=(unsigned short)(rct.bottom-rct.top);
+	return TRUE;/*(rect);*/
+}
+
+
+int
+XSetRegion(display,gc,hrgn)
+Display *display;
+GC gc;
+Region hrgn;
+{
+	/* What to do here ? */
+	xtrace("XSetRegion\n");
+	return 0;
+}
+
+
+int
+XDestroyRegion(hrgn)
+Region hrgn;
+{
+	xtrace("XDestroyRegion\n");
+	DeleteObject(hrgn);
+	return 0;
+}
+
+
+int
+XUnionRectWithRegion(rect,hrgnsrc,hrgndest)
+XRectangle *rect;
+Region hrgnsrc,hrgndest;
+{
+	HRGN temp;
+	xtrace("XUnionRectWithRegion\n");
+	temp=CreateRectRgn(rect->x,rect->y,rect->x+rect->width,
+				rect->y+rect->height);
+	CombineRgn((HRGN)hrgndest,(HRGN)hrgnsrc,temp,RGN_OR);
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XDrawArc
+	Inputs:   display, window, gc, bounding box geometry, arc angles.
+
+	Comments: Works fine.
+
+\*****************************************************************/
+
+int
+XDrawArc(display,w,gc,x,y,width,height,a1,a2)
+Display *display;
+Drawable w;
+GC gc;
+int x,y;
+unsigned int width,height;
+int a1,a2;
+{
+	HDC hDC;
+	HPEN hpen;
+	int tmp;
+	double NT_deg64_to_rad();
+	HANDLE oldObj;
+	xtrace("XDrawArc\n");
+	if (a2>=0)
+		a2+=a1;
+	else
+	{
+		tmp=a1;
+		a1-=a2;
+		a2=tmp;
+	}
+
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		hpen = NT_get_GC_pen(hDC,gc);
+		oldObj = SelectObject(hDC,hpen);
+		Arc(hDC,x,y,x+width-1,y+height-1,
+			(int) (x+width/2+width*cos(NT_deg64_to_rad(a1))),
+			(int) (y+height/2-height*sin(NT_deg64_to_rad(a1))),
+			(int) (x+width/2+width*cos(NT_deg64_to_rad(a2))),
+			(int) (y+height/2-height*sin(NT_deg64_to_rad(a2))));
+		SelectObject(hDC, oldObj);
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XFillArc
+	Inputs:   display, window, gc, geometry as above.
+
+	Comments: Not tested at all, but should work.
+
+\*****************************************************************/
+
+int
+XFillArc(display,w,gc,x,y,width,height,a1,a2)
+Display *display;
+Drawable w;
+GC gc;
+int x,y;
+unsigned int width,height;
+int a1,a2;
+{
+	HDC hDC;
+	HBRUSH hbrush;
+	int tmp;
+        HANDLE oldObj;
+		xtrace("XFillArc\n");
+	if (a2>=0)
+		a2+=a1;
+	else
+	{
+		tmp=a1;
+		a1-=a2;
+		a2=tmp;
+	}
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		hbrush = NT_get_GC_brush(hDC,gc);
+		oldObj = SelectObject(hDC,hbrush);
+		if (gc->values.arc_mode==ArcChord)
+		{
+			Chord(hDC,x,y,x+width,y+height,
+				  (int) (x+width/2+width*cos(NT_deg64_to_rad(a1))),
+				  (int) (y+height/2+height*sin(NT_deg64_to_rad(a1))),
+				  (int) (x+width/2+width*cos(NT_deg64_to_rad(a2))),
+				  (int) (y+height/2+height*sin(NT_deg64_to_rad(a2))));
+		}
+		else
+		{
+			Pie(hDC,x,y,x+width,y+height,
+				(int) (x+width/2+width*cos(NT_deg64_to_rad(a1))),
+				(int) (y+height/2+height*sin(NT_deg64_to_rad(a1))),
+				(int) (x+width/2+width*cos(NT_deg64_to_rad(a2))),
+				(int) (y+height/2+height*sin(NT_deg64_to_rad(a2))));
+		}
+		SelectObject(hDC, oldObj);
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XFillPolygon
+	Inputs:   display, window, gc, points list, number of points,
+		  shape hint, relative drawing mode.
+
+	Comments: Works for convex polygons.  Untested on otherwise.
+	          Optimisation hints are unused, as is the mode.
+
+\*****************************************************************/
+
+int
+XFillPolygon(display,w,gc,points,nps,shape,mode)
+Display *display;
+Drawable w;
+GC gc;
+XPoint *points;
+int nps,shape,mode;
+{
+	HBRUSH hbrush;
+	int n;
+	POINT ntps[1000];
+	HDC hDC;
+	HANDLE oldObj;
+	xtrace("XFillPolygon\n");
+ 	/*ntps=allocateMemory(sizeof(POINT)*nps);*/
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		hbrush = NT_get_GC_brush(hDC,gc);
+		oldObj = SelectObject(hDC,hbrush);
+		for (n=0;n<nps;++n)
+		{
+			(ntps+n)->x=(LONG)points->x;
+			(ntps+n)->y=(LONG)(points++)->y;
+		}
+		Polygon(hDC,ntps,nps);
+		SelectObject(hDC, oldObj);
+		drawableRelDC(w,hDC);
+	}
+	
+	/*free(ntps);*/
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XDrawLine
+	Inputs:   display, window, geometry.
+
+	Comments: Seems to work ok.
+
+\*****************************************************************/
+
+int
+XDrawLine(display,w,gc,x1,y1,x2,y2)
+Display *display;
+Drawable w;
+GC gc;
+int x1,y1,x2,y2;
+{
+	HDC hDC;
+	HPEN hpen;
+	RECT da;
+	HANDLE oldObj;
+	xtrace("XDrawLine\n");
+
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		hpen = NT_get_GC_pen(hDC,gc);
+		oldObj = SelectObject(hDC,hpen);
+		MoveToEx(hDC,x1,y1,NULL);
+		LineTo(hDC,x2,y2);
+		SelectObject(hDC, oldObj);
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XDrawLines
+	Inputs:   display, window, gc, points list, number of points, mode.
+
+	Comments: Untested.
+
+\*****************************************************************/
+
+int
+XDrawLines(display,w,gc,points,nps,mode)
+Display *display;
+Drawable w;
+GC gc;
+XPoint *points;
+int nps,mode;
+{
+	HPEN hpen;
+	int n;
+	POINT pts[1000];
+	HDC hDC;
+	HANDLE oldObj;
+	xtrace("XDrawLines\n");
+
+	pts->x=(LONG)points->x;
+	pts->y=(LONG)points->y;
+
+	for(n=1;n<nps;++n)
+		if (mode==CoordModeOrigin)
+		{
+			(pts+n)->x=(LONG)(points+n)->x;
+			(pts+n)->y=(LONG)(points+n)->y;
+		}
+		else
+		{
+			(pts+n)->x=(LONG)(points+n)->x+(pts+n-1)->x;
+			(pts+n)->y=(LONG)(points+n)->y+(pts+n-1)->y;
+		}
+
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		hpen = NT_get_GC_pen(hDC,gc);
+		oldObj = SelectObject(hDC,hpen);
+		Polyline(hDC,pts,nps);
+		SelectObject(hDC, oldObj);
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XDrawPoints
+	Inputs:   display, window, gc, points list, number of points, mode.
+
+	Comments: Untested.
+
+\*****************************************************************/
+
+int
+XDrawPoints(display,w,gc,points,nps,mode)
+Display *display;
+Drawable w;
+GC gc;
+XPoint *points;
+int nps,mode;
+{
+	HDC hDC;
+	int n;
+	xtrace("XDrawPoints\n");
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		SetPixelV(hDC,points->x,points->y,CNUMTORGB(gc->values.foreground));
+		for (n=1;n<nps;++n)
+		{
+			if (mode==CoordModeOrigin)
+				SetPixelV(hDC,(points+n)->x,(points+n)->y,
+						  CNUMTORGB(gc->values.foreground));
+			else
+				SetPixelV(hDC,(points+n-1)->x+(points+n)->x,
+					  (points+n-1)->y+(points+n)->y,
+					  CNUMTORGB(gc->values.foreground));
+		}
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+int
+XDrawPoint(display,w,gc,x,y)
+Display *display;
+Drawable w;
+GC gc;
+int x,y;
+{
+	HDC hDC;
+	xtrace("XDrawPoint\n");
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		SetPixelV(hDC,x,y,CNUMTORGB(gc->values.foreground));
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XDrawRectangle
+	Inputs:   display, window, gc, geometry
+
+	Comments: Seems to work.
+
+\*****************************************************************/
+
+int
+XDrawRectangle(display,w,gc,x,y,width,height)
+Display *display;
+Drawable w;
+GC gc;
+int x,y;
+unsigned int width,height;
+{
+	HDC hDC;
+	RECT rect;
+	HBRUSH hbrush;
+	HPEN hpen;
+	HANDLE oldbrush, oldpen;
+	xtrace("XDrawRectangle\n");
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		hbrush = NT_get_GC_brush(hDC,gc);
+		rect.left=(LONG)x;
+		rect.right=(LONG)(x+width);
+		rect.top=(LONG)y;
+		rect.bottom=(LONG)(y+height);
+		oldbrush = SelectObject(hDC,GetStockObject(NULL_BRUSH));
+		hpen = NT_get_GC_pen(hDC,gc);
+		oldpen = SelectObject(hDC,hpen);
+
+		Rectangle(hDC,(int)rect.left,(int)rect.top,(int)rect.right,(int)rect.bottom);
+		/*
+		  FrameRect(hDC,&rect,hbrush);
+		*/
+		SelectObject(hDC, oldbrush);
+		SelectObject(hDC, oldpen);
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XDrawSegments
+	Inputs: display, window, gc, segment list, number of segments.
+
+	Comments: Untested.
+
+\*****************************************************************/
+
+int
+XDrawSegments(display,w,gc,segs,nsegs)
+Display *display;
+Drawable w;
+GC gc;
+XSegment *segs;
+int nsegs;
+{
+	HDC hDC;
+	HPEN hpen;
+	int n;
+	HANDLE oldObj;
+	xtrace("XDrawSegments\n");
+	if (VALID_WINDOW(w))
+	{
+		hDC = drawableGetDC(w);
+		hpen = NT_get_GC_pen(hDC,gc);
+		oldObj = SelectObject(hDC,hpen);
+		SetBkMode(hDC,TRANSPARENT);
+		for (n=0;n<nsegs;n++)
+		{
+			MoveToEx(hDC,(segs+n)->x1,(segs+n)->y1,NULL);
+			LineTo(hDC,(segs+n)->x2,(segs+n)->y2);
+		}
+		SelectObject(hDC, oldObj);
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+Pixmap
+XCreatePixmap(display,drawable,width,height,depth)
+Display *display;
+Drawable drawable;
+unsigned int width, height;
+unsigned int depth;
+{
+	RECT rct;
+	NT_window *w = (NT_window *)NT_new_window();
+	HDC parenthDC = drawableGetDC(drawable);
+	w->hDC = CreateCompatibleDC(parenthDC);
+	w->hBitmap = CreateCompatibleBitmap(parenthDC,width,height);
+	SelectObject(w->hDC, w->hBitmap);
+
+	rct.left=(LONG) 0;
+	rct.right=(LONG) width;
+	rct.top=(LONG) 0;
+	rct.bottom=(LONG) height;
+	FillRect(w->hDC, &rct, GetStockObject(WHITE_BRUSH));
+
+	drawableRelDC(drawable,parenthDC);
+
+	w->w = NONMAPPED_HANDLE;
+	w->x=0;
+	w->y=0;
+	w->wdth = width;
+	w->hght = height;
+	w->min = depth;
+	return (Pixmap)w;
+}
+
+const char revBytes[]={
+	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50,
+	0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8,
+	0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04,
+	0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4,
+	0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c,
+	0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82,
+	0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32,
+	0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46,
+	0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6,
+	0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e,
+	0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1,
+	0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71,
+	0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99,
+	0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25,
+	0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d,
+	0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3,
+	0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b,
+	0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb,
+	0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67,
+	0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f,
+	0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f,
+	0xbf, 0x7f, 0xff
+};
+
+
+Pixmap
+XCreateBitmapFromData(Display *display,
+    Drawable drawable, const char *data,
+    unsigned int width, unsigned int height)
+{
+	NT_window *w = (NT_window *)NT_new_window();
+	HDC parenthDC = drawableGetDC(drawable);
+	w->hDC = CreateCompatibleDC(parenthDC);
+
+	{
+		int i,j;
+		char *newdata;
+		int bytes = (width+7)>>3;
+		int newbytes = (bytes&1)?bytes+1:bytes;
+		newdata = allocateMemory(newbytes*height);
+		for (i=0;i<height;i++)
+		{
+			for (j=0;j<bytes;j++)
+			{
+				newdata[(i*newbytes)+j]=revBytes[(unsigned char)data[(i*bytes)+j]];		
+			}
+		}
+		w->hBitmap = CreateBitmap(width,height,1,1,newdata);
+		freeMemory(newdata);
+	}
+	
+	SelectObject(w->hDC, w->hBitmap);	
+	drawableRelDC(drawable,parenthDC);
+	w->x=0;
+	w->y=0;
+	w->wdth = width;
+	w->hght = height;
+	w->min = 1;
+	return (Pixmap)w;
+}
+
+int
+XFreePixmap(display, pixmap)
+	 Display *display;
+	 Pixmap pixmap;
+{
+	NT_window *w = (NT_window *)pixmap;
+	NT_delete_window(w);
+	return 0;
+}
+
+int
+XCopyArea(display, src, dest, gc, src_x, src_y, width, height, dest_x, dest_y)
+Display *display;
+Drawable src, dest;
+GC gc;
+int src_x, src_y;
+unsigned int width, height;
+int dest_x, dest_y;
+{
+	HDC hsrc, hdst;
+	hsrc = drawableGetDC(src);
+	if (VALID_WINDOW(dest))
+	{
+		hdst = drawableGetDC(dest);
+		(void)BitBlt(hdst,dest_x,dest_y,width,height,hsrc,src_x,src_y,SRCCOPY);
+		drawableRelDC(src,hsrc);
+	}
+	drawableRelDC(dest,hdst);
+	return 0;
+}
+
+XImage *
+NT_XCreateImage()
+{
+	return NULL;
+}
+
+int NT_XDestroyImage(ximage)
+XImage *ximage;
+{
+	/* freeMemory(ximage->data); */
+  freeMemory(ximage);
+  return 1;
+}
+
+unsigned long
+NT_XGetPixel(ximage,x,y)
+XImage *ximage;
+int x,y;
+{
+	return 0;
+}
+int
+NT_XPutPixel(ximage,x,y,pixel)
+XImage *ximage;
+int x,y;
+unsigned long pixel;
+{
+	return 0;
+}
+XImage *
+NT_XSubImage(ximage,x,y,w,h)
+XImage *ximage;
+int x,y;
+unsigned int w,h;
+{
+	return NULL;
+}
+int
+NT_XAddPixel(ximage,value)
+XImage *ximage;
+unsigned long value;
+{
+	return 0;
+}
+
+XImage *
+XGetImage(display,drawable,x,y,width,height,plane_mask,format)
+Display *display;
+Drawable drawable;
+int x,y;
+unsigned int width, height;
+unsigned long plane_mask;
+int format;
+{
+	return NULL;
+}
+
+XImage *
+XCreateImage(display,visual,depth,format,offset,data,width,height, bitmap_pad, bytes_per_line)
+Display *display;
+Visual *visual;
+unsigned int depth;
+int format;
+int offset;
+char *data;
+unsigned int width, height;
+int bitmap_pad, bytes_per_line;
+{
+    XImage *img = (XImage *) allocateMemory(sizeof(XImage));
+
+    if (img) {
+		img->depth = 24; /* depth; */
+		img->format = format;
+		img->xoffset = offset;
+		img->data = data;
+		img->width = width;
+		img->height = height;
+		img->bitmap_pad = 32;
+		img->bytes_per_line=width*((24)>>3);
+		img->bits_per_pixel = 24; /* depth; */
+		img->bitmap_bit_order = LSBFirst;
+		img->byte_order = MSBFirst;
+		img->blue_mask = 0x0ff00000;
+		img->green_mask=0x00ff0000;
+		img->red_mask= 0x0000ff00;
+		
+		img->f.create_image = NT_XCreateImage;
+		img->f.destroy_image = NT_XDestroyImage;
+		img->f.get_pixel = NT_XGetPixel;
+		img->f.put_pixel = NT_XPutPixel;
+		img->f.sub_image = NT_XSubImage;
+		img->f.add_pixel = NT_XAddPixel;
+		
+    }
+	
+	return img;
+}
+void
+DrawBitmap(HDC hdc, HBITMAP hBitmap, int xStart, int yStart)
+{
+	BITMAP bm;
+	HDC hdcMem;
+	DWORD dwSize;
+	POINT ptSize, ptOrg;
+	hdcMem = CreateCompatibleDC(hdc);
+	SelectObject(hdcMem, hBitmap);
+	SetMapMode(hdcMem,GetMapMode(hdc));
+	GetObject(hBitmap, sizeof(BITMAP), (LPVOID)&bm);
+	ptSize.x = bm.bmWidth;
+	ptSize.y = bm.bmHeight;
+	DPtoLP(hdc, &ptSize,1);
+	ptOrg.x=0;
+	ptOrg.y=0;
+	DPtoLP(hdcMem,&ptOrg,1);
+	BitBlt(hdc,xStart,yStart,ptSize.x,ptSize.y,hdcMem,ptOrg.x,ptOrg.y,SRCCOPY);
+	DeleteDC(hdcMem);
+}
+/*
+static unsigned char wBrickBits[]={
+	0xff,0x0c,0x0c,0x0c, 0xff,0xc0,0xc0,0xc0,
+	0xff,0x0c,0xff,0xff, 0xff,0xff,0xc0,0xc0,
+	0xff,0x0c,0xff,0xff, 0xff,0xff,0xc0,0xc0,
+	0xff,0x0c,0x0c,0x0c, 0xff,0xc0,0xc0,0xc0
+};
+*/
+int
+XPutImage(display,w,gc,image,sx,sy,dx,dy,width,height)
+Display *display;
+Drawable w;
+XImage *image;
+GC gc;
+int sx,sy,dx,dy;
+unsigned int width,height;
+{
+	BITMAPINFO bmInfo;
+	NT_window *pix = (NT_window *)w;
+	int res;
+	if (VALID_WINDOW(w))
+	{
+		HDC hDC = drawableGetDC(w);
+		bmInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+		bmInfo.bmiHeader.biWidth = width;
+		bmInfo.bmiHeader.biHeight = height;
+		bmInfo.bmiHeader.biPlanes = 1;
+		bmInfo.bmiHeader.biBitCount = 24; /*image->depth; */
+		bmInfo.bmiHeader.biCompression = BI_RGB;
+		bmInfo.bmiHeader.biSizeImage = 0;
+		bmInfo.bmiHeader.biXPelsPerMeter = 3600;
+		bmInfo.bmiHeader.biYPelsPerMeter = 3600;
+		bmInfo.bmiHeader.biClrUsed = 0;
+		bmInfo.bmiHeader.biClrImportant = 0;
+		res = SetDIBitsToDevice(hDC,0,0,width,height,0,0,0,height,image->data,&bmInfo,DIB_RGB_COLORS);
+		/*	BitBlt(CreateDC("DISPLAY",NULL,NULL,NULL),10,0,width,height,hDC,0,0,SRCCOPY); */
+		if (res==0)
+			printf("SetDIBitsfailed %d\n",res,GetLastError());
+		drawableRelDC(w,hDC);
+	}
+	return 0;
+}
+
+int
+XSetWindowBackground(display, w, bg)
+	 Display *display;
+	 Window w;
+	 unsigned long bg;
+{
+	NT_window *window = (NT_window *)w;
+	xtrace("XSetWindowBackground\n");
+	DeleteObject(window->bg);
+	window->bg=CreateSolidBrush(CNUMTORGB(bg));
+	return 0;
+}
+
+int
+XSetWindowBackgroundPixmap(display, w, background_tile)
+Display *display;
+Window w;
+Pixmap background_tile;
+{
+	NT_window *window = (NT_window *)w;
+	NT_window *wpix = (NT_window *)background_tile;
+	BITMAPINFO *bmInfo;
+	BITMAP bm;
+	int res;
+	
+	xtrace("XSetWindowBackgroundPixmap\n");
+	if (background_tile==ParentRelative)
+	{
+	}
+	else
+	{
+		GetObject(wpix->hBitmap, sizeof(BITMAP), &bm);
+	
+		bmInfo = allocateMemory(sizeof(BITMAPINFO) + ( (bm.bmBitsPixel>>3)* bm.bmWidth*bm.bmHeight));
+		bmInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+		bmInfo->bmiHeader.biWidth = bm.bmWidth;
+		bmInfo->bmiHeader.biHeight = bm.bmHeight;
+		bmInfo->bmiHeader.biPlanes = 1;
+		bmInfo->bmiHeader.biBitCount = bm.bmBitsPixel;
+		bmInfo->bmiHeader.biCompression = BI_RGB;
+		bmInfo->bmiHeader.biSizeImage =  0;
+		bmInfo->bmiHeader.biClrImportant = 0; 
+		bmInfo->bmiHeader.biClrUsed = 0;
+	
+		res =GetDIBits(wpix->hDC,wpix->hBitmap,0,bm.bmHeight,bmInfo->bmiColors,bmInfo,DIB_RGB_COLORS);
+		if (res==0)
+			printf("getDIBits failed %d\n",res,GetLastError());
+	
+		DeleteObject(window->bg);
+		window->bg = CreateDIBPatternBrushPt(bmInfo, DIB_RGB_COLORS);
+		freeMemory(bmInfo);
+	}
+}
+
+
+/*****************************************************************\
+
+	Function: XSetFillStyle
+	Inputs:   display, gc, fill style.
+
+	Comments: ZZzzz...
+
+\*****************************************************************/
+
+int
+XSetFillStyle(display,gc,fs)
+Display *display;
+GC gc;
+int fs;
+{
+	xtrace("XSetFillStyle\n");
+	gc->values.fill_style=fs;
+	gc->dirty |= GCFillStyle;
+	return 0;
+}
+
+
+int
+XSetDashes(Display *display,
+    GC gc, int dash_offset,
+    const char * dash_list,
+    int n)
+{
+	xtrace("XSetDashes\n");
+	return 0;
+}
+
+
+int
+XChangeWindowAttributes(display,w,vmask,attr)
+Display *display;
+Window w;
+unsigned long vmask;
+XSetWindowAttributes *attr;
+{
+	xtrace("XChangeWindowAttributes\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XLowerWindow
+	Inputs:   display, window to be lowered.
+
+	Comments: Make sure if the window has a frame that that gets lowered
+		  too.
+
+\*****************************************************************/
+
+int
+XLowerWindow(display,w)
+Display *display;
+Window w;
+{
+	NT_window *ntw=(NT_window *)w;
+	xtrace("XLowerWindow\n");
+	SetWindowPos((HWND)ntw->w,HWND_BOTTOM,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XMapRaised
+	Inputs:   display, window.
+
+	Comments: Frames get raised first.
+
+\*****************************************************************/
+
+int
+XMapRaised(display,w)
+Display *display;
+Window w;
+{
+	NT_window *ntw=(NT_window *)w;
+	xtrace("XMapRaised\n");
+	XMapWindow(display,w);
+	SetWindowPos(ntw->w,HWND_TOP,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE);
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XMapSubwindows
+	Inputs:   display, window.
+
+	Comments: Unfortunately, the optimisations normally made by
+		  the X server are not made here.
+
+\*****************************************************************/
+
+int
+XMapSubwindows(display,w)
+Display *display;
+Window w;
+{
+	NT_window *ntw=(NT_window *)w;
+	struct NT_child *tmp;
+
+	xtrace("XMapSubWindows\n");
+	tmp=ntw->child;
+	while (tmp!=NULL)
+	{
+		XMapWindow(display,(Window)tmp->w);
+		tmp=tmp->next;
+        }
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XQueryTree
+	Inputs:   display, window.
+	Returned: root window, parent window, list of children, status.
+
+	Comments: Not fully implemented.  The child field is wrong.
+
+\*****************************************************************/
+
+StatusDef
+XQueryTree(display,w,root,parent,ch,n)
+Display *display;
+Window w;
+Window* root;
+Window* parent;
+Window** ch;
+unsigned int *n;
+{
+	NT_window *ntw=(NT_window *)w;
+	StatusDef status=1;
+
+	xtrace("XQueryTree\n");
+	*parent=(Window)ntw->parent;
+	if (ntw->parent==NULL)
+		status=0;
+	*root=display->screens[0].root;
+	*ch=NULL;
+	*n=0;
+	return (status);
+}
+
+
+/*****************************************************************\
+
+	Function: XRaiseWindow
+	Inputs:   display, window.
+
+	Comments: Recursive raising of window and its children.
+
+\*****************************************************************/
+
+int
+XRaiseWindow(display,w)
+Display *display;
+Window w;
+{
+	NT_window *ntw=(NT_window *)w;
+	struct NT_child *tmp;
+	xtrace("XRaiseWindows\n");
+
+	BringWindowToTop(ntw->w);
+	tmp=ntw->child;
+	while (tmp!=NULL)
+	{
+		XRaiseWindow(display,(Window)tmp->w);
+		tmp=tmp->next;
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XRootWindow
+	Inputs:   display, screen number
+	Returned: root window ID.
+
+	Comments: Info taken from display structure.
+
+\*****************************************************************/
+
+Window
+XRootWindow(display,scr)
+Display *display;
+int scr;
+{
+	xtrace("XRootWindow\n");
+	return(display->screens[0].root);
+}
+
+
+/*****************************************************************\
+
+	Function: XRootWindowOfScreen
+	Inputs:   screen pointer
+	Returned: root window ID.
+
+	Comments: ZZzzz...
+
+\*****************************************************************/
+
+Window
+XRootWindowOfScreen(scr)
+Screen *scr;
+{
+	xtrace("XRootWindowOfScreen\n");
+	return(scr->root);
+}
+
+
+/*****************************************************************\
+
+	Function: XTranslateCoordinates
+	Inputs:   display, source window, destination window, source x, y.
+	Returned: destination x, y, child window if any.
+
+	Comments: Seems to work properly.
+
+\*****************************************************************/
+
+BoolDef
+XTranslateCoordinates(display,sw,dw,sx,sy,dx,dy,ch)
+Display *display;
+Window sw,dw;
+int sx,sy,*dx,*dy;
+Window *ch;
+{
+	xtrace("XTranslateCoordinates\n");
+	return (True);
+}
+
+
+/*****************************************************************\
+
+	Function: XUnmapWindow
+	Inputs:   display, window.
+
+	Comments: Removes a window and its frame, if it has one, from the
+		  screen.
+
+\*****************************************************************/
+
+int
+XUnmapWindow(display,w)
+Display *display;
+Window w;
+{
+	NT_window *ntw=(NT_window *)w;
+	xtrace("XUnmapWindow\n");
+	ShowWindow(ntw->w,SW_HIDE);
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XCopyGC
+	Inputs:   display, source gc, values mask, destination gc.
+
+	Comments: Copies masked elements from source to destination.
+
+\*****************************************************************/
+
+int
+XCopyGC(display,sgc,vmask,dgc)
+Display *display;
+GC sgc,dgc;
+unsigned long vmask;
+{
+	xtrace("XCopyGC\n");
+	if (vmask&GCFunction)
+		dgc->values.function=sgc->values.function;
+	if (vmask&GCPlaneMask)
+		dgc->values.plane_mask=sgc->values.plane_mask;
+	if (vmask&GCForeground)
+		dgc->values.foreground=sgc->values.foreground;
+	if (vmask&GCBackground)
+		dgc->values.background=sgc->values.background;
+	if (vmask&GCLineWidth)
+		dgc->values.line_width=sgc->values.line_width;
+	if (vmask&GCLineStyle)
+		dgc->values.line_style=sgc->values.line_style;
+	if (vmask&GCCapStyle)
+		dgc->values.cap_style=sgc->values.cap_style;
+	if (vmask&GCJoinStyle)
+		dgc->values.join_style=sgc->values.join_style;
+	if (vmask&GCFillStyle)
+		dgc->values.fill_style=sgc->values.fill_style;
+	if (vmask&GCFillRule)
+		dgc->values.fill_rule=sgc->values.fill_rule;
+	if (vmask&GCTile)
+		dgc->values.tile=sgc->values.tile;
+	if (vmask&GCStipple)
+		dgc->values.stipple=sgc->values.stipple;
+	if (vmask&GCTileStipXOrigin)
+		dgc->values.ts_x_origin=sgc->values.ts_x_origin;
+	if (vmask&GCTileStipYOrigin)
+		dgc->values.ts_y_origin=sgc->values.ts_y_origin;
+	if (vmask&GCFont)
+		dgc->values.font=sgc->values.font;
+	if (vmask&GCSubwindowMode)
+		dgc->values.subwindow_mode=sgc->values.subwindow_mode;
+	if (vmask&GCGraphicsExposures)
+		dgc->values.graphics_exposures=sgc->values.graphics_exposures;
+	if (vmask&GCClipXOrigin)
+		dgc->values.clip_x_origin=sgc->values.clip_x_origin;
+	if (vmask&GCClipYOrigin)
+		dgc->values.clip_y_origin=sgc->values.clip_y_origin;
+	if (vmask&GCClipMask)
+		dgc->values.clip_mask=sgc->values.clip_mask;
+	if (vmask&GCDashList)
+		dgc->values.dashes=sgc->values.dashes;
+	if (vmask&GCArcMode)
+		dgc->values.arc_mode=sgc->values.arc_mode;
+
+	dgc->dirty = 0xFFFF;
+	return 0;
+}
+
+
+int
+XSetClipMask(display,gc,cmask)
+Display *display;
+GC gc;
+Pixmap cmask;
+{
+	xtrace("XSetClipMask\n");
+	return 0;
+}
+
+
+int
+XSetClipRectangles(display,gc,clx,cly,rs,n,order)
+Display *display;
+GC gc;
+int clx,cly;
+XRectangle *rs;
+int n,order;
+{
+	xtrace("XSetClipRectangles\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XSetFunction
+	Inputs:   display, gc, graphics operation.
+
+	Comments: ZZzzz...
+
+\*****************************************************************/
+
+int
+XSetFunction(display,gc,fn)
+Display *display;
+GC gc;
+int fn;
+{
+	xtrace("XSetFunction\n");
+	gc->values.function=fn;
+	gc->dirty |= GCFunction;
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XSetLineAttributes
+	Inputs:   display, gc, line width, line style, cap style, join style.
+
+	Comments: These all have windows equivalents.
+
+\*****************************************************************/
+
+int
+XSetLineAttributes(display,gc,lw,ls,cs,js)
+Display *display;
+GC gc;
+unsigned int lw;
+int ls,cs,js;
+{
+	xtrace("XSetLineAttributes\n");
+	gc->values.line_width=lw;
+	gc->values.line_style=ls;
+	gc->values.cap_style=cs;
+	gc->values.join_style=js;
+	gc->dirty |= GCLineWidth | GCLineStyle | GCCapStyle | GCJoinStyle;
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XSetPlaneMask
+	Inputs:   display, gc, plane mask.
+
+	Comments: What's a plane mask?
+
+\*****************************************************************/
+
+int
+XSetPlaneMask(display,gc,pmask)
+Display *display;
+GC gc;
+unsigned long pmask;
+{
+	xtrace("XSetPlaneMask\n");
+	gc->values.plane_mask=pmask;
+	return 0;
+}
+
+
+int
+XSetTile(display,gc,tile)
+Display *display;
+GC gc;
+Pixmap tile;
+{
+	xtrace("XSetTile\n");
+	return 0;
+}
+
+
+StatusDef
+XAllocColorCells(display,cmap,cont,pmasks,np,pixels,nc)
+Display *display;
+Colormap cmap;
+BoolDef cont;
+unsigned long *pmasks;
+unsigned int np;
+unsigned long *pixels;
+unsigned int nc;
+{
+	unsigned int i;
+	xtrace("XAllocColorCells\n");
+	for (i = 0;i<nc;i++)
+		pixels[i] = i;
+	if(np==1)
+	{
+		*pmasks = nc;
+	}
+	return 1;
+}
+
+
+/*****************************************************************\
+
+	Function: XAllocColorPlanes
+	Inputs:   display, colour map, contiguous flag, pixel value list,
+		  number of colours, number of reds, greens, blues.
+	Returned: red mask, green mask, blue mask, status.
+
+	Comments: Works for True Colour only.
+
+\*****************************************************************/
+
+StatusDef
+XAllocColorPlanes(display,cmap,cont,pixels,nc,nr,ng,nb,rmask,gmask,bmask)
+Display *display;
+Colormap cmap;
+BoolDef cont;
+unsigned long *pixels;
+int nc;
+int nr,ng,nb;
+unsigned long *rmask,*gmask,*bmask;
+{
+	xtrace("XAllocColorPlanes\n");
+	*rmask=255;
+	*gmask=255<<8;
+	*bmask=255<<16;
+	return (1);
+}
+
+
+StatusDef
+XAllocNamedColor(Display *display,
+    Colormap cmap, const char *cname,
+    XColor *cell, XColor *rgb)
+{
+	xtrace("XAllocNamedColor\n");
+	return 0;
+}
+
+
+Colormap
+XCreateColormap(display,w,visual,alloc)
+Display *display;
+Window w;
+Visual *visual;
+int alloc;
+{
+	xtrace("XCreateColormap\n");
+	return 0;
+}
+
+
+StatusDef
+XGetStandardColormap(display,w,cmapinf,prop)
+Display *display;
+Window w;
+XStandardColormap *cmapinf;
+Atom prop;
+{
+	xtrace("XGetStandardColormap\n");
+	return 0;
+}
+
+StatusDef
+XAllocColor(display,cmap,xc)
+Display *display;
+Colormap cmap;
+XColor *xc;
+{
+	xtrace("XAllocColor\n");
+	xc->pixel = RGB((BYTE) (xc->red>>8)&0xff, (BYTE) (xc->green>>8)&0xff, (BYTE) (xc->blue>>8)&0xff);
+	return 1;
+}
+
+int
+XQueryColor(display,cmap,cell)
+Display *display;
+Colormap cmap;
+XColor *cell;
+{
+	xtrace("XQueryColor\n");
+	cell->red = (cell->pixel>>8)&0x0ff00;
+	cell->green = (cell->pixel)&0x0ff00;
+	cell->blue = (cell->pixel<<8)&0x0ff00;
+  return 1;
+}
+
+
+int
+XQueryColors(display,cmap,cells,nc)
+Display *display;
+Colormap cmap;
+XColor *cells;
+int nc;
+{
+	int i;
+
+	xtrace("XQueryColors\n");
+	for (i=0;i<nc;i++)
+	{
+		cells[i].red=(cells[i].pixel>>8)&0xff00;
+		cells[i].green=(cells[i].pixel)&0xff00;
+		cells[i].blue=(cells[i].pixel<<8)&0xff00;
+	}
+	return 0;
+}
+
+
+int
+XStoreColor(display,cmap,cell)
+Display *display;
+Colormap cmap;
+XColor *cell;
+{
+	xtrace("XStoreColor\n");
+	return 0;
+}
+
+
+
+int
+XStoreColors(display,cmap,cells,nc)
+Display *display;
+Colormap cmap;
+XColor *cells;
+int nc;
+{
+	int i;
+	xtrace("XStoreColors\n");
+	return 0;
+}
+
+char **
+XGetFontPath(display,nps)
+Display *display;
+int *nps;
+{
+	xtrace("XGetFontPath\n");
+	return (NULL);
+}
+
+
+BoolDef
+XGetFontProperty(fstruct,atom,val)
+XFontStruct *fstruct;
+Atom atom;
+unsigned long *val;
+{
+	xtrace("XGetFontProperty\n");
+	return (0);
+}
+
+/* attempts to translate the font name into
+** something win32 understands.
+** 
+*/
+Font
+NT_loadfont(name)
+char *name;
+{
+	LOGFONT lf;
+	HFONT hfont;
+	char *p,*q;
+	int size = 0;
+	char buff[33];
+	
+	memset(&lf,0,sizeof(lf));
+	lf.lfHeight = -13;
+	
+	lf.lfWeight = FW_NORMAL;
+	lf.lfFaceName[0]='\0';
+	
+	if (name && strstr(name,"-bold"))
+	{
+	    lf.lfWeight = FW_BOLD;
+	}
+	for(p=name, q=buff; p; p++)
+	{
+		if (((!*p || *p=='-') && q!=buff) || (q-buff>31))
+		{
+			*q++='\0';
+			if (lf.lfFaceName[0]=='\0')
+			{
+				if (isalpha(buff[0]))
+					strcpy(lf.lfFaceName, buff);
+				else if (isdigit(buff[0]) && ((q=strchr(buff,'x')) || (q=strchr(buff,'X'))))
+				{
+					strcpy(lf.lfFaceName, "Courier New");
+					size = -atoi(q+1);
+				}
+			}
+			else if (size == 0 && isdigit(buff[0]))
+			{				
+				size = -atoi(buff);
+			}
+			q = buff;
+		}
+		else
+			*q++ = *p;
+		if (!*p) break;
+	}
+	
+	if (size > 99)
+		lf.lfHeight = - (size/10);
+	else if (size)
+		lf.lfHeight = - size;
+		
+	if (!strcmp(lf.lfFaceName,"lucidatypewriter"))
+		strcpy(lf.lfFaceName,"Lucida Console");
+	else if (lf.lfFaceName[0]=='\0')
+		strcpy(lf.lfFaceName,"Courier New");
+	
+	hfont = CreateFontIndirect(&lf);
+	return (Font)hfont;
+}
+
+XFontStruct *
+XLoadQueryFont(Display *display, const char *name)
+{
+	XFontStruct *fs;
+	TEXTMETRIC tm;
+	HDC hdc;
+	HWND root;
+	HFONT old;
+	int i;
+	
+	xtrace("XLoadQueryFont\n");
+	fs = allocateMemory(sizeof(XFontStruct));
+	fs->fid = NT_loadfont(name);
+
+	root=GetDesktopWindow();
+	hdc=GetDC(root);
+	old = SelectObject(hdc, (HFONT)fs->fid);
+	GetTextMetrics(hdc, &tm);
+	SelectObject(hdc,old);
+	ReleaseDC(root,hdc);
+	fs->min_bounds.width = tm.tmAveCharWidth;
+	fs->max_bounds.width = tm.tmMaxCharWidth;
+	fs->n_properties = 0;
+	fs->properties = NULL;
+	fs->min_char_or_byte2 =tm.tmFirstChar;
+	fs->max_char_or_byte2 =tm.tmLastChar;
+	fs->per_char = (XCharStruct*)allocateMemory(sizeof(XCharStruct)*tm.tmLastChar);
+	ZeroMemory(fs->per_char, sizeof(XCharStruct)*tm.tmLastChar);
+	for (i=tm.tmFirstChar; i<tm.tmLastChar; i++) {
+		SIZE size;
+		char buff[2];
+		buff[0]=i;
+		buff[1]='\0';
+		if (0&&GetTextExtentPoint32(hdc,buff,1,&size))
+		{
+			fs->per_char[i].width = size.cx;
+			fs->per_char[i].rbearing = fs->per_char[i].width;
+		}
+		else
+		{
+			fs->per_char[i].width = tm.tmAveCharWidth;
+			fs->per_char[i].rbearing = tm.tmAveCharWidth;
+		}
+	}
+	fs->ascent = tm.tmAscent;
+	fs->descent= tm.tmDescent;
+	return(fs);
+}
+
+XFontStruct *
+XQueryFont(display, font_id)
+Display *display;
+XID     font_id;
+{
+	static XFontStruct fs;
+
+	xtrace("XQueryFont\n");
+	return(&fs);
+}
+
+KeySym
+XKeycodeToKeysym(display, keycode, index)
+Display *display;
+unsigned int keycode;
+int     index;
+{
+	xtrace("XKeycodeToKeysym\n");
+	if (keycode == 254) return XK_Alt_L;
+	else if (keycode == 255) return XK_Num_Lock;
+	return(NoSymbol);
+}
+KeyCode
+XKeysymToKeycode(display, keysym)
+Display *display;
+KeySym keysym;
+{
+	xtrace("XKeycodeToKeysym\n");
+	if (keysym == XK_Alt_L) return 254;
+	else if (keysym == XK_Num_Lock) return 255;
+	return(0);
+}
+KeySym
+XStringToKeysym(const char *str)
+{
+	xtrace("XStringToKeysym\n");
+	return(NoSymbol);
+}
+
+XModifierKeymap *
+XGetModifierMapping(display)
+Display *display;
+{
+	XModifierKeymap *map = NULL;
+	xtrace("XGetModifierMapping\n");
+	map = (XModifierKeymap *)allocateMemory(sizeof(XModifierKeymap));
+	map->max_keypermod = 1;
+	map->modifiermap = (KeyCode *)allocateMemory(sizeof(KeyCode)*8);
+	map->modifiermap[0]=0;
+	map->modifiermap[1]=0;
+	map->modifiermap[2]=0;
+	map->modifiermap[3]=XKeysymToKeycode(display,XK_Alt_L);
+	map->modifiermap[4]=0;
+	map->modifiermap[5]=0;
+	map->modifiermap[6]=0;
+	map->modifiermap[7]=XKeysymToKeycode(display,XK_Num_Lock);
+	return(map);
+}
+int
+XFreeModifiermap(XModifierKeymap *modmap)
+{
+	xtrace("XFreeModifiermap\n");
+	freeMemory(modmap->modifiermap);
+	freeMemory(modmap);
+	return 0;
+}
+
+
+int
+XSetFont(display,gc,font)
+Display *display;
+GC gc;
+Font font;
+{
+	xtrace("XSetFont\n");
+	gc->values.font = font;
+	return 0;
+}
+
+
+int
+XSetFontPath(display,dirs,nd)
+Display *display;
+char **dirs;
+int nd;
+{
+	xtrace("XSetFontPath\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+	Function: XTextExtents
+	Inputs:   font structure, string, string length.
+	Returned: writing direction, max ascent, max descent, font overall
+		  characteristics.
+
+	Comments: The design of windows fonts is similar to X, as far as
+		  ascent and descent are concerned.  However, they are
+		  positioned differently on the screen (see XDrawText).
+
+\*****************************************************************/
+
+static HDC desktopHDC;
+static int firstTE = TRUE;
+int
+XTextExtents(fstruct,str,nc,dir,ascent,descent,overall)
+XFontStruct *fstruct;
+const char *str;
+int nc;
+int *dir,*ascent,*descent;
+XCharStruct *overall;
+{
+	TEXTMETRIC tmet;
+	HDC hdc;
+	SIZE tsize;
+	HWND desktop;
+	HFONT old;
+	
+	xtrace("XTextExtents\n");
+	if (firstTE)
+	{
+		firstTE = FALSE;
+		desktop=GetDesktopWindow();
+		desktopHDC=GetDC(desktop);
+	}
+	hdc = desktopHDC;
+	old = SelectObject(hdc, (HFONT)fstruct->fid);
+	GetTextMetrics(hdc,&tmet);
+	GetTextExtentPoint(hdc,str,nc,&tsize);
+	*dir=FontLeftToRight;
+	*ascent=tmet.tmAscent + 1;
+	*descent=tmet.tmDescent;
+	overall->ascent=(short)(tmet.tmAscent + 1);
+	overall->descent=(short)tmet.tmDescent;
+	overall->width=(short)tsize.cx;
+	overall->lbearing=0;
+	overall->rbearing=(short)tsize.cx;
+	/* cjh_rel_dc(desktop,hdc);*/
+	SelectObject(hdc,old);
+	return 0;
+}
+
+
+int
+XTextExtents16(fstruct,str,nc,dir,ascent,descent,overall)
+XFontStruct *fstruct;
+const XChar2b *str;
+int nc;
+int *dir,*ascent,*descent;
+XCharStruct *overall;
+{
+	xtrace("XTextExtents16\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XTextWidth
+	Inputs:   font structure, string, length of string.
+	Returned: String width in pixels.
+
+	Comments:
+
+\*****************************************************************/
+
+int
+XTextWidth(fstruct,str,co)
+XFontStruct *fstruct;
+const char *str;
+int co;
+{
+	HDC hdc;
+	SIZE tsize;
+	HWND root;
+	HFONT old;
+	xtrace("XTextWidth\n");
+
+	if(firstTE)
+	{
+		firstTE = FALSE;
+		root=GetDesktopWindow();
+		hdc=GetDC(root);
+	}
+	old = SelectObject(hdc, (HFONT)fstruct->fid);
+	GetTextExtentPoint(hdc,str,co,&tsize);
+	SelectObject(hdc,old);
+	/*cjh_rel_dc(root,hdc);*/
+	return (tsize.cx);
+}
+
+
+int
+XTextWidth16(fstruct,str,co)
+XFontStruct *fstruct;
+const XChar2b *str;
+int co;
+{
+	xtrace("XTextWidth16\n");
+	return 0;
+}
+
+
+int
+XGetErrorDatabaseText(display,name,msg,defstr,buf,len)
+Display *display;
+const char *name,*msg;
+const char *defstr;
+char *buf;
+int len;
+{
+	static char def_err[]="Errors not implemented";
+	int n;
+
+	xtrace("XGetErrorDatabaseText\n");
+	while (n<len && def_err[n] != 0)
+		*(buf+n)=def_err[n++];
+	*(buf+n)=0;
+	return 0;
+}
+
+
+int
+XGetErrorText(display,code,buf,len)
+Display *display;
+int code;
+char *buf;
+int len;
+{
+	xtrace("XGetErrorText\n");
+	return 0;
+}
+
+
+XErrorHandler
+XSetErrorHandler(handler)
+XErrorHandler handler;
+{
+	xtrace("XSetErrorHandler\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XDefaultScreen
+	Inputs:   display
+	Returned: default screen number
+
+	Comments:
+
+\*****************************************************************/
+
+int
+XDefaultScreen(display)
+Display *display;
+{
+	xtrace("XDefaultScreen\n");
+	return (display->default_screen);
+}
+
+Visual *
+XDefaultVisual(display, screen)
+Display *display;
+int screen;
+{
+	xtrace("XDefaultVisual\n");
+	return DefaultVisual(display, screen);
+}
+int
+XDefaultDepth(display, screen)
+Display *display;
+int screen;
+{
+	xtrace("XDefaultDepth\n");
+	return DefaultDepth(display, screen);
+}
+Colormap
+XDefaultColormap(display, screen)
+Display *display;
+int screen;
+{
+	xtrace("XDefaultColormap\n");
+	return DefaultColormap(display, screen);
+}
+
+
+/*****************************************************************\
+
+
+	Function: XScreenOfDisplay
+	Inputs:   display,screen number
+	Returned: screen list.
+
+	Comments:
+
+\*****************************************************************/
+
+Screen *
+XScreenOfDisplay(display,scr)
+Display *display;
+int scr;
+{
+	xtrace("XScreenOfDisplay\n");
+	return (display->screens);
+}
+
+
+Cursor
+XCreateFontCursor(display,shape)
+Display *display;
+unsigned int shape;
+{
+	xtrace("XCreateFontCursor\n");
+	return 0;
+}
+
+
+int
+XRecolorCursor(display,cursor,fg,bg)
+Display *display;
+Cursor cursor;
+XColor *fg,*bg;
+{
+	xtrace("XRecolorCursor\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XWarpPointer
+	Inputs:   display, source window, destination window, source window
+		  geometry, destination x, y.
+
+	Comments: Not knowingly tested.
+
+\*****************************************************************/
+
+int
+XWarpPointer(display,sw,dw,sx,sy,swidth,sheight,dx,dy)
+Display *display;
+Window sw,dw;
+int sx,sy;
+unsigned int swidth,sheight;
+int dx,dy;
+{
+	NT_window *ntsw=(NT_window *)sw;
+	NT_window *ntdw=(NT_window *)dw;
+
+	POINT cpt,tmp;
+	RECT srct;
+	HDC hDC;
+
+	xtrace("XWarpPointer\n");
+	GetCursorPos(&cpt);
+	if (ntsw==None)
+	{
+		if (ntdw==None)
+			SetCursorPos(dx,dy);
+		else
+		{
+			tmp.x=dx;
+			tmp.y=dy;
+			ClientToScreen(ntdw->w,&tmp);
+			SetCursorPos(tmp.x,tmp.y);
+		}
+	}
+	else
+	{
+		GetWindowRect(ntsw->w,&srct);
+		tmp.x=sx;
+		tmp.y=sy;
+		ClientToScreen(ntsw->w,&tmp);
+		if (swidth==0)
+			swidth=srct.right-sx;
+		if (sheight==0)
+			sheight=srct.bottom-sy;
+		hDC = cjh_get_dc(ntdw);
+		if (cpt.x>=tmp.x && cpt.x<tmp.x+(int)swidth &&
+		    cpt.y>=tmp.y && cpt.y<tmp.y+(int)sheight &&
+		    PtVisible(hDC,cpt.x,cpt.y))
+		{
+			if (ntdw==None)
+				SetCursorPos(cpt.x+dx,cpt.y+dy);
+			else
+			{
+				tmp.x=dx;
+				tmp.y=dy;
+				ClientToScreen(ntdw->w,&tmp);
+				SetCursorPos(tmp.x,tmp.y);
+			}
+		}
+		cjh_rel_dc(ntdw,hDC);
+	}
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XBell
+	Inputs:   display, percent loudness.
+
+	Comments: Don't throw away your CD just yet.
+
+\*****************************************************************/
+
+int
+XBell(display,pc)
+Display *display;
+int pc;
+{
+	xtrace("XBell\n");
+	Beep(20,40);
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XGetInputFocus
+	Inputs:   display, focus window, revert to window.
+
+	Comments: We don't have the data in place for the revert to field
+		  to work.
+
+\*****************************************************************/
+
+int
+XGetInputFocus(display,focus,revto)
+Display *display;
+Window *focus;
+int *revto;
+{
+	xtrace("XGetInputFocus\n");
+	*focus=(Window)GetFocus();  /* Note: returns NULL if the focus window */
+	revto=RevertToNone; /*       belongs to another thread.       */
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XSetInputFocus
+	Inputs:   display, focus window, revert to window, time.
+
+	Comments: Set focus to requested client window.
+
+\*****************************************************************/
+
+int
+XSetInputFocus(display,focus,revto,time)
+Display *display;
+Window focus;
+int revto;
+Time time;
+{
+	NT_window *ntw=(NT_window *)focus;
+	xtrace("XSetInputFocus\n");
+	SetFocus(ntw->w);
+	return 0;
+}
+
+
+int
+XLookupString(event,buf,nbytes,keysym,status)
+XKeyEvent *event;
+char *buf;
+int nbytes;
+KeySym *keysym;
+XComposeStatus *status;
+{
+	xtrace("XLookupString\n");
+	*buf=event->keycode;
+	*keysym=event->keycode;
+	return (1);
+}
+
+
+int
+XRefreshKeyboardMapping(event)
+XMappingEvent *event;
+{
+	xtrace("XRefreshKeyboardMapping\n");
+	return 0;
+}
+
+
+int
+XSetClassHint(display,w,chints)
+Display *display;
+Window w;
+XClassHint *chints;
+{
+	xtrace("XSetClassHint\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XSetNormalHints
+	Inputs:   display, window, size hints.
+
+	Comments: Assuming the role of the window manager, we alter the
+		  window geometry as requested.
+
+\*****************************************************************/
+
+int
+XSetNormalHints(display,w,hints)
+Display *display;
+Window w;
+XSizeHints *hints;
+{
+	NT_window *ntw=(NT_window *)w;
+	UINT ff;
+
+	xtrace("XSetNormalHints\n");
+	if (!hints->flags&PPosition)
+		ff=SWP_NOMOVE;
+	else
+		ff=0;
+	
+	if (!hints->flags&PSize)
+		ff=ff|SWP_NOSIZE;
+
+	if (hints->flags &USPosition)
+	{
+		ntw->x = hints->x;
+		ntw->y = hints->y;
+	}
+	if (hints->flags & USSize)
+	{
+		ntw->wdth = hints->width;
+		ntw->hght = hints->height;
+	}
+	
+	if (hints->flags&PMinSize)
+	{
+		ntw->minx = hints->min_width;
+		ntw->miny = hints->min_height;
+	}
+	
+	if (VALID_WINDOW(ntw))
+	{
+		SetWindowPos(ntw->w,HWND_TOPMOST,hints->x,hints->y,
+					 hints->width,hints->height,ff|SWP_SHOWWINDOW);
+	}
+	return 0;
+}
+
+
+int
+XSetWMHints(display,w,wmhints)
+Display *display;
+Window w;
+XWMHints *wmhints;
+{
+	xtrace("XSetWMHints\n");
+	return 0;
+}
+
+
+StatusDef
+XSetWMProtocols(display,w,prots,co)
+Display *display;
+Window w;
+Atom *prots;
+int co;
+{
+	xtrace("XSetWMProtocols\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XStoreName
+	Inputs:   display, window, window name.
+
+	Comments: Only set names to the frame windows, otherwise captions
+		  appear in the client areas.
+
+\*****************************************************************/
+
+int
+XStoreName(display,w,wname)
+Display *display;
+Window w;
+const char *wname;
+{
+	NT_window *ntw=(NT_window *)w;
+	int status = 0;
+
+	xtrace("XStoreName\n");
+	if (ntw->top_flag)
+	{
+		ntw->title_text = strdup(wname);
+		if (VALID_WINDOW(ntw))
+			status = SetWindowText (ntw->w , wname);
+	}
+	return(status);
+}
+
+StatusDef
+XFetchName(
+    Display *display,
+    Window w,
+    char **window_name_return)
+{
+	NT_window *ntw=(NT_window *)w;
+	int status = 1;
+	xtrace("XFetchName\n");
+	*window_name_return = NULL;
+	if (ntw->title_text!=NULL)
+	{
+		*window_name_return = strdup(ntw->title_text);
+		status =0;
+	}
+	return(status);
+}
+
+
+
+/*****************************************************************\
+
+
+	Function: XDoesBackingStore
+	Inputs:   screen
+
+	Comments: No backing store at the moment.  Windows doesn't seem
+		  to support it, unless we do it ourselves with compatible
+		  bitmaps.
+
+\*****************************************************************/
+
+int
+XDoesBackingStore(scr)
+Screen *scr;
+{
+	xtrace("XDoesBackingStore\n");
+	return(0);
+}
+
+
+XExtCodes *
+XInitExtension(display,name)
+Display *display;
+const char *name;
+{
+	xtrace("XInitExtension\n");
+	return 0;
+}
+
+
+/*****************************************************************\
+
+
+	Function: XFree
+	Inputs:   data to be freed.
+
+	Comments: This might need changing sometime.  No crashes so far.
+
+\*****************************************************************/
+
+int
+XFree(data)
+void *data;
+{
+	xtrace("XFree\n");
+	freeMemory(data);
+	return 0;
+}
+
+/*****************************************************************\
+
+
+	Function: XServerVendor
+	Inputs:   display.
+	Returned: string of vendor's name.
+
+	Comments: Copied from the display structure.
+
+\*****************************************************************/
+
+char *
+XServerVendor(display)
+Display *display;
+{
+	xtrace("XServerVendor\n");
+	return (display->vendor);
+}
+
+
+int
+XSetIconName(display,w,iname)
+Display *display;
+Window w;
+const char *iname;
+{
+	xtrace("XSetIconName\n");
+	return 0;
+}
+int
+XGetIconName(display,w,iname)
+Display *display;
+Window w;
+char **iname;
+{
+	xtrace("XGetIconName\n");
+	*iname = NULL;
+	return 0;
+}
+
+
+int
+XSetSelectionOwner(display, sel, owner, time)
+Display* display;
+Atom sel;
+Window owner;
+Time time;
+{
+    HWND hwnd = owner ? ((NT_window*)owner)->w : NULL;
+	HWND cowner = GetClipboardOwner();
+	OpenClipboard(hwnd);
+	if (cowner==hwnd)
+		catchNextDestroyClipboard();
+	EmptyClipboard();
+	CloseClipboard();
+	return 0;
+}
+
+Window
+XGetSelectionOwner(display,selection)
+Display* display;
+Atom selection;
+{
+	HWND hwnd = NULL;
+	xtrace("XGetSelectionOwner\n");
+	hwnd = GetClipboardOwner();
+	return (Window)NT_find_window_from_id(hwnd);
+}
+
+int
+XConvertSelection(display,sel,target,prop,req,time)
+Display *display;
+Atom sel,target,prop;
+Window req;
+Time time;
+{
+	xtrace("XConvertSelection\n");
+	return 0;
+}
+
+/*****************************************************************\
+
+	Function: NT_set_rop
+	Inputs:   window device context, X graphics context
+
+	Comments: Sets the graphics drawing operation.
+
+\*****************************************************************/
+
+void
+NT_set_rop(hdc,gc)
+HDC hdc;
+GC gc;
+{
+	switch (gc->values.function)
+	{
+		case GXclear:
+			SetROP2(hdc,R2_BLACK);
+			break;
+
+		case GXand:
+			SetROP2(hdc,R2_MASKPEN);
+			break;
+
+		case GXandReverse:
+			SetROP2(hdc,R2_MASKPENNOT);
+			break;
+
+		case GXcopy:
+			SetROP2(hdc,R2_COPYPEN);
+			break;
+
+		case GXnoop:
+			SetROP2(hdc,R2_NOP);
+			break;
+
+		case GXxor:
+			SetROP2(hdc,R2_XORPEN);/*XORPEN);*/
+			break;
+
+		case GXor:
+			SetROP2(hdc,R2_MERGEPEN);
+			break;
+
+		case GXnor:
+			SetROP2(hdc,R2_NOTMERGEPEN);
+			break;
+
+		case GXequiv:
+			SetROP2(hdc,R2_NOTXORPEN);
+			break;
+
+		case GXinvert:
+			SetROP2(hdc,R2_NOT);
+			break;
+
+		case GXorReverse:
+			SetROP2(hdc,R2_MERGEPENNOT);
+			break;
+
+		case GXcopyInverted:
+			SetROP2(hdc,R2_NOTCOPYPEN);
+			break;
+
+		case GXorInverted:
+			SetROP2(hdc,R2_MERGENOTPEN);
+			break;
+
+		case GXnand:
+			SetROP2(hdc,R2_NOTMASKPEN);
+			break;
+
+		case GXset:
+			SetROP2(hdc,R2_WHITE);
+			break;
+	}
+}
+
+/*****************************************************************\
+
+	Function: NT_check_update_GC
+	Inputs:   gc - Graphics Context
+
+	Comments: Check what has changed in the GC and modify the
+		  pen and brush accordingly.
+
+\*****************************************************************/
+static int
+NT_check_update_GC(gc)
+GC gc;
+{
+	DWORD style=PS_GEOMETRIC;
+	LOGBRUSH lbr;
+	int	 width;
+	NTGC	*lntgc;
+
+	if ( gc->ext_data == NULL )
+	{
+		gc->ext_data = (XExtData *)allocateMemory(sizeof(XExtData));
+		lntgc = (NTGC *)allocateMemory(sizeof(NTGC));
+		gc->ext_data->private_data = (char *)lntgc;
+		lntgc->pen = INVALID_HANDLE;
+		lntgc->brush = INVALID_HANDLE;
+		gc->dirty=~0;
+	}
+
+	if ((gc->dirty & GCForeground) ||
+		 (gc->dirty & GCLineStyle)  ||
+	     (gc->dirty & GCCapStyle)   ||
+	     (gc->dirty & GCJoinStyle)  ||
+	     (gc->dirty & GCLineWidth) )
+	{
+		lbr.lbStyle=BS_SOLID;
+		lbr.lbColor=CNUMTORGB(gc->values.foreground);
+		lbr.lbHatch=0;
+
+		if (gc->values.line_style==LineDoubleDash)
+			style|=PS_DASHDOT;
+		else if (gc->values.line_style==LineOnOffDash)
+			style|=PS_DASH;
+		else
+			style|=PS_SOLID;
+
+		if (gc->values.cap_style==CapProjecting)
+			style|=PS_ENDCAP_SQUARE;
+		else if (gc->values.cap_style==CapRound)
+			style|=PS_ENDCAP_ROUND;
+		else
+			style|=PS_ENDCAP_FLAT;
+
+		if (gc->values.join_style==JoinRound)
+			style|=PS_JOIN_ROUND;
+		else if (gc->values.join_style==JoinMiter)
+			style|=PS_JOIN_MITER;
+		else
+			style|=PS_JOIN_BEVEL;
+		width=gc->values.line_width;
+		if (width==0)
+			width=1;
+
+		lntgc = (NTGC *)gc->ext_data->private_data;
+		if ( lntgc->pen != INVALID_HANDLE )
+			DeleteObject(lntgc->pen);
+
+		lntgc->pen = ExtCreatePen(style,width,&lbr,0,NULL);
+	}
+	if (gc->values.fill_style != FillSolid)
+	{
+		if ((gc->dirty & GCStipple))
+		{
+			NT_window *pixmap = (NT_window *)gc->values.stipple;
+			lntgc->brush = CreatePatternBrush(pixmap->hBitmap);
+		}
+	}
+	else if ((gc->dirty & GCForeground) )
+	{
+		lntgc = (NTGC *)gc->ext_data->private_data;
+		if ( lntgc->brush != INVALID_HANDLE )
+			DeleteObject(lntgc->brush);
+		lntgc->brush = CreateSolidBrush(CNUMTORGB(gc->values.foreground));
+
+	}
+
+	gc->dirty = 0;
+
+	return(1);
+}
+
+
+/*****************************************************************\
+
+	Function: NT_get_GC_pen
+	Inputs:   device context, graphics context
+
+	Comments: Sets the device context and pen according to the
+		  graphics context.
+
+\*****************************************************************/
+static HPEN
+NT_get_GC_pen(hdc,gc)
+HDC hdc;
+GC gc;
+{
+	NTGC *lntgc;
+
+	NT_check_update_GC(gc);
+	NT_set_rop(hdc,gc);
+
+	lntgc = (NTGC *)gc->ext_data->private_data;
+
+	return(lntgc->pen);
+}
+
+
+/*****************************************************************\
+
+	Function: NT_get_GC_brush
+	Inputs:   device context, graphics context
+	Returns:  handle for brush.
+
+	Comments: Same as above for painting operations.
+
+\*****************************************************************/
+static HBRUSH
+NT_get_GC_brush(hdc,gc)
+HDC hdc;
+GC gc;
+{
+	NTGC *lntgc;
+
+        NT_check_update_GC(gc);
+
+	if (gc->values.fill_rule==EvenOddRule)
+		SetPolyFillMode(hdc,ALTERNATE);
+	else
+		SetPolyFillMode(hdc,WINDING);
+	
+	if (gc->values.fill_style == FillSolid)
+	{
+		SetTextColor(hdc, CNUMTORGB(gc->values.foreground));
+		SetBkColor(hdc, CNUMTORGB(gc->values.background));
+	}
+	
+	NT_set_rop(hdc,gc);
+
+	lntgc = (NTGC *)gc->ext_data->private_data;
+
+	return(lntgc->brush);
+}
+
+
+/*****************************************************************\
+
+	Function: NT_deg64_to_rad
+	Inputs:   angle (in 64ths of a degree)
+
+	Comments: Converts int angle to double in radians.
+
+\*****************************************************************/
+
+double
+NT_deg64_to_rad(a)
+int a;
+{
+	return ((double)a/64.0*0.017453);
+}
+
+
+/******************************************************************/
+/*                                                                */
+/*               Atoms and properties code.                       */
+/*                                                                */
+/******************************************************************/
+
+static char **nt_atoms;
+static int num_nt_atoms = 0;
+static int max_num_nt_atoms = 0;
+#define ATOMS_BLOCK_SIZE 40
+
+/******************************************************************\
+
+         Function:  XInternAtom
+         Inputs:    Display, property name, creation flag.
+
+         Comments:  Could be made much more efficient.
+
+\******************************************************************/
+
+Atom
+XInternAtom(display, property_name, only_if_exists)
+Display *display;
+const char *property_name;
+BoolDef only_if_exists;
+{
+	int i;
+	char **new_nt_atoms;
+
+	xtrace("XInternAtom\n");
+	if (strcmp(property_name,"VT_SELECTION")==0)
+	{
+		return XA_LAST_PREDEFINED + 667;
+	}
+	
+	for (i=0;i< num_nt_atoms ;i++)
+		if (strcmp(nt_atoms[i],property_name) == 0)
+			return XA_LAST_PREDEFINED + i;
+	
+	if (only_if_exists)
+		return None;
+
+	if (num_nt_atoms >= max_num_nt_atoms)
+	{
+		new_nt_atoms = (char **)realloc(nt_atoms,(max_num_nt_atoms + ATOMS_BLOCK_SIZE)*sizeof(char *));
+		if (!new_nt_atoms)
+			return None;
+		nt_atoms = new_nt_atoms;
+		max_num_nt_atoms+= ATOMS_BLOCK_SIZE;
+		nt_atoms[num_nt_atoms] = allocateMemory(strlen(property_name)+1);
+		if (!nt_atoms[num_nt_atoms])
+			return None;
+		strcpy(nt_atoms[num_nt_atoms],property_name);
+		return (XA_LAST_PREDEFINED +  num_nt_atoms++);
+	}
+}
+
+/******************************************************************\
+
+         Function:  XGetAtomName
+         Inputs:    Display,Atom
+
+         Comments:  None.
+
+\******************************************************************/
+char *
+XGetAtomName(display,atom)
+Display *display;
+Atom atom;
+{
+	char *ret_string;
+	xtrace("XGetAtomName\n");
+	if (atom > num_nt_atoms + XA_LAST_PREDEFINED)
+		return NULL;
+
+	if (! (ret_string = allocateMemory(strlen(nt_atoms[atom - XA_LAST_PREDEFINED])+1)))
+		return FALSE;
+
+	strcpy(ret_string,nt_atoms[atom]);
+
+	return ret_string;
+}
+
+/******************************************************************\
+
+         Function:  XChangeProperty
+         Inputs:    Display,Window,Property,type,format,mode,data,
+                    nelements.
+
+         Comments:  None.
+
+\******************************************************************/
+int
+XChangeProperty(
+	Display *display,
+	Window window,
+	Atom property,
+	Atom type,
+	int format,
+	int mode,
+	const unsigned char *data,
+	int nelements)
+{
+	NT_window *ntw=(NT_window *)window;
+	struct NT_prop_list *wanderer, *new;
+	xtrace("XChangeProperty\n");
+
+	if (property == XA_CUT_BUFFER0 && type==XA_STRING)
+	{
+		HGLOBAL handle=NULL;
+		char *buffer=NULL;
+		int i,j,cr=0;
+		for (i=0; i<nelements; i++)
+			if (data[i]=='\n' && (i==0 || data[i-1]!='\r')) cr++;
+		
+		handle = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, nelements+cr+1);
+		if (!handle) return;
+		OpenClipboard(ntw->w);
+		buffer = GlobalLock(handle);
+		for (i=j=0; i<nelements; buffer[j++]=data[i++])
+			if (data[i]=='\n' && (i==0 || data[i-1]!='\r')) buffer[j++]='\r';
+		buffer[j++]='\0';
+		GlobalUnlock(handle);
+		SetClipboardData(CF_TEXT, handle);
+		CloseClipboard();
+		return;
+	}
+}
+
+int
+XGetWindowProperty(display,window,property,long_offset,long_length,delete,
+                   req_type,actual_type_return,actual_format_return,
+                   nitems_return,bytes_after_return,prop_return)
+Display *display;
+Window window;
+Atom property;
+long long_offset;
+long long_length;
+BoolDef delete;
+Atom req_type;
+Atom *actual_type_return;
+int *actual_format_return;
+unsigned long *nitems_return;
+unsigned long *bytes_after_return;
+unsigned char **prop_return;
+{
+	NT_window *ntw=(NT_window *)window;
+	struct NT_prop_list *wanderer;
+	char *data, *destPtr;
+	HGLOBAL handle;
+	
+	xtrace("XGetWindowProperty\n");
+	
+	/* here's a hack to fake getting the selection */
+	if (property == XA_CUT_BUFFER0)
+	{
+		if (IsClipboardFormatAvailable(CF_TEXT) &&
+			OpenClipboard(NULL)) {
+			handle = GetClipboardData(CF_TEXT);
+			if (handle != NULL) {
+				data = GlobalLock(handle);
+				*prop_return = allocateMemory(strlen(data)+1);
+				destPtr = *prop_return;
+				while (*data != '\0') {
+					if (*data != '\r') {
+						*destPtr = *data;
+						destPtr++;
+					}
+					data++;
+				}
+				*destPtr = '\0';
+				GlobalUnlock(handle);
+				*nitems_return=strlen(*prop_return);
+				*actual_type_return = XA_STRING;
+				*bytes_after_return = 0;
+			} 
+			CloseClipboard();
+			return 0;
+		}
+	}
+}
+
+
+
+char **
+XListExtensions(display,ret_num)
+Display *display;
+int *ret_num;
+{
+	*ret_num = 0;
+	xtrace("XListExtensions\n");
+	return NULL;
+}
+
+XFreeExtensionList(list)
+char **list;
+{
+	xtrace("XFreeExtensionList\n");
+	return 0;
+}
+
+XChangeGC(
+	Display* display,
+	GC gc,
+	unsigned long mask,
+	XGCValues* gc_values)
+{
+	xtrace("XChangeGC\n");
+	if (mask&GCArcMode)
+		gc->values.arc_mode=gc_values->arc_mode;
+	if (mask&GCBackground)
+		gc->values.background=gc_values->background;
+	if (mask&GCCapStyle)
+		gc->values.cap_style=gc_values->cap_style;
+	if (mask&GCClipMask)
+		gc->values.clip_mask=gc_values->clip_mask;
+	if (mask&GCClipXOrigin)
+		gc->values.clip_x_origin=gc_values->clip_x_origin;
+	if (mask&GCClipYOrigin)
+		gc->values.clip_y_origin=gc_values->clip_y_origin;
+	if (mask&GCDashList)
+		gc->values.dashes=gc_values->dashes;
+	if (mask&GCDashOffset)
+		gc->values.dash_offset=gc_values->dash_offset;
+	if (mask&GCFillRule)
+		gc->values.fill_rule=gc_values->fill_rule;
+	if (mask&GCFillStyle)
+		gc->values.fill_style=gc_values->fill_style;
+	if (mask&GCFont)
+		gc->values.font=gc_values->font;
+	if (mask&GCForeground)
+		gc->values.foreground=gc_values->foreground;
+	if (mask&GCFunction)
+		gc->values.function=gc_values->function;
+	if (mask&GCGraphicsExposures)
+		gc->values.graphics_exposures=gc_values->graphics_exposures;
+	if (mask&GCJoinStyle)
+		gc->values.join_style=gc_values->join_style;
+	if (mask&GCLineStyle)
+		gc->values.line_style=gc_values->line_style;
+	if (mask&GCLineWidth)
+		gc->values.line_width=gc_values->line_width;
+	if (mask&GCPlaneMask)
+		gc->values.plane_mask=gc_values->plane_mask;
+	if (mask&GCStipple)
+		gc->values.stipple=gc_values->stipple;
+	if (mask&GCSubwindowMode)
+		gc->values.subwindow_mode=gc_values->subwindow_mode;
+	if (mask&GCTile)
+		gc->values.tile=gc_values->tile;
+	if (mask&GCTileStipXOrigin)
+		gc->values.ts_x_origin=gc_values->ts_x_origin;
+	if (mask&GCTileStipYOrigin)
+		gc->values.ts_y_origin=gc_values->ts_y_origin;
+	gc->dirty |= mask;
+	return 0;
+}
+
+
+int
+XConnectionNumber(Display* display)
+{
+	int fd;
+	xtrace("XConnectionNumber\n");
+	fd = open ("/dev/windows", O_NONBLOCK, 0);
+	return fd;
+}
+
+XFreeFont(Display* display,XFontStruct* font_struct)
+{
+	xtrace("XFreeFont\n");
+	return 0;
+}
+
+char *
+_Xsetlocale(int category, const char *name)
+{
+	xtrace("Xsetlocale\n");
+	return (char *)name;
+}
+
+char *
+XSetLocaleModifiers(const char* modifier_list)
+{
+	xtrace("XSetLocaleModifiers\n");
+	return NULL;
+}
+XIM
+XOpenIM(
+	Display* dpy,
+	struct _XrmHashBucketRec* rdb,
+	char* res_name,
+	char* res_class)
+{
+	xtrace("XOpenIM\n");
+	return 0;
+}
+char *
+XGetIMValues(XIM im , ...)
+{
+	xtrace("XGetIMValues\n");
+	return NULL;
+}
+XIC
+XCreateIC(XIM im , ...)
+{
+	xtrace("XCreateIC\n");
+	return 0;
+}
+StatusDef
+XCloseIM(XIM im)
+{
+	xtrace("XCloseIM\n");
+	return 0;
+}
+
+char *
+XrmQuarkToString(void *quark)
+{
+	xtrace("XrmQuarkToString\n");
+	return NULL;
+}
+
+int
+XmbLookupString(
+	XIC ic,
+	XKeyPressedEvent* event,
+	char* buffer_return,
+	int bytes_buffer,
+	KeySym* keysym_return,
+	StatusDef* status_return)
+{
+	xtrace("XmbLookupString\n");
+	return 0;
+}
+int
+XmbTextPropertyToTextList(
+	Display *display,
+	XTextProperty *text_prop,
+	char ***list_return,
+	int *count_return)
+{
+	xtrace("XmbTextPropertyToTextList\n");
+	/* in the future copy this, for 2.7.1 rxvt leaks this, so don't yet */
+	*list_return = (char **)allocateMemory(sizeof(char *));
+	*list_return[0] = text_prop->value;
+	*count_return = 1;
+	return 0;	
+}
+
+int
+XmbTextListToTextProperty(
+	 Display *display,
+	 char **list,
+	 int count,
+	 XICCEncodingStyle style,
+	 XTextProperty *text_prop_return)
+{
+	int ret = 0;
+	if (count!=1) ret = XNoMemory;
+	text_prop_return->value = strdup(list[0]);
+	switch (style)
+	{
+		case XStringStyle: text_prop_return->encoding = XA_STRING; break;
+		/* case XCompoundTextStyle: text_prop_return->encoding = XA_COMPOUND; break; */
+		default: ret = XLocaleNotSupported;
+	}
+	text_prop_return->format = 8;
+	text_prop_return->nitems = count;
+	return ret;
+}
+
+void
+XSetICFocus(XIC ic)
+{
+	xtrace("XSetICFocus\n");
+}
+void
+XUnsetICFocus(XIC ic)
+{
+	xtrace("XUnsetICFocus\n");
+}
+
+
+
+/* lifted from emacs */
+/*
+ *    XParseGeometry parses strings of the form
+ *   "=<width>x<height>{+-}<xoffset>{+-}<yoffset>", where
+ *   width, height, xoffset, and yoffset are unsigned integers.
+ *   Example:  "=80x24+300-49"
+ *   The equal sign is optional.
+ *   It returns a bitmask that indicates which of the four values
+ *   were actually found in the string.  For each value found,
+ *   the corresponding argument is updated;  for each value
+ *   not found, the corresponding argument is left unchanged. 
+ */
+
+static int
+read_integer (string, NextString)
+     register char *string;
+     char **NextString;
+{
+	register int Result = 0;
+	int Sign = 1;
+  
+	if (*string == '+')
+		string++;
+	else if (*string == '-')
+    {
+		string++;
+		Sign = -1;
+    }
+	for (; (*string >= '0') && (*string <= '9'); string++)
+    {
+		Result = (Result * 10) + (*string - '0');
+    }
+	*NextString = string;
+	if (Sign >= 0)
+		return (Result);
+	else
+		return (-Result);
+}
+
+/* lifted from emacs */
+int
+XParseGeometry(
+	const char* string,
+	int* x,
+	int* y,
+	unsigned int* width,
+	unsigned int* height)
+{
+	int mask = NoValue;
+	register char *strind;
+	unsigned int tempWidth, tempHeight;
+	int tempX, tempY;
+	char *nextCharacter;
+  
+	if ((string == NULL) || (*string == '\0')) return (mask);
+	if (*string == '=')
+		string++;  /* ignore possible '=' at beg of geometry spec */
+  
+	strind = (char *)string;
+	if (*strind != '+' && *strind != '-' && *strind != 'x') 
+    {
+		tempWidth = read_integer (strind, &nextCharacter);
+		if (strind == nextCharacter) 
+			return (0);
+		strind = nextCharacter;
+		mask |= WidthValue;
+    }
+  
+	if (*strind == 'x' || *strind == 'X') 
+    {	
+		strind++;
+		tempHeight = read_integer (strind, &nextCharacter);
+		if (strind == nextCharacter)
+			return (0);
+		strind = nextCharacter;
+		mask |= HeightValue;
+    }
+  
+	if ((*strind == '+') || (*strind == '-')) 
+    {
+		if (*strind == '-') 
+		{
+			strind++;
+			tempX = -read_integer (strind, &nextCharacter);
+			if (strind == nextCharacter)
+				return (0);
+			strind = nextCharacter;
+			mask |= XNegative;
+
+		}
+		else
+		{	
+			strind++;
+			tempX = read_integer (strind, &nextCharacter);
+			if (strind == nextCharacter)
+				return (0);
+			strind = nextCharacter;
+		}
+		mask |= XValue;
+		if ((*strind == '+') || (*strind == '-')) 
+		{
+			if (*strind == '-') 
+			{
+				strind++;
+				tempY = -read_integer (strind, &nextCharacter);
+				if (strind == nextCharacter)
+					return (0);
+				strind = nextCharacter;
+				mask |= YNegative;
+
+			}
+			else
+			{
+				strind++;
+				tempY = read_integer (strind, &nextCharacter);
+				if (strind == nextCharacter)
+					return (0);
+				strind = nextCharacter;
+			}
+			mask |= YValue;
+		}
+    }
+  
+	/* If strind isn't at the end of the string the it's an invalid
+	   geometry specification. */
+  
+	if (*strind != '\0') return (0);
+  
+	if (mask & XValue)
+		*x = tempX;
+	if (mask & YValue)
+		*y = tempY;
+	if (mask & WidthValue)
+		*width = tempWidth;
+	if (mask & HeightValue)
+		*height = tempHeight;
+	return (mask);
+}
+
+XResizeWindow(
+	Display* display,
+	Window w,
+	unsigned int width,
+	unsigned int height)
+{
+	NT_window *ntw=(NT_window *)w;
+	xtrace("XResizeWindow\n");
+	ntw->wdth = width;
+	ntw->hght = height;
+	if (VALID_WINDOW(ntw)) {
+		MoveWindow(ntw->w, ntw->x,ntw->y,ntw->wdth,ntw->hght,FALSE);
+	}
+	return 0;
+}
+
+void
+XSetWMNormalHints(Display* display,Window w,XSizeHints* hints)
+{
+	xtrace("XSetWMNormalHints\n");
+	XSetNormalHints(display,w,hints);
+}
+
+void
+XSetWMProperties(
+	Display* display,
+	Window w,
+	XTextProperty* window_name,
+	XTextProperty* icon_name,
+	char** argv,
+	int argc,
+	XSizeHints* normal_hints,
+	XWMHints* wm_hints,
+	XClassHint* class_hints)
+{
+	xtrace("XSetWMProperties\n");
+	XSetNormalHints(display,w,normal_hints);
+}
+XDefineCursor(Display* display,Window w,Cursor cursor)
+{
+	xtrace("XDefineCursor\n");
+	return 0;
+}
+
+XMoveResizeWindow(
+	Display* display,
+	Window w,
+	int x,
+	int y,
+	unsigned int width,
+	unsigned int height)
+{
+	NT_window *ntw=(NT_window *)w;
+	xtrace("XMoveResizeWindow\n");
+	ntw->x = x;
+	ntw->y = y;
+	ntw->wdth = width;
+	ntw->hght = height;
+	if (VALID_WINDOW(ntw)) {
+		MoveWindow(ntw->w, x,y,width,height,TRUE);
+	}
+	
+}
+
+XMoveWindow(
+	Display* display,
+	Window w,
+	int x,
+	int y)
+{
+	NT_window *ntw=(NT_window *)w;
+	xtrace("XMoveWindow\n");
+	ntw->x = x;
+	ntw->y = y;
+	if (VALID_WINDOW(ntw)) {
+		MoveWindow(ntw->w, x,y,ntw->wdth,ntw->hght,TRUE);
+	}
+	return 0;
+}
+
+/* 
+ * xcolors.c --
+ *
+ *	This file contains the routines used to map from X color
+ *	names to RGB and pixel values.
+ *
+ * Copyright (c) 1996 by Sun Microsystems, Inc.
+ *
+ * See the file "license.terms" for information on usage and redistribution
+ * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+ *
+ * SCCS: @(#) xcolors.c 1.3 96/12/17 13:07:02
+ */
+
+/*
+ * Define an array that defines the mapping from color names to RGB values.
+ * Note that this array must be kept sorted alphabetically so that the
+ * binary search used in XParseColor will succeed.
+ */
+typedef struct {
+    char *name;
+    unsigned char red;
+    unsigned char green;
+    unsigned char blue;
+} XColorEntry;
+
+static XColorEntry xColors[] = {
+    "alice blue", 240, 248, 255,
+    "AliceBlue", 240, 248, 255,
+    "antique white", 250, 235, 215,
+    "AntiqueWhite", 250, 235, 215,
+    "AntiqueWhite1", 255, 239, 219,
+    "AntiqueWhite2", 238, 223, 204,
+    "AntiqueWhite3", 205, 192, 176,
+    "AntiqueWhite4", 139, 131, 120,
+    "aquamarine", 127, 255, 212,
+    "aquamarine1", 127, 255, 212,
+    "aquamarine2", 118, 238, 198,
+    "aquamarine3", 102, 205, 170,
+    "aquamarine4", 69, 139, 116,
+    "azure", 240, 255, 255,
+    "azure1", 240, 255, 255,
+    "azure2", 224, 238, 238,
+    "azure3", 193, 205, 205,
+    "azure4", 131, 139, 139,
+    "beige", 245, 245, 220,
+    "bisque", 255, 228, 196,
+    "bisque1", 255, 228, 196,
+    "bisque2", 238, 213, 183,
+    "bisque3", 205, 183, 158,
+    "bisque4", 139, 125, 107,
+    "black", 0, 0, 0,
+    "blanched almond", 255, 235, 205,
+    "BlanchedAlmond", 255, 235, 205,
+    "blue", 0, 0, 255,
+    "blue violet", 138, 43, 226,
+    "blue1", 0, 0, 255,
+    "blue2", 0, 0, 238,
+    "blue3", 0, 0, 205,
+    "blue4", 0, 0, 139,
+    "BlueViolet", 138, 43, 226,
+    "brown", 165, 42, 42,
+    "brown1", 255, 64, 64,
+    "brown2", 238, 59, 59,
+    "brown3", 205, 51, 51,
+    "brown4", 139, 35, 35,
+    "burlywood", 222, 184, 135,
+    "burlywood1", 255, 211, 155,
+    "burlywood2", 238, 197, 145,
+    "burlywood3", 205, 170, 125,
+    "burlywood4", 139, 115, 85,
+    "cadet blue", 95, 158, 160,
+    "CadetBlue", 95, 158, 160,
+    "CadetBlue1", 152, 245, 255,
+    "CadetBlue2", 142, 229, 238,
+    "CadetBlue3", 122, 197, 205,
+    "CadetBlue4", 83, 134, 139,
+    "chartreuse", 127, 255, 0,
+    "chartreuse1", 127, 255, 0,
+    "chartreuse2", 118, 238, 0,
+    "chartreuse3", 102, 205, 0,
+    "chartreuse4", 69, 139, 0,
+    "chocolate", 210, 105, 30,
+    "chocolate1", 255, 127, 36,
+    "chocolate2", 238, 118, 33,
+    "chocolate3", 205, 102, 29,
+    "chocolate4", 139, 69, 19,
+    "coral", 255, 127, 80,
+    "coral1", 255, 114, 86,
+    "coral2", 238, 106, 80,
+    "coral3", 205, 91, 69,
+    "coral4", 139, 62, 47,
+    "cornflower blue", 100, 149, 237,
+    "CornflowerBlue", 100, 149, 237,
+    "cornsilk", 255, 248, 220,
+    "cornsilk1", 255, 248, 220,
+    "cornsilk2", 238, 232, 205,
+    "cornsilk3", 205, 200, 177,
+    "cornsilk4", 139, 136, 120,
+    "cyan", 0, 255, 255,
+    "cyan1", 0, 255, 255,
+    "cyan2", 0, 238, 238,
+    "cyan3", 0, 205, 205,
+    "cyan4", 0, 139, 139,
+    "dark goldenrod", 184, 134, 11,
+    "dark green", 0, 100, 0,
+    "dark khaki", 189, 183, 107,
+    "dark olive green", 85, 107, 47,
+    "dark orange", 255, 140, 0,
+    "dark orchid", 153, 50, 204,
+    "dark salmon", 233, 150, 122,
+    "dark sea green", 143, 188, 143,
+    "dark slate blue", 72, 61, 139,
+    "dark slate gray", 47, 79, 79,
+    "dark slate grey", 47, 79, 79,
+    "dark turquoise", 0, 206, 209,
+    "dark violet", 148, 0, 211,
+    "DarkGoldenrod", 184, 134, 11,
+    "DarkGoldenrod1", 255, 185, 15,
+    "DarkGoldenrod2", 238, 173, 14,
+    "DarkGoldenrod3", 205, 149, 12,
+    "DarkGoldenrod4", 139, 101, 8,
+    "DarkGreen", 0, 100, 0,
+    "DarkKhaki", 189, 183, 107,
+    "DarkOliveGreen", 85, 107, 47,
+    "DarkOliveGreen1", 202, 255, 112,
+    "DarkOliveGreen2", 188, 238, 104,
+    "DarkOliveGreen3", 162, 205, 90,
+    "DarkOliveGreen4", 110, 139, 61,
+    "DarkOrange", 255, 140, 0,
+    "DarkOrange1", 255, 127, 0,
+    "DarkOrange2", 238, 118, 0,
+    "DarkOrange3", 205, 102, 0,
+    "DarkOrange4", 139, 69, 0,
+    "DarkOrchid", 153, 50, 204,
+    "DarkOrchid1", 191, 62, 255,
+    "DarkOrchid2", 178, 58, 238,
+    "DarkOrchid3", 154, 50, 205,
+    "DarkOrchid4", 104, 34, 139,
+    "DarkSalmon", 233, 150, 122,
+    "DarkSeaGreen", 143, 188, 143,
+    "DarkSeaGreen1", 193, 255, 193,
+    "DarkSeaGreen2", 180, 238, 180,
+    "DarkSeaGreen3", 155, 205, 155,
+    "DarkSeaGreen4", 105, 139, 105,
+    "DarkSlateBlue", 72, 61, 139,
+    "DarkSlateGray", 47, 79, 79,
+    "DarkSlateGray1", 151, 255, 255,
+    "DarkSlateGray2", 141, 238, 238,
+    "DarkSlateGray3", 121, 205, 205,
+    "DarkSlateGray4", 82, 139, 139,
+    "DarkSlateGrey", 47, 79, 79,
+    "DarkTurquoise", 0, 206, 209,
+    "DarkViolet", 148, 0, 211,
+    "deep pink", 255, 20, 147,
+    "deep sky blue", 0, 191, 255,
+    "DeepPink", 255, 20, 147,
+    "DeepPink1", 255, 20, 147,
+    "DeepPink2", 238, 18, 137,
+    "DeepPink3", 205, 16, 118,
+    "DeepPink4", 139, 10, 80,
+    "DeepSkyBlue", 0, 191, 255,
+    "DeepSkyBlue1", 0, 191, 255,
+    "DeepSkyBlue2", 0, 178, 238,
+    "DeepSkyBlue3", 0, 154, 205,
+    "DeepSkyBlue4", 0, 104, 139,
+    "dim gray", 105, 105, 105,
+    "dim grey", 105, 105, 105,
+    "DimGray", 105, 105, 105,
+    "DimGrey", 105, 105, 105,
+    "dodger blue", 30, 144, 255,
+    "DodgerBlue", 30, 144, 255,
+    "DodgerBlue1", 30, 144, 255,
+    "DodgerBlue2", 28, 134, 238,
+    "DodgerBlue3", 24, 116, 205,
+    "DodgerBlue4", 16, 78, 139,
+    "firebrick", 178, 34, 34,
+    "firebrick1", 255, 48, 48,
+    "firebrick2", 238, 44, 44,
+    "firebrick3", 205, 38, 38,
+    "firebrick4", 139, 26, 26,
+    "floral white", 255, 250, 240,
+    "FloralWhite", 255, 250, 240,
+    "forest green", 34, 139, 34,
+    "ForestGreen", 34, 139, 34,
+    "gainsboro", 220, 220, 220,
+    "ghost white", 248, 248, 255,
+    "GhostWhite", 248, 248, 255,
+    "gold", 255, 215, 0,
+    "gold1", 255, 215, 0,
+    "gold2", 238, 201, 0,
+    "gold3", 205, 173, 0,
+    "gold4", 139, 117, 0,
+    "goldenrod", 218, 165, 32,
+    "goldenrod1", 255, 193, 37,
+    "goldenrod2", 238, 180, 34,
+    "goldenrod3", 205, 155, 29,
+    "goldenrod4", 139, 105, 20,
+    "gray", 190, 190, 190,
+    "gray0", 0, 0, 0,
+    "gray1", 3, 3, 3,
+    "gray10", 26, 26, 26,
+    "gray100", 255, 255, 255,
+    "gray11", 28, 28, 28,
+    "gray12", 31, 31, 31,
+    "gray13", 33, 33, 33,
+    "gray14", 36, 36, 36,
+    "gray15", 38, 38, 38,
+    "gray16", 41, 41, 41,
+    "gray17", 43, 43, 43,
+    "gray18", 46, 46, 46,
+    "gray19", 48, 48, 48,
+    "gray2", 5, 5, 5,
+    "gray20", 51, 51, 51,
+    "gray21", 54, 54, 54,
+    "gray22", 56, 56, 56,
+    "gray23", 59, 59, 59,
+    "gray24", 61, 61, 61,
+    "gray25", 64, 64, 64,
+    "gray26", 66, 66, 66,
+    "gray27", 69, 69, 69,
+    "gray28", 71, 71, 71,
+    "gray29", 74, 74, 74,
+    "gray3", 8, 8, 8,
+    "gray30", 77, 77, 77,
+    "gray31", 79, 79, 79,
+    "gray32", 82, 82, 82,
+    "gray33", 84, 84, 84,
+    "gray34", 87, 87, 87,
+    "gray35", 89, 89, 89,
+    "gray36", 92, 92, 92,
+    "gray37", 94, 94, 94,
+    "gray38", 97, 97, 97,
+    "gray39", 99, 99, 99,
+    "gray4", 10, 10, 10,
+    "gray40", 102, 102, 102,
+    "gray41", 105, 105, 105,
+    "gray42", 107, 107, 107,
+    "gray43", 110, 110, 110,
+    "gray44", 112, 112, 112,
+    "gray45", 115, 115, 115,
+    "gray46", 117, 117, 117,
+    "gray47", 120, 120, 120,
+    "gray48", 122, 122, 122,
+    "gray49", 125, 125, 125,
+    "gray5", 13, 13, 13,
+    "gray50", 127, 127, 127,
+    "gray51", 130, 130, 130,
+    "gray52", 133, 133, 133,
+    "gray53", 135, 135, 135,
+    "gray54", 138, 138, 138,
+    "gray55", 140, 140, 140,
+    "gray56", 143, 143, 143,
+    "gray57", 145, 145, 145,
+    "gray58", 148, 148, 148,
+    "gray59", 150, 150, 150,
+    "gray6", 15, 15, 15,
+    "gray60", 153, 153, 153,
+    "gray61", 156, 156, 156,
+    "gray62", 158, 158, 158,
+    "gray63", 161, 161, 161,
+    "gray64", 163, 163, 163,
+    "gray65", 166, 166, 166,
+    "gray66", 168, 168, 168,
+    "gray67", 171, 171, 171,
+    "gray68", 173, 173, 173,
+    "gray69", 176, 176, 176,
+    "gray7", 18, 18, 18,
+    "gray70", 179, 179, 179,
+    "gray71", 181, 181, 181,
+    "gray72", 184, 184, 184,
+    "gray73", 186, 186, 186,
+    "gray74", 189, 189, 189,
+    "gray75", 191, 191, 191,
+    "gray76", 194, 194, 194,
+    "gray77", 196, 196, 196,
+    "gray78", 199, 199, 199,
+    "gray79", 201, 201, 201,
+    "gray8", 20, 20, 20,
+    "gray80", 204, 204, 204,
+    "gray81", 207, 207, 207,
+    "gray82", 209, 209, 209,
+    "gray83", 212, 212, 212,
+    "gray84", 214, 214, 214,
+    "gray85", 217, 217, 217,
+    "gray86", 219, 219, 219,
+    "gray87", 222, 222, 222,
+    "gray88", 224, 224, 224,
+    "gray89", 227, 227, 227,
+    "gray9", 23, 23, 23,
+    "gray90", 229, 229, 229,
+    "gray91", 232, 232, 232,
+    "gray92", 235, 235, 235,
+    "gray93", 237, 237, 237,
+    "gray94", 240, 240, 240,
+    "gray95", 242, 242, 242,
+    "gray96", 245, 245, 245,
+    "gray97", 247, 247, 247,
+    "gray98", 250, 250, 250,
+    "gray99", 252, 252, 252,
+    "green", 0, 255, 0,
+    "green yellow", 173, 255, 47,
+    "green1", 0, 255, 0,
+    "green2", 0, 238, 0,
+    "green3", 0, 205, 0,
+    "green4", 0, 139, 0,
+    "GreenYellow", 173, 255, 47,
+    "grey", 190, 190, 190,
+    "grey0", 0, 0, 0,
+    "grey1", 3, 3, 3,
+    "grey10", 26, 26, 26,
+    "grey100", 255, 255, 255,
+    "grey11", 28, 28, 28,
+    "grey12", 31, 31, 31,
+    "grey13", 33, 33, 33,
+    "grey14", 36, 36, 36,
+    "grey15", 38, 38, 38,
+    "grey16", 41, 41, 41,
+    "grey17", 43, 43, 43,
+    "grey18", 46, 46, 46,
+    "grey19", 48, 48, 48,
+    "grey2", 5, 5, 5,
+    "grey20", 51, 51, 51,
+    "grey21", 54, 54, 54,
+    "grey22", 56, 56, 56,
+    "grey23", 59, 59, 59,
+    "grey24", 61, 61, 61,
+    "grey25", 64, 64, 64,
+    "grey26", 66, 66, 66,
+    "grey27", 69, 69, 69,
+    "grey28", 71, 71, 71,
+    "grey29", 74, 74, 74,
+    "grey3", 8, 8, 8,
+    "grey30", 77, 77, 77,
+    "grey31", 79, 79, 79,
+    "grey32", 82, 82, 82,
+    "grey33", 84, 84, 84,
+    "grey34", 87, 87, 87,
+    "grey35", 89, 89, 89,
+    "grey36", 92, 92, 92,
+    "grey37", 94, 94, 94,
+    "grey38", 97, 97, 97,
+    "grey39", 99, 99, 99,
+    "grey4", 10, 10, 10,
+    "grey40", 102, 102, 102,
+    "grey41", 105, 105, 105,
+    "grey42", 107, 107, 107,
+    "grey43", 110, 110, 110,
+    "grey44", 112, 112, 112,
+    "grey45", 115, 115, 115,
+    "grey46", 117, 117, 117,
+    "grey47", 120, 120, 120,
+    "grey48", 122, 122, 122,
+    "grey49", 125, 125, 125,
+    "grey5", 13, 13, 13,
+    "grey50", 127, 127, 127,
+    "grey51", 130, 130, 130,
+    "grey52", 133, 133, 133,
+    "grey53", 135, 135, 135,
+    "grey54", 138, 138, 138,
+    "grey55", 140, 140, 140,
+    "grey56", 143, 143, 143,
+    "grey57", 145, 145, 145,
+    "grey58", 148, 148, 148,
+    "grey59", 150, 150, 150,
+    "grey6", 15, 15, 15,
+    "grey60", 153, 153, 153,
+    "grey61", 156, 156, 156,
+    "grey62", 158, 158, 158,
+    "grey63", 161, 161, 161,
+    "grey64", 163, 163, 163,
+    "grey65", 166, 166, 166,
+    "grey66", 168, 168, 168,
+    "grey67", 171, 171, 171,
+    "grey68", 173, 173, 173,
+    "grey69", 176, 176, 176,
+    "grey7", 18, 18, 18,
+    "grey70", 179, 179, 179,
+    "grey71", 181, 181, 181,
+    "grey72", 184, 184, 184,
+    "grey73", 186, 186, 186,
+    "grey74", 189, 189, 189,
+    "grey75", 191, 191, 191,
+    "grey76", 194, 194, 194,
+    "grey77", 196, 196, 196,
+    "grey78", 199, 199, 199,
+    "grey79", 201, 201, 201,
+    "grey8", 20, 20, 20,
+    "grey80", 204, 204, 204,
+    "grey81", 207, 207, 207,
+    "grey82", 209, 209, 209,
+    "grey83", 212, 212, 212,
+    "grey84", 214, 214, 214,
+    "grey85", 217, 217, 217,
+    "grey86", 219, 219, 219,
+    "grey87", 222, 222, 222,
+    "grey88", 224, 224, 224,
+    "grey89", 227, 227, 227,
+    "grey9", 23, 23, 23,
+    "grey90", 229, 229, 229,
+    "grey91", 232, 232, 232,
+    "grey92", 235, 235, 235,
+    "grey93", 237, 237, 237,
+    "grey94", 240, 240, 240,
+    "grey95", 242, 242, 242,
+    "grey96", 245, 245, 245,
+    "grey97", 247, 247, 247,
+    "grey98", 250, 250, 250,
+    "grey99", 252, 252, 252,
+    "honeydew", 240, 255, 240,
+    "honeydew1", 240, 255, 240,
+    "honeydew2", 224, 238, 224,
+    "honeydew3", 193, 205, 193,
+    "honeydew4", 131, 139, 131,
+    "hot pink", 255, 105, 180,
+    "HotPink", 255, 105, 180,
+    "HotPink1", 255, 110, 180,
+    "HotPink2", 238, 106, 167,
+    "HotPink3", 205, 96, 144,
+    "HotPink4", 139, 58, 98,
+    "indian red", 205, 92, 92,
+    "IndianRed", 205, 92, 92,
+    "IndianRed1", 255, 106, 106,
+    "IndianRed2", 238, 99, 99,
+    "IndianRed3", 205, 85, 85,
+    "IndianRed4", 139, 58, 58,
+    "ivory", 255, 255, 240,
+    "ivory1", 255, 255, 240,
+    "ivory2", 238, 238, 224,
+    "ivory3", 205, 205, 193,
+    "ivory4", 139, 139, 131,
+    "khaki", 240, 230, 140,
+    "khaki1", 255, 246, 143,
+    "khaki2", 238, 230, 133,
+    "khaki3", 205, 198, 115,
+    "khaki4", 139, 134, 78,
+    "lavender", 230, 230, 250,
+    "lavender blush", 255, 240, 245,
+    "LavenderBlush", 255, 240, 245,
+    "LavenderBlush1", 255, 240, 245,
+    "LavenderBlush2", 238, 224, 229,
+    "LavenderBlush3", 205, 193, 197,
+    "LavenderBlush4", 139, 131, 134,
+    "lawn green", 124, 252, 0,
+    "LawnGreen", 124, 252, 0,
+    "lemon chiffon", 255, 250, 205,
+    "LemonChiffon", 255, 250, 205,
+    "LemonChiffon1", 255, 250, 205,
+    "LemonChiffon2", 238, 233, 191,
+    "LemonChiffon3", 205, 201, 165,
+    "LemonChiffon4", 139, 137, 112,
+    "light blue", 173, 216, 230,
+    "light coral", 240, 128, 128,
+    "light cyan", 224, 255, 255,
+    "light goldenrod", 238, 221, 130,
+    "light goldenrod yellow", 250, 250, 210,
+    "light gray", 211, 211, 211,
+    "light grey", 211, 211, 211,
+    "light pink", 255, 182, 193,
+    "light salmon", 255, 160, 122,
+    "light sea green", 32, 178, 170,
+    "light sky blue", 135, 206, 250,
+    "light slate blue", 132, 112, 255,
+    "light slate gray", 119, 136, 153,
+    "light slate grey", 119, 136, 153,
+    "light steel blue", 176, 196, 222,
+    "light yellow", 255, 255, 224,
+    "LightBlue", 173, 216, 230,
+    "LightBlue1", 191, 239, 255,
+    "LightBlue2", 178, 223, 238,
+    "LightBlue3", 154, 192, 205,
+    "LightBlue4", 104, 131, 139,
+    "LightCoral", 240, 128, 128,
+    "LightCyan", 224, 255, 255,
+    "LightCyan1", 224, 255, 255,
+    "LightCyan2", 209, 238, 238,
+    "LightCyan3", 180, 205, 205,
+    "LightCyan4", 122, 139, 139,
+    "LightGoldenrod", 238, 221, 130,
+    "LightGoldenrod1", 255, 236, 139,
+    "LightGoldenrod2", 238, 220, 130,
+    "LightGoldenrod3", 205, 190, 112,
+    "LightGoldenrod4", 139, 129, 76,
+    "LightGoldenrodYellow", 250, 250, 210,
+    "LightGray", 211, 211, 211,
+    "LightGrey", 211, 211, 211,
+    "LightPink", 255, 182, 193,
+    "LightPink1", 255, 174, 185,
+    "LightPink2", 238, 162, 173,
+    "LightPink3", 205, 140, 149,
+    "LightPink4", 139, 95, 101,
+    "LightSalmon", 255, 160, 122,
+    "LightSalmon1", 255, 160, 122,
+    "LightSalmon2", 238, 149, 114,
+    "LightSalmon3", 205, 129, 98,
+    "LightSalmon4", 139, 87, 66,
+    "LightSeaGreen", 32, 178, 170,
+    "LightSkyBlue", 135, 206, 250,
+    "LightSkyBlue1", 176, 226, 255,
+    "LightSkyBlue2", 164, 211, 238,
+    "LightSkyBlue3", 141, 182, 205,
+    "LightSkyBlue4", 96, 123, 139,
+    "LightSlateBlue", 132, 112, 255,
+    "LightSlateGray", 119, 136, 153,
+    "LightSlateGrey", 119, 136, 153,
+    "LightSteelBlue", 176, 196, 222,
+    "LightSteelBlue1", 202, 225, 255,
+    "LightSteelBlue2", 188, 210, 238,
+    "LightSteelBlue3", 162, 181, 205,
+    "LightSteelBlue4", 110, 123, 139,
+    "LightYellow", 255, 255, 224,
+    "LightYellow1", 255, 255, 224,
+    "LightYellow2", 238, 238, 209,
+    "LightYellow3", 205, 205, 180,
+    "LightYellow4", 139, 139, 122,
+    "lime green", 50, 205, 50,
+    "LimeGreen", 50, 205, 50,
+    "linen", 250, 240, 230,
+    "magenta", 255, 0, 255,
+    "magenta1", 255, 0, 255,
+    "magenta2", 238, 0, 238,
+    "magenta3", 205, 0, 205,
+    "magenta4", 139, 0, 139,
+    "maroon", 176, 48, 96,
+    "maroon1", 255, 52, 179,
+    "maroon2", 238, 48, 167,
+    "maroon3", 205, 41, 144,
+    "maroon4", 139, 28, 98,
+    "medium aquamarine", 102, 205, 170,
+    "medium blue", 0, 0, 205,
+    "medium orchid", 186, 85, 211,
+    "medium purple", 147, 112, 219,
+    "medium sea green", 60, 179, 113,
+    "medium slate blue", 123, 104, 238,
+    "medium spring green", 0, 250, 154,
+    "medium turquoise", 72, 209, 204,
+    "medium violet red", 199, 21, 133,
+    "MediumAquamarine", 102, 205, 170,
+    "MediumBlue", 0, 0, 205,
+    "MediumOrchid", 186, 85, 211,
+    "MediumOrchid1", 224, 102, 255,
+    "MediumOrchid2", 209, 95, 238,
+    "MediumOrchid3", 180, 82, 205,
+    "MediumOrchid4", 122, 55, 139,
+    "MediumPurple", 147, 112, 219,
+    "MediumPurple1", 171, 130, 255,
+    "MediumPurple2", 159, 121, 238,
+    "MediumPurple3", 137, 104, 205,
+    "MediumPurple4", 93, 71, 139,
+    "MediumSeaGreen", 60, 179, 113,
+    "MediumSlateBlue", 123, 104, 238,
+    "MediumSpringGreen", 0, 250, 154,
+    "MediumTurquoise", 72, 209, 204,
+    "MediumVioletRed", 199, 21, 133,
+    "midnight blue", 25, 25, 112,
+    "MidnightBlue", 25, 25, 112,
+    "mint cream", 245, 255, 250,
+    "MintCream", 245, 255, 250,
+    "misty rose", 255, 228, 225,
+    "MistyRose", 255, 228, 225,
+    "MistyRose1", 255, 228, 225,
+    "MistyRose2", 238, 213, 210,
+    "MistyRose3", 205, 183, 181,
+    "MistyRose4", 139, 125, 123,
+    "moccasin", 255, 228, 181,
+    "navajo white", 255, 222, 173,
+    "NavajoWhite", 255, 222, 173,
+    "NavajoWhite1", 255, 222, 173,
+    "NavajoWhite2", 238, 207, 161,
+    "NavajoWhite3", 205, 179, 139,
+    "NavajoWhite4", 139, 121, 94,
+    "navy", 0, 0, 128,
+    "navy blue", 0, 0, 128,
+    "NavyBlue", 0, 0, 128,
+    "old lace", 253, 245, 230,
+    "OldLace", 253, 245, 230,
+    "olive drab", 107, 142, 35,
+    "OliveDrab", 107, 142, 35,
+    "OliveDrab1", 192, 255, 62,
+    "OliveDrab2", 179, 238, 58,
+    "OliveDrab3", 154, 205, 50,
+    "OliveDrab4", 105, 139, 34,
+    "orange", 255, 165, 0,
+    "orange red", 255, 69, 0,
+    "orange1", 255, 165, 0,
+    "orange2", 238, 154, 0,
+    "orange3", 205, 133, 0,
+    "orange4", 139, 90, 0,
+    "OrangeRed", 255, 69, 0,
+    "OrangeRed1", 255, 69, 0,
+    "OrangeRed2", 238, 64, 0,
+    "OrangeRed3", 205, 55, 0,
+    "OrangeRed4", 139, 37, 0,
+    "orchid", 218, 112, 214,
+    "orchid1", 255, 131, 250,
+    "orchid2", 238, 122, 233,
+    "orchid3", 205, 105, 201,
+    "orchid4", 139, 71, 137,
+    "pale goldenrod", 238, 232, 170,
+    "pale green", 152, 251, 152,
+    "pale turquoise", 175, 238, 238,
+    "pale violet red", 219, 112, 147,
+    "PaleGoldenrod", 238, 232, 170,
+    "PaleGreen", 152, 251, 152,
+    "PaleGreen1", 154, 255, 154,
+    "PaleGreen2", 144, 238, 144,
+    "PaleGreen3", 124, 205, 124,
+    "PaleGreen4", 84, 139, 84,
+    "PaleTurquoise", 175, 238, 238,
+    "PaleTurquoise1", 187, 255, 255,
+    "PaleTurquoise2", 174, 238, 238,
+    "PaleTurquoise3", 150, 205, 205,
+    "PaleTurquoise4", 102, 139, 139,
+    "PaleVioletRed", 219, 112, 147,
+    "PaleVioletRed1", 255, 130, 171,
+    "PaleVioletRed2", 238, 121, 159,
+    "PaleVioletRed3", 205, 104, 137,
+    "PaleVioletRed4", 139, 71, 93,
+    "papaya whip", 255, 239, 213,
+    "PapayaWhip", 255, 239, 213,
+    "peach puff", 255, 218, 185,
+    "PeachPuff", 255, 218, 185,
+    "PeachPuff1", 255, 218, 185,
+    "PeachPuff2", 238, 203, 173,
+    "PeachPuff3", 205, 175, 149,
+    "PeachPuff4", 139, 119, 101,
+    "peru", 205, 133, 63,
+    "pink", 255, 192, 203,
+    "pink1", 255, 181, 197,
+    "pink2", 238, 169, 184,
+    "pink3", 205, 145, 158,
+    "pink4", 139, 99, 108,
+    "plum", 221, 160, 221,
+    "plum1", 255, 187, 255,
+    "plum2", 238, 174, 238,
+    "plum3", 205, 150, 205,
+    "plum4", 139, 102, 139,
+    "powder blue", 176, 224, 230,
+    "PowderBlue", 176, 224, 230,
+    "purple", 160, 32, 240,
+    "purple1", 155, 48, 255,
+    "purple2", 145, 44, 238,
+    "purple3", 125, 38, 205,
+    "purple4", 85, 26, 139,
+    "red", 255, 0, 0,
+    "red1", 255, 0, 0,
+    "red2", 238, 0, 0,
+    "red3", 205, 0, 0,
+    "red4", 139, 0, 0,
+    "rosy brown", 188, 143, 143,
+    "RosyBrown", 188, 143, 143,
+    "RosyBrown1", 255, 193, 193,
+    "RosyBrown2", 238, 180, 180,
+    "RosyBrown3", 205, 155, 155,
+    "RosyBrown4", 139, 105, 105,
+    "royal blue", 65, 105, 225,
+    "RoyalBlue", 65, 105, 225,
+    "RoyalBlue1", 72, 118, 255,
+    "RoyalBlue2", 67, 110, 238,
+    "RoyalBlue3", 58, 95, 205,
+    "RoyalBlue4", 39, 64, 139,
+    "saddle brown", 139, 69, 19,
+    "SaddleBrown", 139, 69, 19,
+    "salmon", 250, 128, 114,
+    "salmon1", 255, 140, 105,
+    "salmon2", 238, 130, 98,
+    "salmon3", 205, 112, 84,
+    "salmon4", 139, 76, 57,
+    "sandy brown", 244, 164, 96,
+    "SandyBrown", 244, 164, 96,
+    "sea green", 46, 139, 87,
+    "SeaGreen", 46, 139, 87,
+    "SeaGreen1", 84, 255, 159,
+    "SeaGreen2", 78, 238, 148,
+    "SeaGreen3", 67, 205, 128,
+    "SeaGreen4", 46, 139, 87,
+    "seashell", 255, 245, 238,
+    "seashell1", 255, 245, 238,
+    "seashell2", 238, 229, 222,
+    "seashell3", 205, 197, 191,
+    "seashell4", 139, 134, 130,
+    "sienna", 160, 82, 45,
+    "sienna1", 255, 130, 71,
+    "sienna2", 238, 121, 66,
+    "sienna3", 205, 104, 57,
+    "sienna4", 139, 71, 38,
+    "sky blue", 135, 206, 235,
+    "SkyBlue", 135, 206, 235,
+    "SkyBlue1", 135, 206, 255,
+    "SkyBlue2", 126, 192, 238,
+    "SkyBlue3", 108, 166, 205,
+    "SkyBlue4", 74, 112, 139,
+    "slate blue", 106, 90, 205,
+    "slate gray", 112, 128, 144,
+    "slate grey", 112, 128, 144,
+    "SlateBlue", 106, 90, 205,
+    "SlateBlue1", 131, 111, 255,
+    "SlateBlue2", 122, 103, 238,
+    "SlateBlue3", 105, 89, 205,
+    "SlateBlue4", 71, 60, 139,
+    "SlateGray", 112, 128, 144,
+    "SlateGray1", 198, 226, 255,
+    "SlateGray2", 185, 211, 238,
+    "SlateGray3", 159, 182, 205,
+    "SlateGray4", 108, 123, 139,
+    "SlateGrey", 112, 128, 144,
+    "snow", 255, 250, 250,
+    "snow1", 255, 250, 250,
+    "snow2", 238, 233, 233,
+    "snow3", 205, 201, 201,
+    "snow4", 139, 137, 137,
+    "spring green", 0, 255, 127,
+    "SpringGreen", 0, 255, 127,
+    "SpringGreen1", 0, 255, 127,
+    "SpringGreen2", 0, 238, 118,
+    "SpringGreen3", 0, 205, 102,
+    "SpringGreen4", 0, 139, 69,
+    "steel blue", 70, 130, 180,
+    "SteelBlue", 70, 130, 180,
+    "SteelBlue1", 99, 184, 255,
+    "SteelBlue2", 92, 172, 238,
+    "SteelBlue3", 79, 148, 205,
+    "SteelBlue4", 54, 100, 139,
+    "tan", 210, 180, 140,
+    "tan1", 255, 165, 79,
+    "tan2", 238, 154, 73,
+    "tan3", 205, 133, 63,
+    "tan4", 139, 90, 43,
+    "thistle", 216, 191, 216,
+    "thistle1", 255, 225, 255,
+    "thistle2", 238, 210, 238,
+    "thistle3", 205, 181, 205,
+    "thistle4", 139, 123, 139,
+    "tomato", 255, 99, 71,
+    "tomato1", 255, 99, 71,
+    "tomato2", 238, 92, 66,
+    "tomato3", 205, 79, 57,
+    "tomato4", 139, 54, 38,
+    "turquoise", 64, 224, 208,
+    "turquoise1", 0, 245, 255,
+    "turquoise2", 0, 229, 238,
+    "turquoise3", 0, 197, 205,
+    "turquoise4", 0, 134, 139,
+    "violet", 238, 130, 238,
+    "violet red", 208, 32, 144,
+    "VioletRed", 208, 32, 144,
+    "VioletRed1", 255, 62, 150,
+    "VioletRed2", 238, 58, 140,
+    "VioletRed3", 205, 50, 120,
+    "VioletRed4", 139, 34, 82,
+    "wheat", 245, 222, 179,
+    "wheat1", 255, 231, 186,
+    "wheat2", 238, 216, 174,
+    "wheat3", 205, 186, 150,
+    "wheat4", 139, 126, 102,
+    "white", 255, 255, 255,
+    "white smoke", 245, 245, 245,
+    "WhiteSmoke", 245, 245, 245,
+    "yellow", 255, 255, 0,
+    "yellow green", 154, 205, 50,
+    "yellow1", 255, 255, 0,
+    "yellow2", 238, 238, 0,
+    "yellow3", 205, 205, 0,
+    "yellow4", 139, 139, 0,
+    "YellowGreen", 154, 205, 50,
+    NULL, 0, 0, 0
+};
+
+
+/*
+ * This value will be set to the number of colors in the color table
+ * the first time it is needed.
+ */
+
+static int numXColors = 0;
+
+/*
+ * Forward declarations for functions used only in this file.
+ */
+
+static int	FindColor(const char *name, XColor *colorPtr);
+
+int strcasecmp(const char *a, const char *b)
+{
+	int i=0,c;
+	if((a==NULL)||(b==NULL)) return -1;
+	
+	while(((!(c=toupper(a[i])-toupper(b[i])))&&a[i]&&b[i])) i++;
+	return c;
+}
+/*
+ *----------------------------------------------------------------------
+ *
+ * FindColor --
+ *
+ *	This routine finds the color entry that corresponds to the
+ *	specified color.
+ *
+ * Results:
+ *	Returns non-zero on success.  The RGB values of the XColor
+ *	will be initialized to the proper values on success.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+static int
+FindColor(name, colorPtr)
+    const char *name;
+    XColor *colorPtr;
+{
+    int l, u, r, i;
+
+    /*
+     * Count the number of elements in the color array if we haven't
+     * done so yet.
+     */
+
+    if (numXColors == 0) {
+	XColorEntry *ePtr;
+	for (ePtr = xColors; ePtr->name != NULL; ePtr++) {
+	    numXColors++;
+	}
+    }
+
+    /*
+     * Perform a binary search on the sorted array of colors.
+     */
+
+    l = 0;
+    u = numXColors - 1;
+    while (l <= u) {
+	i = (l + u) / 2;
+	r = strcasecmp(name, xColors[i].name);
+	if (r == 0) {
+	    break;
+	} else if (r < 0) {
+	    u = i-1;
+	} else {
+	    l = i+1;
+	}
+    }
+    if (l > u) {
+	return 0;
+    }
+    colorPtr->red = xColors[i].red << 8;
+    colorPtr->green = xColors[i].green << 8;
+    colorPtr->blue = xColors[i].blue << 8;
+    return 1;
+}
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * XParseColor --
+ *
+ *	Partial implementation of X color name parsing interface.
+ *
+ * Results:
+ *	Returns non-zero on success.
+ *
+ * Side effects:
+ *	None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+StatusDef
+XParseColor(display, map, spec, colorPtr)
+    Display *display;
+    Colormap map;
+    const char* spec;
+    XColor *colorPtr;
+{
+    if (spec[0] == '#') {
+	char fmt[16];
+	int i, red, green, blue;
+	
+	if ((i = strlen(spec+1))%3) {
+	    return 0;
+	}
+	i /= 3;
+
+	sprintf(fmt, "%%%dx%%%dx%%%dx", i, i, i);
+	if (sscanf(spec+1, fmt, &red, &green, &blue) != 3) {
+	    return 0;
+	}
+	colorPtr->red = ((unsigned short) red) << (4 * (4 - i));
+	colorPtr->green = ((unsigned short) green) << (4 * (4 - i));
+	colorPtr->blue = ((unsigned short) blue) << (4 * (4 - i));
+    } else {
+	if (!FindColor(spec, colorPtr)) {
+	    return 0;
+	}
+    }
+    colorPtr->pixel = ((colorPtr->red)>>8)&0xff;
+    colorPtr->flags = DoRed|DoGreen|DoBlue;
+    colorPtr->pad = 0;
+    return 1;
+}
+/** xpm support */
+int
+XFreeColors(display, cmap, pixels, npixels, planes)
+Display *display;
+Colormap cmap;
+unsigned long pixels[];
+int npixels;
+unsigned long planes;
+{
+	return 0;
+}
+
+int
+XGrabServer(display)
+	 Display *display;
+{
+	return 0;
+}
+
+int
+XUngrabServer(display)
+	 Display *display;
+{
+	return 0;
+}
+
+
+#endif
diff -urN rxvt-2.7.2-orig/W11/wrap/Makefile rxvt-2.7.2/W11/wrap/Makefile
--- rxvt-2.7.2-orig/W11/wrap/Makefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/wrap/Makefile	Thu May 24 21:52:48 2001
@@ -0,0 +1,21 @@
+
+first_rule: all
+
+all allbin: ../lib/libX11.a
+
+alldoc tags:
+
+../lib/libX11.a: wrap.o rxvt_res.o
+	ar r ../lib/libX11.a wrap.o rxvt_res.o
+
+wrap.o: wrap.c xwrappers.gen
+	gcc -O -c wrap.c -I.. -mwin32
+
+rxvt_res.o: rxvt.rc
+	windres -i rxvt.rc -o rxvt_res.o
+
+xwrappers.gen: ../X11/Xlib.h
+	perl mkproxy.pl ../X11/Xlib.h > xwrappers.gen
+
+clean:
+	rm wrap.o rxvt_res.o ../lib/libX11.a 
diff -urN rxvt-2.7.2-orig/W11/wrap/mkproxy.pl rxvt-2.7.2/W11/wrap/mkproxy.pl
--- rxvt-2.7.2-orig/W11/wrap/mkproxy.pl	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/wrap/mkproxy.pl	Sat Apr 14 16:49:08 2001
@@ -0,0 +1,36 @@
+#! perl
+
+$file = join("",<>);
+$file=~s/[^\000]+\/\* functions \*\///;
+$file=~s/#endif\s+$//;
+foreach my $def (split(/\s*;\s*/,$file))
+{
+	$def =~ s/\s+/ /g;
+	my $paren = ($def=~s/\(([^\(\)]*)\)\s*//)?$1:'';
+	my $type = ($def=~s/^([^\000]*\s+\*?)//)?$1:'';
+	$type=~s/^\s+//; 
+	$type=~s/\s+$//;  
+	push(@list,{def=>$def,type=>$type,paren=>$paren}); 
+}
+foreach my $s (sort {$a->{def} cmp $b->{def}} @list) 
+{
+	my $def = $s->{def};
+	my $type = $s->{type};
+	my $paren=$s->{paren};
+	my $params = $paren;
+	$params=~s/[\[\]\*]//g;
+	$params=~s/\s+,/,/g;
+	$params=~s/[^,\s]+\s+//g;
+	next if ($params =~ /\.\.\./);
+	next if ($def eq 'XOpenDisplay');
+	my $return = $type eq 'void' ? '':'return ';
+	print "
+typedef $type (proto_$def)($paren);
+static proto_$def *func_$def = NULL;
+$type $def($paren) {
+	if (!func_$def) func_$def=(proto_$def *)_loadfunc(\"$def\");
+	$return(func_$def)($params);
+}
+";
+
+}
Binary files rxvt-2.7.2-orig/W11/wrap/rxtv.ico and rxvt-2.7.2/W11/wrap/rxtv.ico differ
Binary files rxvt-2.7.2-orig/W11/wrap/rxvt.ico and rxvt-2.7.2/W11/wrap/rxvt.ico differ
diff -urN rxvt-2.7.2-orig/W11/wrap/rxvt.rc rxvt-2.7.2/W11/wrap/rxvt.rc
--- rxvt-2.7.2-orig/W11/wrap/rxvt.rc	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/wrap/rxvt.rc	Sun Jun  3 19:27:54 2001
@@ -0,0 +1,23 @@
+#include "wrap.h"
+
+IDI_RXTV ICON    DISCARDABLE PRELOAD     "rxtv.ico"
+IDI_RXVT ICON       "rxvt.ico"
+
+1 VERSIONINFO 
+FILEVERSION 2, 7, 2, 6
+PRODUCTVERSION 2, 7, 2, 6
+FILESUBTYPE 0
+BEGIN
+ BLOCK "StringFileInfo"
+ BEGIN
+  BLOCK "04090000"
+  BEGIN
+   VALUE "FileDescription", "Terminal program.\000"
+   VALUE "FileVersion", "2.7.2-6\000"
+   VALUE "InternalName", "rxvt\000"
+   VALUE "OriginalFilename", "rxvt.exe\000"
+   VALUE "ProductName","rxvt\000"
+   VALUE "ProductVersion","2.7.2-6\000"
+  END
+ END
+END
diff -urN rxvt-2.7.2-orig/W11/wrap/wrap.c rxvt-2.7.2/W11/wrap/wrap.c
--- rxvt-2.7.2-orig/W11/wrap/wrap.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/wrap/wrap.c	Sun Jun  3 19:39:48 2001
@@ -0,0 +1,217 @@
+
+#include <X11/Xlib.h>
+#include <windows.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <malloc.h>
+#include "wrap.h"
+
+void __cdecl WinMainCRTStartup(void) { mainCRTStartup(); }
+
+static void *_lib=NULL;
+static char *_libname = NULL;
+
+static void *_loadfunc(char *name)
+{
+	void *f = NULL;
+	if (_lib==NULL) {
+		if (_libname==NULL) {
+			fprintf(stderr,"%s called before XOpenDisplay!\n",name);
+			exit(3);
+		}
+		_lib = LoadLibrary(_libname);
+		if (_lib == NULL) {
+			fprintf(stderr,"failed to load %s.dll\n",_libname);
+			exit(1);
+		}
+	}
+	f = GetProcAddress(_lib,name);
+	if (f==NULL) {
+		fprintf(stderr,"failed to find %s\n",name);
+		exit(2);
+	}	
+	return f;
+}
+
+static void _freelib()
+{
+	FreeLibrary(_lib);
+	_lib=NULL;
+}
+typedef LONG (proto_WndProc)(HWND hWnd,UINT message,UINT wParam,LONG lParam);
+static proto_WndProc *func_WndProc = NULL;
+LONG __stdcall WndProc(HWND hWnd,UINT message,UINT wParam,LONG lParam)
+{
+	if (!func_WndProc) func_WndProc=(proto_WndProc *)_loadfunc("NT_handleMsg");
+	return (func_WndProc)(hWnd,message,wParam,lParam);
+}
+
+static void
+hideConsole()
+{
+	HWND conwin;
+	HANDLE hConsole;
+	CONSOLE_SCREEN_BUFFER_INFO buffInfo;
+	SECURITY_ATTRIBUTES  sa;
+
+ 	char app_name[40];
+	sprintf(app_name, "rxvt%08x", (unsigned int)GetCurrentThreadId());
+	/* from eConsole source */
+	sa.nLength = sizeof(sa);
+	sa.bInheritHandle = TRUE;
+	sa.lpSecurityDescriptor = NULL;	
+	hConsole = CreateFile( "CONOUT$", GENERIC_WRITE | GENERIC_READ,
+						   FILE_SHARE_READ | FILE_SHARE_WRITE, &sa,	
+						   OPEN_EXISTING, 0, 0 );
+	if (GetConsoleScreenBufferInfo(hConsole,&buffInfo) &&
+		buffInfo.dwCursorPosition.X==0 &&
+		buffInfo.dwCursorPosition.Y==0)
+	{
+		/* find the console window, from eConsole source */
+		SetConsoleTitle( app_name );
+		while ((conwin = FindWindow( NULL, app_name))==NULL)
+			Sleep( 40 );
+		ShowWindowAsync(conwin, SW_HIDE);
+	}
+}
+
+
+ATOM
+_register_window_class()
+{
+	WNDCLASS  wc;
+	HANDLE    curInstance = GetModuleHandleA(NULL);
+	char app_name[40];
+	sprintf(app_name, "rxvt%08x", (unsigned int)GetCurrentThreadId());	
+	hideConsole();
+	wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC; /* CS_OWNDC */
+	wc.lpfnWndProc = WndProc;
+	wc.cbClsExtra = 0;
+	wc.cbWndExtra = 0;
+	wc.hInstance = curInstance;
+	wc.hIcon = LoadIcon(curInstance, MAKEINTRESOURCE( IDI_RXTV ));
+	wc.hCursor =  LoadCursor(NULL, IDC_ARROW);
+	wc.hbrBackground = NULL;
+	wc.lpszMenuName =  NULL;
+	wc.lpszClassName = app_name;
+	return RegisterClass(&wc);
+}
+
+typedef void (proto_NT_SetAtom)(ATOM class);
+static proto_NT_SetAtom *func_NT_SetAtom = NULL;
+void _set_atom(ATOM class)
+{
+	if (!func_NT_SetAtom) func_NT_SetAtom=(proto_NT_SetAtom *)_loadfunc("NT_SetAtom");
+	(func_NT_SetAtom)(class);
+}
+
+typedef Display * (proto_XOpenDisplay)(const char *name);
+static proto_XOpenDisplay *func_XOpenDisplay = NULL;
+Display * XOpenDisplay(const char *name) {
+	ATOM class;
+	char *env_var=NULL;
+	if (_libname==NULL)
+	{
+		env_var = getenv("W11_LIBRARY");
+		if (env_var!=NULL) _libname = strdup(env_var);
+		else if (name==NULL || !strcmp(name,":0")) {
+			_libname="libW11";
+			class = _register_window_class();
+			_set_atom(class);
+		}	
+		else _libname="libX11";
+	}
+	if (!func_XOpenDisplay) func_XOpenDisplay=(proto_XOpenDisplay *)_loadfunc("XOpenDisplay");
+	return (func_XOpenDisplay)(name);
+}
+
+typedef struct {
+    char    *name;
+    XPointer value;
+} XIMArg;
+
+static void
+_XIMVaToList(va_list var, XIMArg *args)
+{
+    char   *attr;
+	int i = 0;
+    if (!args) return;
+    for (attr = va_arg(var, char*); attr && i<11; attr = va_arg(var, char*)) {
+	    args->name = attr;
+	    args->value = va_arg(var, XPointer);
+	    args++;
+		i++;
+    }
+	for(;i<11;i++) {
+		args->name=NULL;
+		args->value=NULL;
+		args++;
+	}
+}
+
+typedef XIC (proto_XCreateIC)(XIM im, ...);
+static proto_XCreateIC *func_XCreateIC = NULL;
+XIC
+XCreateIC(XIM im, ...)
+{
+    va_list var;
+    XIMArg a[11];
+
+    va_start(var, im);
+    _XIMVaToList(var, a);
+    va_end(var);
+	
+	if (a[10].name!=NULL) {
+		fprintf(stderr,"call to XCreateIC with more than 20 args\n");
+		exit(5);
+	}
+	
+	if (!func_XCreateIC) func_XCreateIC=(proto_XCreateIC *)_loadfunc("XCreateIC");
+	return (func_XCreateIC)(im,
+						   a[0].name, a[0].value,
+						   a[1].name, a[1].value,
+						   a[2].name, a[2].value,
+						   a[3].name, a[3].value,
+						   a[4].name, a[4].value,
+						   a[5].name, a[5].value,
+						   a[6].name, a[6].value,
+						   a[7].name, a[7].value,
+						   a[8].name, a[8].value,
+						   a[9].name, a[9].value,
+						   NULL);
+}
+
+typedef char * (proto_XGetIMValues)(XIM im, ...);
+static proto_XGetIMValues *func_XGetIMValues = NULL;
+char *
+XGetIMValues(XIM im, ...)
+{
+    va_list var;
+    XIMArg a[11];
+
+    va_start(var, im);
+    _XIMVaToList(var, a);
+    va_end(var);
+	
+	if (a[10].name!=NULL) {
+		fprintf(stderr,"call to XGetIMValues with more than 20 args\n");
+		exit(5);
+	}
+
+	if (!func_XGetIMValues) func_XGetIMValues=(proto_XGetIMValues *)_loadfunc("XGetIMValues");
+	return (func_XGetIMValues)(im,
+						   a[0].name, a[0].value,
+						   a[1].name, a[1].value,
+						   a[2].name, a[2].value,
+						   a[3].name, a[3].value,
+						   a[4].name, a[4].value,
+						   a[5].name, a[5].value,
+						   a[6].name, a[6].value,
+						   a[7].name, a[7].value,
+						   a[8].name, a[8].value,
+						   a[9].name, a[9].value,
+						   NULL);
+}
+
+
+#include "xwrappers.gen"
diff -urN rxvt-2.7.2-orig/W11/wrap/wrap.h rxvt-2.7.2/W11/wrap/wrap.h
--- rxvt-2.7.2-orig/W11/wrap/wrap.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/wrap/wrap.h	Fri May 25 09:24:22 2001
@@ -0,0 +1,2 @@
+#define IDI_RXTV 101
+#define IDI_RXVT 102
diff -urN rxvt-2.7.2-orig/W11/wrap/xwrappers.gen rxvt-2.7.2/W11/wrap/xwrappers.gen
--- rxvt-2.7.2-orig/W11/wrap/xwrappers.gen	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/wrap/xwrappers.gen	Mon May 14 10:10:38 2001
@@ -0,0 +1,1127 @@
+
+typedef StatusDef (proto_XAllocColor)( Display *display, Colormap cmap, XColor *xc);
+static proto_XAllocColor *func_XAllocColor = NULL;
+StatusDef XAllocColor( Display *display, Colormap cmap, XColor *xc) {
+	if (!func_XAllocColor) func_XAllocColor=(proto_XAllocColor *)_loadfunc("XAllocColor");
+	return (func_XAllocColor)( display, cmap, xc);
+}
+
+typedef StatusDef (proto_XAllocColorCells)( Display *display, Colormap cmap, BoolDef cont, unsigned long *pmasks, unsigned int np, unsigned long *pixels, unsigned int nc);
+static proto_XAllocColorCells *func_XAllocColorCells = NULL;
+StatusDef XAllocColorCells( Display *display, Colormap cmap, BoolDef cont, unsigned long *pmasks, unsigned int np, unsigned long *pixels, unsigned int nc) {
+	if (!func_XAllocColorCells) func_XAllocColorCells=(proto_XAllocColorCells *)_loadfunc("XAllocColorCells");
+	return (func_XAllocColorCells)( display, cmap, cont, pmasks, np, pixels, nc);
+}
+
+typedef StatusDef (proto_XAllocColorPlanes)( Display *display, Colormap cmap, BoolDef cont, unsigned long *pixels, int nc, int nr,int ng,int nb, unsigned long *rmask, unsigned long *gmask, unsigned long *bmask);
+static proto_XAllocColorPlanes *func_XAllocColorPlanes = NULL;
+StatusDef XAllocColorPlanes( Display *display, Colormap cmap, BoolDef cont, unsigned long *pixels, int nc, int nr,int ng,int nb, unsigned long *rmask, unsigned long *gmask, unsigned long *bmask) {
+	if (!func_XAllocColorPlanes) func_XAllocColorPlanes=(proto_XAllocColorPlanes *)_loadfunc("XAllocColorPlanes");
+	return (func_XAllocColorPlanes)( display, cmap, cont, pixels, nc, nr,ng,nb, rmask, gmask, bmask);
+}
+
+typedef StatusDef (proto_XAllocNamedColor)(Display *display, Colormap cmap, const char *cname, XColor *cell, XColor *rgb);
+static proto_XAllocNamedColor *func_XAllocNamedColor = NULL;
+StatusDef XAllocNamedColor(Display *display, Colormap cmap, const char *cname, XColor *cell, XColor *rgb) {
+	if (!func_XAllocNamedColor) func_XAllocNamedColor=(proto_XAllocNamedColor *)_loadfunc("XAllocNamedColor");
+	return (func_XAllocNamedColor)(display, cmap, cname, cell, rgb);
+}
+
+typedef int (proto_XBell)( Display *display, int pc);
+static proto_XBell *func_XBell = NULL;
+int XBell( Display *display, int pc) {
+	if (!func_XBell) func_XBell=(proto_XBell *)_loadfunc("XBell");
+	return (func_XBell)( display, pc);
+}
+
+typedef int (proto_XChangeGC)( Display* display, GC gc, unsigned long mask, XGCValues* gc_values);
+static proto_XChangeGC *func_XChangeGC = NULL;
+int XChangeGC( Display* display, GC gc, unsigned long mask, XGCValues* gc_values) {
+	if (!func_XChangeGC) func_XChangeGC=(proto_XChangeGC *)_loadfunc("XChangeGC");
+	return (func_XChangeGC)( display, gc, mask, gc_values);
+}
+
+typedef int (proto_XChangeProperty)( Display *display, Window window, Atom property, Atom type, int format, int mode, const unsigned char *data, int nelements);
+static proto_XChangeProperty *func_XChangeProperty = NULL;
+int XChangeProperty( Display *display, Window window, Atom property, Atom type, int format, int mode, const unsigned char *data, int nelements) {
+	if (!func_XChangeProperty) func_XChangeProperty=(proto_XChangeProperty *)_loadfunc("XChangeProperty");
+	return (func_XChangeProperty)( display, window, property, type, format, mode, data, nelements);
+}
+
+typedef int (proto_XChangeWindowAttributes)( Display *display, Window w, unsigned long vmask, XSetWindowAttributes *attr);
+static proto_XChangeWindowAttributes *func_XChangeWindowAttributes = NULL;
+int XChangeWindowAttributes( Display *display, Window w, unsigned long vmask, XSetWindowAttributes *attr) {
+	if (!func_XChangeWindowAttributes) func_XChangeWindowAttributes=(proto_XChangeWindowAttributes *)_loadfunc("XChangeWindowAttributes");
+	return (func_XChangeWindowAttributes)( display, w, vmask, attr);
+}
+
+typedef BoolDef (proto_XCheckTypedEvent)( Display *display, int ev, XEvent *rep);
+static proto_XCheckTypedEvent *func_XCheckTypedEvent = NULL;
+BoolDef XCheckTypedEvent( Display *display, int ev, XEvent *rep) {
+	if (!func_XCheckTypedEvent) func_XCheckTypedEvent=(proto_XCheckTypedEvent *)_loadfunc("XCheckTypedEvent");
+	return (func_XCheckTypedEvent)( display, ev, rep);
+}
+
+typedef BoolDef (proto_XCheckTypedWindowEvent)( Display* display, Window w, int event_type, XEvent* event_return);
+static proto_XCheckTypedWindowEvent *func_XCheckTypedWindowEvent = NULL;
+BoolDef XCheckTypedWindowEvent( Display* display, Window w, int event_type, XEvent* event_return) {
+	if (!func_XCheckTypedWindowEvent) func_XCheckTypedWindowEvent=(proto_XCheckTypedWindowEvent *)_loadfunc("XCheckTypedWindowEvent");
+	return (func_XCheckTypedWindowEvent)( display, w, event_type, event_return);
+}
+
+typedef BoolDef (proto_XCheckWindowEvent)( Display *display, Window w, long emask, XEvent *ev);
+static proto_XCheckWindowEvent *func_XCheckWindowEvent = NULL;
+BoolDef XCheckWindowEvent( Display *display, Window w, long emask, XEvent *ev) {
+	if (!func_XCheckWindowEvent) func_XCheckWindowEvent=(proto_XCheckWindowEvent *)_loadfunc("XCheckWindowEvent");
+	return (func_XCheckWindowEvent)( display, w, emask, ev);
+}
+
+typedef int (proto_XClearArea)( Display *display, Window w, int x, int y, unsigned int width, unsigned int height, BoolDef exposures);
+static proto_XClearArea *func_XClearArea = NULL;
+int XClearArea( Display *display, Window w, int x, int y, unsigned int width, unsigned int height, BoolDef exposures) {
+	if (!func_XClearArea) func_XClearArea=(proto_XClearArea *)_loadfunc("XClearArea");
+	return (func_XClearArea)( display, w, x, y, width, height, exposures);
+}
+
+typedef int (proto_XClearWindow)(Display *display, Window w);
+static proto_XClearWindow *func_XClearWindow = NULL;
+int XClearWindow(Display *display, Window w) {
+	if (!func_XClearWindow) func_XClearWindow=(proto_XClearWindow *)_loadfunc("XClearWindow");
+	return (func_XClearWindow)(display, w);
+}
+
+typedef int (proto_XClipBox)( Region hrgn, XRectangle *rect);
+static proto_XClipBox *func_XClipBox = NULL;
+int XClipBox( Region hrgn, XRectangle *rect) {
+	if (!func_XClipBox) func_XClipBox=(proto_XClipBox *)_loadfunc("XClipBox");
+	return (func_XClipBox)( hrgn, rect);
+}
+
+typedef int (proto_XCloseDisplay)(Display *display);
+static proto_XCloseDisplay *func_XCloseDisplay = NULL;
+int XCloseDisplay(Display *display) {
+	if (!func_XCloseDisplay) func_XCloseDisplay=(proto_XCloseDisplay *)_loadfunc("XCloseDisplay");
+	return (func_XCloseDisplay)(display);
+}
+
+typedef StatusDef (proto_XCloseIM)(XIM im);
+static proto_XCloseIM *func_XCloseIM = NULL;
+StatusDef XCloseIM(XIM im) {
+	if (!func_XCloseIM) func_XCloseIM=(proto_XCloseIM *)_loadfunc("XCloseIM");
+	return (func_XCloseIM)(im);
+}
+
+typedef int (proto_XConnectionNumber)(Display* display);
+static proto_XConnectionNumber *func_XConnectionNumber = NULL;
+int XConnectionNumber(Display* display) {
+	if (!func_XConnectionNumber) func_XConnectionNumber=(proto_XConnectionNumber *)_loadfunc("XConnectionNumber");
+	return (func_XConnectionNumber)(display);
+}
+
+typedef int (proto_XConvertSelection)( Display *display, Atom sel, Atom target, Atom prop, Window req, Time time);
+static proto_XConvertSelection *func_XConvertSelection = NULL;
+int XConvertSelection( Display *display, Atom sel, Atom target, Atom prop, Window req, Time time) {
+	if (!func_XConvertSelection) func_XConvertSelection=(proto_XConvertSelection *)_loadfunc("XConvertSelection");
+	return (func_XConvertSelection)( display, sel, target, prop, req, time);
+}
+
+typedef int (proto_XCopyArea)( Display *display, Drawable src, Drawable dest, GC gc, int src_x, int src_y, unsigned int width, unsigned int height, int dest_x, int dest_y);
+static proto_XCopyArea *func_XCopyArea = NULL;
+int XCopyArea( Display *display, Drawable src, Drawable dest, GC gc, int src_x, int src_y, unsigned int width, unsigned int height, int dest_x, int dest_y) {
+	if (!func_XCopyArea) func_XCopyArea=(proto_XCopyArea *)_loadfunc("XCopyArea");
+	return (func_XCopyArea)( display, src, dest, gc, src_x, src_y, width, height, dest_x, dest_y);
+}
+
+typedef int (proto_XCopyGC)( Display *display, GC sgc, unsigned long vmask, GC dgc);
+static proto_XCopyGC *func_XCopyGC = NULL;
+int XCopyGC( Display *display, GC sgc, unsigned long vmask, GC dgc) {
+	if (!func_XCopyGC) func_XCopyGC=(proto_XCopyGC *)_loadfunc("XCopyGC");
+	return (func_XCopyGC)( display, sgc, vmask, dgc);
+}
+
+typedef Pixmap (proto_XCreateBitmapFromData)(Display *display, Drawable drawable, const char *data, unsigned int width, unsigned int height);
+static proto_XCreateBitmapFromData *func_XCreateBitmapFromData = NULL;
+Pixmap XCreateBitmapFromData(Display *display, Drawable drawable, const char *data, unsigned int width, unsigned int height) {
+	if (!func_XCreateBitmapFromData) func_XCreateBitmapFromData=(proto_XCreateBitmapFromData *)_loadfunc("XCreateBitmapFromData");
+	return (func_XCreateBitmapFromData)(display, drawable, data, width, height);
+}
+
+typedef Colormap (proto_XCreateColormap)( Display *display, Window w, Visual *visual, int alloc);
+static proto_XCreateColormap *func_XCreateColormap = NULL;
+Colormap XCreateColormap( Display *display, Window w, Visual *visual, int alloc) {
+	if (!func_XCreateColormap) func_XCreateColormap=(proto_XCreateColormap *)_loadfunc("XCreateColormap");
+	return (func_XCreateColormap)( display, w, visual, alloc);
+}
+
+typedef Cursor (proto_XCreateFontCursor)( Display *display, unsigned int shape);
+static proto_XCreateFontCursor *func_XCreateFontCursor = NULL;
+Cursor XCreateFontCursor( Display *display, unsigned int shape) {
+	if (!func_XCreateFontCursor) func_XCreateFontCursor=(proto_XCreateFontCursor *)_loadfunc("XCreateFontCursor");
+	return (func_XCreateFontCursor)( display, shape);
+}
+
+typedef GC (proto_XCreateGC)( Display *display, Drawable window, unsigned long mask, XGCValues *gc_values);
+static proto_XCreateGC *func_XCreateGC = NULL;
+GC XCreateGC( Display *display, Drawable window, unsigned long mask, XGCValues *gc_values) {
+	if (!func_XCreateGC) func_XCreateGC=(proto_XCreateGC *)_loadfunc("XCreateGC");
+	return (func_XCreateGC)( display, window, mask, gc_values);
+}
+
+typedef XImage * (proto_XCreateImage)( Display *display, Visual *visual, unsigned int depth, int format, int offset, char *data, unsigned int width, unsigned int height, int bitmap_pad, int bytes_per_line);
+static proto_XCreateImage *func_XCreateImage = NULL;
+XImage * XCreateImage( Display *display, Visual *visual, unsigned int depth, int format, int offset, char *data, unsigned int width, unsigned int height, int bitmap_pad, int bytes_per_line) {
+	if (!func_XCreateImage) func_XCreateImage=(proto_XCreateImage *)_loadfunc("XCreateImage");
+	return (func_XCreateImage)( display, visual, depth, format, offset, data, width, height, bitmap_pad, bytes_per_line);
+}
+
+typedef Pixmap (proto_XCreatePixmap)( Display *display, Drawable drawable, unsigned int width, unsigned int height, unsigned int depth);
+static proto_XCreatePixmap *func_XCreatePixmap = NULL;
+Pixmap XCreatePixmap( Display *display, Drawable drawable, unsigned int width, unsigned int height, unsigned int depth) {
+	if (!func_XCreatePixmap) func_XCreatePixmap=(proto_XCreatePixmap *)_loadfunc("XCreatePixmap");
+	return (func_XCreatePixmap)( display, drawable, width, height, depth);
+}
+
+typedef Region (proto_XCreateRegion)();
+static proto_XCreateRegion *func_XCreateRegion = NULL;
+Region XCreateRegion() {
+	if (!func_XCreateRegion) func_XCreateRegion=(proto_XCreateRegion *)_loadfunc("XCreateRegion");
+	return (func_XCreateRegion)();
+}
+
+typedef Window (proto_XCreateSimpleWindow)( Display *display, Window parent, int x, int y, unsigned int brd, unsigned int w, unsigned int h, unsigned long bg, unsigned long brd_col);
+static proto_XCreateSimpleWindow *func_XCreateSimpleWindow = NULL;
+Window XCreateSimpleWindow( Display *display, Window parent, int x, int y, unsigned int brd, unsigned int w, unsigned int h, unsigned long bg, unsigned long brd_col) {
+	if (!func_XCreateSimpleWindow) func_XCreateSimpleWindow=(proto_XCreateSimpleWindow *)_loadfunc("XCreateSimpleWindow");
+	return (func_XCreateSimpleWindow)( display, parent, x, y, brd, w, h, bg, brd_col);
+}
+
+typedef Window (proto_XCreateWindow)( Display *display, Window parent, int x, int y, unsigned int width, unsigned int height, unsigned int bw, int depth, unsigned int class, Visual *visual, unsigned long valuemask, XSetWindowAttributes *attr);
+static proto_XCreateWindow *func_XCreateWindow = NULL;
+Window XCreateWindow( Display *display, Window parent, int x, int y, unsigned int width, unsigned int height, unsigned int bw, int depth, unsigned int class, Visual *visual, unsigned long valuemask, XSetWindowAttributes *attr) {
+	if (!func_XCreateWindow) func_XCreateWindow=(proto_XCreateWindow *)_loadfunc("XCreateWindow");
+	return (func_XCreateWindow)( display, parent, x, y, width, height, bw, depth, class, visual, valuemask, attr);
+}
+
+typedef Colormap (proto_XDefaultColormap)( Display *display, int screen);
+static proto_XDefaultColormap *func_XDefaultColormap = NULL;
+Colormap XDefaultColormap( Display *display, int screen) {
+	if (!func_XDefaultColormap) func_XDefaultColormap=(proto_XDefaultColormap *)_loadfunc("XDefaultColormap");
+	return (func_XDefaultColormap)( display, screen);
+}
+
+typedef int (proto_XDefaultDepth)( Display *display, int screen);
+static proto_XDefaultDepth *func_XDefaultDepth = NULL;
+int XDefaultDepth( Display *display, int screen) {
+	if (!func_XDefaultDepth) func_XDefaultDepth=(proto_XDefaultDepth *)_loadfunc("XDefaultDepth");
+	return (func_XDefaultDepth)( display, screen);
+}
+
+typedef int (proto_XDefaultScreen)(Display *display);
+static proto_XDefaultScreen *func_XDefaultScreen = NULL;
+int XDefaultScreen(Display *display) {
+	if (!func_XDefaultScreen) func_XDefaultScreen=(proto_XDefaultScreen *)_loadfunc("XDefaultScreen");
+	return (func_XDefaultScreen)(display);
+}
+
+typedef Visual * (proto_XDefaultVisual)( Display *display, int screen);
+static proto_XDefaultVisual *func_XDefaultVisual = NULL;
+Visual * XDefaultVisual( Display *display, int screen) {
+	if (!func_XDefaultVisual) func_XDefaultVisual=(proto_XDefaultVisual *)_loadfunc("XDefaultVisual");
+	return (func_XDefaultVisual)( display, screen);
+}
+
+typedef int (proto_XDefineCursor)(Display* display,Window w,Cursor cursor);
+static proto_XDefineCursor *func_XDefineCursor = NULL;
+int XDefineCursor(Display* display,Window w,Cursor cursor) {
+	if (!func_XDefineCursor) func_XDefineCursor=(proto_XDefineCursor *)_loadfunc("XDefineCursor");
+	return (func_XDefineCursor)(display,w,cursor);
+}
+
+typedef int (proto_XDestroyRegion)(Region hrgn);
+static proto_XDestroyRegion *func_XDestroyRegion = NULL;
+int XDestroyRegion(Region hrgn) {
+	if (!func_XDestroyRegion) func_XDestroyRegion=(proto_XDestroyRegion *)_loadfunc("XDestroyRegion");
+	return (func_XDestroyRegion)(hrgn);
+}
+
+typedef int (proto_XDestroyWindow)( Display *display, Window w);
+static proto_XDestroyWindow *func_XDestroyWindow = NULL;
+int XDestroyWindow( Display *display, Window w) {
+	if (!func_XDestroyWindow) func_XDestroyWindow=(proto_XDestroyWindow *)_loadfunc("XDestroyWindow");
+	return (func_XDestroyWindow)( display, w);
+}
+
+typedef char * (proto_XDisplayString)(Display *display);
+static proto_XDisplayString *func_XDisplayString = NULL;
+char * XDisplayString(Display *display) {
+	if (!func_XDisplayString) func_XDisplayString=(proto_XDisplayString *)_loadfunc("XDisplayString");
+	return (func_XDisplayString)(display);
+}
+
+typedef int (proto_XDoesBackingStore)(Screen *scr);
+static proto_XDoesBackingStore *func_XDoesBackingStore = NULL;
+int XDoesBackingStore(Screen *scr) {
+	if (!func_XDoesBackingStore) func_XDoesBackingStore=(proto_XDoesBackingStore *)_loadfunc("XDoesBackingStore");
+	return (func_XDoesBackingStore)(scr);
+}
+
+typedef int (proto_XDrawArc)( Display *display, Drawable w, GC gc, int x, int y, unsigned int width,unsigned int height, int a1, int a2);
+static proto_XDrawArc *func_XDrawArc = NULL;
+int XDrawArc( Display *display, Drawable w, GC gc, int x, int y, unsigned int width,unsigned int height, int a1, int a2) {
+	if (!func_XDrawArc) func_XDrawArc=(proto_XDrawArc *)_loadfunc("XDrawArc");
+	return (func_XDrawArc)( display, w, gc, x, y, width,height, a1, a2);
+}
+
+typedef int (proto_XDrawImageString)( Display* display, Drawable d, GC gc, int x, int y, const char* string, int length);
+static proto_XDrawImageString *func_XDrawImageString = NULL;
+int XDrawImageString( Display* display, Drawable d, GC gc, int x, int y, const char* string, int length) {
+	if (!func_XDrawImageString) func_XDrawImageString=(proto_XDrawImageString *)_loadfunc("XDrawImageString");
+	return (func_XDrawImageString)( display, d, gc, x, y, string, length);
+}
+
+typedef int (proto_XDrawImageString16)(Display *display, Drawable window, GC gc, int x, int y, const XChar2b* str, int len);
+static proto_XDrawImageString16 *func_XDrawImageString16 = NULL;
+int XDrawImageString16(Display *display, Drawable window, GC gc, int x, int y, const XChar2b* str, int len) {
+	if (!func_XDrawImageString16) func_XDrawImageString16=(proto_XDrawImageString16 *)_loadfunc("XDrawImageString16");
+	return (func_XDrawImageString16)(display, window, gc, x, y, str, len);
+}
+
+typedef int (proto_XDrawLine)( Display *display, Drawable w, GC gc, int x1,int y1, int x2,int y2);
+static proto_XDrawLine *func_XDrawLine = NULL;
+int XDrawLine( Display *display, Drawable w, GC gc, int x1,int y1, int x2,int y2) {
+	if (!func_XDrawLine) func_XDrawLine=(proto_XDrawLine *)_loadfunc("XDrawLine");
+	return (func_XDrawLine)( display, w, gc, x1,y1, x2,y2);
+}
+
+typedef int (proto_XDrawLines)( Display *display, Drawable w, GC gc, XPoint *points, int nps,int mode);
+static proto_XDrawLines *func_XDrawLines = NULL;
+int XDrawLines( Display *display, Drawable w, GC gc, XPoint *points, int nps,int mode) {
+	if (!func_XDrawLines) func_XDrawLines=(proto_XDrawLines *)_loadfunc("XDrawLines");
+	return (func_XDrawLines)( display, w, gc, points, nps,mode);
+}
+
+typedef int (proto_XDrawPoint)( Display *display, Drawable w, GC gc, int x, int y);
+static proto_XDrawPoint *func_XDrawPoint = NULL;
+int XDrawPoint( Display *display, Drawable w, GC gc, int x, int y) {
+	if (!func_XDrawPoint) func_XDrawPoint=(proto_XDrawPoint *)_loadfunc("XDrawPoint");
+	return (func_XDrawPoint)( display, w, gc, x, y);
+}
+
+typedef int (proto_XDrawPoints)( Display *display, Drawable w, GC gc, XPoint *points, int nps, int mode);
+static proto_XDrawPoints *func_XDrawPoints = NULL;
+int XDrawPoints( Display *display, Drawable w, GC gc, XPoint *points, int nps, int mode) {
+	if (!func_XDrawPoints) func_XDrawPoints=(proto_XDrawPoints *)_loadfunc("XDrawPoints");
+	return (func_XDrawPoints)( display, w, gc, points, nps, mode);
+}
+
+typedef int (proto_XDrawRectangle)( Display *display, Drawable w, GC gc, int x, int y, unsigned int width, unsigned int height);
+static proto_XDrawRectangle *func_XDrawRectangle = NULL;
+int XDrawRectangle( Display *display, Drawable w, GC gc, int x, int y, unsigned int width, unsigned int height) {
+	if (!func_XDrawRectangle) func_XDrawRectangle=(proto_XDrawRectangle *)_loadfunc("XDrawRectangle");
+	return (func_XDrawRectangle)( display, w, gc, x, y, width, height);
+}
+
+typedef int (proto_XDrawSegments)( Display *display, Drawable w, GC gc, XSegment *segs, int nsegs);
+static proto_XDrawSegments *func_XDrawSegments = NULL;
+int XDrawSegments( Display *display, Drawable w, GC gc, XSegment *segs, int nsegs) {
+	if (!func_XDrawSegments) func_XDrawSegments=(proto_XDrawSegments *)_loadfunc("XDrawSegments");
+	return (func_XDrawSegments)( display, w, gc, segs, nsegs);
+}
+
+typedef int (proto_XDrawString)(Display *display, Drawable window, GC gc, int x, int y, const char* str, int len);
+static proto_XDrawString *func_XDrawString = NULL;
+int XDrawString(Display *display, Drawable window, GC gc, int x, int y, const char* str, int len) {
+	if (!func_XDrawString) func_XDrawString=(proto_XDrawString *)_loadfunc("XDrawString");
+	return (func_XDrawString)(display, window, gc, x, y, str, len);
+}
+
+typedef int (proto_XDrawString16)(Display *display, Drawable window, GC gc, int x, int y, const XChar2b* str, int len);
+static proto_XDrawString16 *func_XDrawString16 = NULL;
+int XDrawString16(Display *display, Drawable window, GC gc, int x, int y, const XChar2b* str, int len) {
+	if (!func_XDrawString16) func_XDrawString16=(proto_XDrawString16 *)_loadfunc("XDrawString16");
+	return (func_XDrawString16)(display, window, gc, x, y, str, len);
+}
+
+typedef StatusDef (proto_XFetchName)( Display *display, Window w, char **window_name_return);
+static proto_XFetchName *func_XFetchName = NULL;
+StatusDef XFetchName( Display *display, Window w, char **window_name_return) {
+	if (!func_XFetchName) func_XFetchName=(proto_XFetchName *)_loadfunc("XFetchName");
+	return (func_XFetchName)( display, w, window_name_return);
+}
+
+typedef int (proto_XFillArc)( Display *display, Drawable w, GC gc, int x, int y, unsigned int width,unsigned height, int a1, int a2);
+static proto_XFillArc *func_XFillArc = NULL;
+int XFillArc( Display *display, Drawable w, GC gc, int x, int y, unsigned int width,unsigned height, int a1, int a2) {
+	if (!func_XFillArc) func_XFillArc=(proto_XFillArc *)_loadfunc("XFillArc");
+	return (func_XFillArc)( display, w, gc, x, y, width,height, a1, a2);
+}
+
+typedef int (proto_XFillPolygon)( Display *display, Drawable w, GC gc, XPoint *points, int nps, int shape, int mode);
+static proto_XFillPolygon *func_XFillPolygon = NULL;
+int XFillPolygon( Display *display, Drawable w, GC gc, XPoint *points, int nps, int shape, int mode) {
+	if (!func_XFillPolygon) func_XFillPolygon=(proto_XFillPolygon *)_loadfunc("XFillPolygon");
+	return (func_XFillPolygon)( display, w, gc, points, nps, shape, mode);
+}
+
+typedef int (proto_XFillRectangle)( Display *display, Drawable window, GC gc, int x, int y, unsigned int w, unsigned int h);
+static proto_XFillRectangle *func_XFillRectangle = NULL;
+int XFillRectangle( Display *display, Drawable window, GC gc, int x, int y, unsigned int w, unsigned int h) {
+	if (!func_XFillRectangle) func_XFillRectangle=(proto_XFillRectangle *)_loadfunc("XFillRectangle");
+	return (func_XFillRectangle)( display, window, gc, x, y, w, h);
+}
+
+typedef BoolDef (proto_XFilterEvent)(XEvent* event,Window window);
+static proto_XFilterEvent *func_XFilterEvent = NULL;
+BoolDef XFilterEvent(XEvent* event,Window window) {
+	if (!func_XFilterEvent) func_XFilterEvent=(proto_XFilterEvent *)_loadfunc("XFilterEvent");
+	return (func_XFilterEvent)(event,window);
+}
+
+typedef int (proto_XFlush)(Display *display);
+static proto_XFlush *func_XFlush = NULL;
+int XFlush(Display *display) {
+	if (!func_XFlush) func_XFlush=(proto_XFlush *)_loadfunc("XFlush");
+	return (func_XFlush)(display);
+}
+
+typedef int (proto_XFree)(void *data);
+static proto_XFree *func_XFree = NULL;
+int XFree(void *data) {
+	if (!func_XFree) func_XFree=(proto_XFree *)_loadfunc("XFree");
+	return (func_XFree)(data);
+}
+
+typedef int (proto_XFreeColors)(Display *display, Colormap cmap, unsigned long pixels[], int npixels, unsigned long planes);
+static proto_XFreeColors *func_XFreeColors = NULL;
+int XFreeColors(Display *display, Colormap cmap, unsigned long pixels[], int npixels, unsigned long planes) {
+	if (!func_XFreeColors) func_XFreeColors=(proto_XFreeColors *)_loadfunc("XFreeColors");
+	return (func_XFreeColors)(display, cmap, pixels, npixels, planes);
+}
+
+typedef int (proto_XFreeExtensionList)(char **list);
+static proto_XFreeExtensionList *func_XFreeExtensionList = NULL;
+int XFreeExtensionList(char **list) {
+	if (!func_XFreeExtensionList) func_XFreeExtensionList=(proto_XFreeExtensionList *)_loadfunc("XFreeExtensionList");
+	return (func_XFreeExtensionList)(list);
+}
+
+typedef int (proto_XFreeFont)(Display* display,XFontStruct* font_struct);
+static proto_XFreeFont *func_XFreeFont = NULL;
+int XFreeFont(Display* display,XFontStruct* font_struct) {
+	if (!func_XFreeFont) func_XFreeFont=(proto_XFreeFont *)_loadfunc("XFreeFont");
+	return (func_XFreeFont)(display,font_struct);
+}
+
+typedef int (proto_XFreeGC)( Display *display, GC gc);
+static proto_XFreeGC *func_XFreeGC = NULL;
+int XFreeGC( Display *display, GC gc) {
+	if (!func_XFreeGC) func_XFreeGC=(proto_XFreeGC *)_loadfunc("XFreeGC");
+	return (func_XFreeGC)( display, gc);
+}
+
+typedef int (proto_XFreeModifiermap)(XModifierKeymap *modmap);
+static proto_XFreeModifiermap *func_XFreeModifiermap = NULL;
+int XFreeModifiermap(XModifierKeymap *modmap) {
+	if (!func_XFreeModifiermap) func_XFreeModifiermap=(proto_XFreeModifiermap *)_loadfunc("XFreeModifiermap");
+	return (func_XFreeModifiermap)(modmap);
+}
+
+typedef int (proto_XFreePixmap)( Display *display, Pixmap pixmap);
+static proto_XFreePixmap *func_XFreePixmap = NULL;
+int XFreePixmap( Display *display, Pixmap pixmap) {
+	if (!func_XFreePixmap) func_XFreePixmap=(proto_XFreePixmap *)_loadfunc("XFreePixmap");
+	return (func_XFreePixmap)( display, pixmap);
+}
+
+typedef char * (proto_XGetAtomName)( Display *display, Atom atom);
+static proto_XGetAtomName *func_XGetAtomName = NULL;
+char * XGetAtomName( Display *display, Atom atom) {
+	if (!func_XGetAtomName) func_XGetAtomName=(proto_XGetAtomName *)_loadfunc("XGetAtomName");
+	return (func_XGetAtomName)( display, atom);
+}
+
+typedef int (proto_XGetErrorDatabaseText)( Display *display, const char *name, const char *msg, const char *defstr, char *buf, int len);
+static proto_XGetErrorDatabaseText *func_XGetErrorDatabaseText = NULL;
+int XGetErrorDatabaseText( Display *display, const char *name, const char *msg, const char *defstr, char *buf, int len) {
+	if (!func_XGetErrorDatabaseText) func_XGetErrorDatabaseText=(proto_XGetErrorDatabaseText *)_loadfunc("XGetErrorDatabaseText");
+	return (func_XGetErrorDatabaseText)( display, name, msg, defstr, buf, len);
+}
+
+typedef int (proto_XGetErrorText)( Display *display, int code, char *buf, int len);
+static proto_XGetErrorText *func_XGetErrorText = NULL;
+int XGetErrorText( Display *display, int code, char *buf, int len) {
+	if (!func_XGetErrorText) func_XGetErrorText=(proto_XGetErrorText *)_loadfunc("XGetErrorText");
+	return (func_XGetErrorText)( display, code, buf, len);
+}
+
+typedef char ** (proto_XGetFontPath)( Display *display, int *nps);
+static proto_XGetFontPath *func_XGetFontPath = NULL;
+char ** XGetFontPath( Display *display, int *nps) {
+	if (!func_XGetFontPath) func_XGetFontPath=(proto_XGetFontPath *)_loadfunc("XGetFontPath");
+	return (func_XGetFontPath)( display, nps);
+}
+
+typedef BoolDef (proto_XGetFontProperty)( XFontStruct *fstruct, Atom atom, unsigned long *val);
+static proto_XGetFontProperty *func_XGetFontProperty = NULL;
+BoolDef XGetFontProperty( XFontStruct *fstruct, Atom atom, unsigned long *val) {
+	if (!func_XGetFontProperty) func_XGetFontProperty=(proto_XGetFontProperty *)_loadfunc("XGetFontProperty");
+	return (func_XGetFontProperty)( fstruct, atom, val);
+}
+
+typedef StatusDef (proto_XGetGeometry)( Display *display, Drawable w, Window *root, int *x, int *y, unsigned int *width, unsigned int *height, unsigned int *bw, unsigned int *depth);
+static proto_XGetGeometry *func_XGetGeometry = NULL;
+StatusDef XGetGeometry( Display *display, Drawable w, Window *root, int *x, int *y, unsigned int *width, unsigned int *height, unsigned int *bw, unsigned int *depth) {
+	if (!func_XGetGeometry) func_XGetGeometry=(proto_XGetGeometry *)_loadfunc("XGetGeometry");
+	return (func_XGetGeometry)( display, w, root, x, y, width, height, bw, depth);
+}
+
+typedef int (proto_XGetIconName)( Display *display, Window w, char **iname);
+static proto_XGetIconName *func_XGetIconName = NULL;
+int XGetIconName( Display *display, Window w, char **iname) {
+	if (!func_XGetIconName) func_XGetIconName=(proto_XGetIconName *)_loadfunc("XGetIconName");
+	return (func_XGetIconName)( display, w, iname);
+}
+
+typedef XImage * (proto_XGetImage)( Display *display, Drawable drawable, int x, int y, unsigned int width, unsigned int height, unsigned long plane_mask, int format);
+static proto_XGetImage *func_XGetImage = NULL;
+XImage * XGetImage( Display *display, Drawable drawable, int x, int y, unsigned int width, unsigned int height, unsigned long plane_mask, int format) {
+	if (!func_XGetImage) func_XGetImage=(proto_XGetImage *)_loadfunc("XGetImage");
+	return (func_XGetImage)( display, drawable, x, y, width, height, plane_mask, format);
+}
+
+typedef int (proto_XGetInputFocus)( Display *display, Window *focus, int *revto);
+static proto_XGetInputFocus *func_XGetInputFocus = NULL;
+int XGetInputFocus( Display *display, Window *focus, int *revto) {
+	if (!func_XGetInputFocus) func_XGetInputFocus=(proto_XGetInputFocus *)_loadfunc("XGetInputFocus");
+	return (func_XGetInputFocus)( display, focus, revto);
+}
+
+typedef XModifierKeymap * (proto_XGetModifierMapping)(Display *display);
+static proto_XGetModifierMapping *func_XGetModifierMapping = NULL;
+XModifierKeymap * XGetModifierMapping(Display *display) {
+	if (!func_XGetModifierMapping) func_XGetModifierMapping=(proto_XGetModifierMapping *)_loadfunc("XGetModifierMapping");
+	return (func_XGetModifierMapping)(display);
+}
+
+typedef Window (proto_XGetSelectionOwner)( Display* display, Atom selection);
+static proto_XGetSelectionOwner *func_XGetSelectionOwner = NULL;
+Window XGetSelectionOwner( Display* display, Atom selection) {
+	if (!func_XGetSelectionOwner) func_XGetSelectionOwner=(proto_XGetSelectionOwner *)_loadfunc("XGetSelectionOwner");
+	return (func_XGetSelectionOwner)( display, selection);
+}
+
+typedef StatusDef (proto_XGetStandardColormap)( Display *display, Window w, XStandardColormap *cmapinf, Atom prop);
+static proto_XGetStandardColormap *func_XGetStandardColormap = NULL;
+StatusDef XGetStandardColormap( Display *display, Window w, XStandardColormap *cmapinf, Atom prop) {
+	if (!func_XGetStandardColormap) func_XGetStandardColormap=(proto_XGetStandardColormap *)_loadfunc("XGetStandardColormap");
+	return (func_XGetStandardColormap)( display, w, cmapinf, prop);
+}
+
+typedef XVisualInfo * (proto_XGetVisualInfo)( Display *display, long vinm, XVisualInfo *vint, int *n);
+static proto_XGetVisualInfo *func_XGetVisualInfo = NULL;
+XVisualInfo * XGetVisualInfo( Display *display, long vinm, XVisualInfo *vint, int *n) {
+	if (!func_XGetVisualInfo) func_XGetVisualInfo=(proto_XGetVisualInfo *)_loadfunc("XGetVisualInfo");
+	return (func_XGetVisualInfo)( display, vinm, vint, n);
+}
+
+typedef StatusDef (proto_XGetWindowAttributes)(Display *display, Window w, XWindowAttributes *wattr);
+static proto_XGetWindowAttributes *func_XGetWindowAttributes = NULL;
+StatusDef XGetWindowAttributes(Display *display, Window w, XWindowAttributes *wattr) {
+	if (!func_XGetWindowAttributes) func_XGetWindowAttributes=(proto_XGetWindowAttributes *)_loadfunc("XGetWindowAttributes");
+	return (func_XGetWindowAttributes)(display, w, wattr);
+}
+
+typedef int (proto_XGetWindowProperty)( Display *display, Window window, Atom property, long long_offset, long long_length, BoolDef delete, Atom req_type, Atom *actual_type_return, int *actual_format_return, unsigned long *nitems_return, unsigned long *bytes_after_return, unsigned char **prop_return);
+static proto_XGetWindowProperty *func_XGetWindowProperty = NULL;
+int XGetWindowProperty( Display *display, Window window, Atom property, long long_offset, long long_length, BoolDef delete, Atom req_type, Atom *actual_type_return, int *actual_format_return, unsigned long *nitems_return, unsigned long *bytes_after_return, unsigned char **prop_return) {
+	if (!func_XGetWindowProperty) func_XGetWindowProperty=(proto_XGetWindowProperty *)_loadfunc("XGetWindowProperty");
+	return (func_XGetWindowProperty)( display, window, property, long_offset, long_length, delete, req_type, actual_type_return, actual_format_return, nitems_return, bytes_after_return, prop_return);
+}
+
+typedef int (proto_XGrabServer)(Display *display);
+static proto_XGrabServer *func_XGrabServer = NULL;
+int XGrabServer(Display *display) {
+	if (!func_XGrabServer) func_XGrabServer=(proto_XGrabServer *)_loadfunc("XGrabServer");
+	return (func_XGrabServer)(display);
+}
+
+typedef int (proto_XIconifyWindow)(Display *display, Window w, int screen_number);
+static proto_XIconifyWindow *func_XIconifyWindow = NULL;
+int XIconifyWindow(Display *display, Window w, int screen_number) {
+	if (!func_XIconifyWindow) func_XIconifyWindow=(proto_XIconifyWindow *)_loadfunc("XIconifyWindow");
+	return (func_XIconifyWindow)(display, w, screen_number);
+}
+
+typedef XExtCodes * (proto_XInitExtension)(Display *display, const char *name);
+static proto_XInitExtension *func_XInitExtension = NULL;
+XExtCodes * XInitExtension(Display *display, const char *name) {
+	if (!func_XInitExtension) func_XInitExtension=(proto_XInitExtension *)_loadfunc("XInitExtension");
+	return (func_XInitExtension)(display, name);
+}
+
+typedef Atom (proto_XInternAtom)( Display *display, const char *property_name, BoolDef only_if_exists);
+static proto_XInternAtom *func_XInternAtom = NULL;
+Atom XInternAtom( Display *display, const char *property_name, BoolDef only_if_exists) {
+	if (!func_XInternAtom) func_XInternAtom=(proto_XInternAtom *)_loadfunc("XInternAtom");
+	return (func_XInternAtom)( display, property_name, only_if_exists);
+}
+
+typedef KeySym (proto_XKeycodeToKeysym)( Display *display, unsigned int keycode, int index);
+static proto_XKeycodeToKeysym *func_XKeycodeToKeysym = NULL;
+KeySym XKeycodeToKeysym( Display *display, unsigned int keycode, int index) {
+	if (!func_XKeycodeToKeysym) func_XKeycodeToKeysym=(proto_XKeycodeToKeysym *)_loadfunc("XKeycodeToKeysym");
+	return (func_XKeycodeToKeysym)( display, keycode, index);
+}
+
+typedef KeyCode (proto_XKeysymToKeycode)( Display *display, KeySym keysym);
+static proto_XKeysymToKeycode *func_XKeysymToKeycode = NULL;
+KeyCode XKeysymToKeycode( Display *display, KeySym keysym) {
+	if (!func_XKeysymToKeycode) func_XKeysymToKeycode=(proto_XKeysymToKeycode *)_loadfunc("XKeysymToKeycode");
+	return (func_XKeysymToKeycode)( display, keysym);
+}
+
+typedef char ** (proto_XListExtensions)( Display *display, int *ret_num);
+static proto_XListExtensions *func_XListExtensions = NULL;
+char ** XListExtensions( Display *display, int *ret_num) {
+	if (!func_XListExtensions) func_XListExtensions=(proto_XListExtensions *)_loadfunc("XListExtensions");
+	return (func_XListExtensions)( display, ret_num);
+}
+
+typedef XFontStruct * (proto_XLoadQueryFont)(Display *display, const char *name);
+static proto_XLoadQueryFont *func_XLoadQueryFont = NULL;
+XFontStruct * XLoadQueryFont(Display *display, const char *name) {
+	if (!func_XLoadQueryFont) func_XLoadQueryFont=(proto_XLoadQueryFont *)_loadfunc("XLoadQueryFont");
+	return (func_XLoadQueryFont)(display, name);
+}
+
+typedef int (proto_XLookupString)( XKeyEvent *event, char *buf, int nbytes, KeySym *keysym, XComposeStatus *status);
+static proto_XLookupString *func_XLookupString = NULL;
+int XLookupString( XKeyEvent *event, char *buf, int nbytes, KeySym *keysym, XComposeStatus *status) {
+	if (!func_XLookupString) func_XLookupString=(proto_XLookupString *)_loadfunc("XLookupString");
+	return (func_XLookupString)( event, buf, nbytes, keysym, status);
+}
+
+typedef int (proto_XLowerWindow)(Display *display, Window w);
+static proto_XLowerWindow *func_XLowerWindow = NULL;
+int XLowerWindow(Display *display, Window w) {
+	if (!func_XLowerWindow) func_XLowerWindow=(proto_XLowerWindow *)_loadfunc("XLowerWindow");
+	return (func_XLowerWindow)(display, w);
+}
+
+typedef int (proto_XMapRaised)( Display *display, Window w);
+static proto_XMapRaised *func_XMapRaised = NULL;
+int XMapRaised( Display *display, Window w) {
+	if (!func_XMapRaised) func_XMapRaised=(proto_XMapRaised *)_loadfunc("XMapRaised");
+	return (func_XMapRaised)( display, w);
+}
+
+typedef int (proto_XMapSubwindows)( Display *display, Window w);
+static proto_XMapSubwindows *func_XMapSubwindows = NULL;
+int XMapSubwindows( Display *display, Window w) {
+	if (!func_XMapSubwindows) func_XMapSubwindows=(proto_XMapSubwindows *)_loadfunc("XMapSubwindows");
+	return (func_XMapSubwindows)( display, w);
+}
+
+typedef int (proto_XMapWindow)(Display *display, Window window);
+static proto_XMapWindow *func_XMapWindow = NULL;
+int XMapWindow(Display *display, Window window) {
+	if (!func_XMapWindow) func_XMapWindow=(proto_XMapWindow *)_loadfunc("XMapWindow");
+	return (func_XMapWindow)(display, window);
+}
+
+typedef StatusDef (proto_XMatchVisualInfo)( Display* display, int screen, int depth, int class, XVisualInfo* vinfo_return);
+static proto_XMatchVisualInfo *func_XMatchVisualInfo = NULL;
+StatusDef XMatchVisualInfo( Display* display, int screen, int depth, int class, XVisualInfo* vinfo_return) {
+	if (!func_XMatchVisualInfo) func_XMatchVisualInfo=(proto_XMatchVisualInfo *)_loadfunc("XMatchVisualInfo");
+	return (func_XMatchVisualInfo)( display, screen, depth, class, vinfo_return);
+}
+
+typedef int (proto_XMoveResizeWindow)( Display* display, Window w, int x, int y, unsigned int width, unsigned int height);
+static proto_XMoveResizeWindow *func_XMoveResizeWindow = NULL;
+int XMoveResizeWindow( Display* display, Window w, int x, int y, unsigned int width, unsigned int height) {
+	if (!func_XMoveResizeWindow) func_XMoveResizeWindow=(proto_XMoveResizeWindow *)_loadfunc("XMoveResizeWindow");
+	return (func_XMoveResizeWindow)( display, w, x, y, width, height);
+}
+
+typedef int (proto_XMoveWindow)( Display* display, Window w, int x, int y);
+static proto_XMoveWindow *func_XMoveWindow = NULL;
+int XMoveWindow( Display* display, Window w, int x, int y) {
+	if (!func_XMoveWindow) func_XMoveWindow=(proto_XMoveWindow *)_loadfunc("XMoveWindow");
+	return (func_XMoveWindow)( display, w, x, y);
+}
+
+typedef int (proto_XNextEvent)( Display *display, XEvent *event);
+static proto_XNextEvent *func_XNextEvent = NULL;
+int XNextEvent( Display *display, XEvent *event) {
+	if (!func_XNextEvent) func_XNextEvent=(proto_XNextEvent *)_loadfunc("XNextEvent");
+	return (func_XNextEvent)( display, event);
+}
+
+typedef XIM (proto_XOpenIM)( Display* dpy, struct _XrmHashBucketRec* rdb, char* res_name, char* res_class);
+static proto_XOpenIM *func_XOpenIM = NULL;
+XIM XOpenIM( Display* dpy, struct _XrmHashBucketRec* rdb, char* res_name, char* res_class) {
+	if (!func_XOpenIM) func_XOpenIM=(proto_XOpenIM *)_loadfunc("XOpenIM");
+	return (func_XOpenIM)( dpy, rdb, res_name, res_class);
+}
+
+typedef StatusDef (proto_XParseColor)( Display *display, Colormap map, const char* spec, XColor *colorPtr);
+static proto_XParseColor *func_XParseColor = NULL;
+StatusDef XParseColor( Display *display, Colormap map, const char* spec, XColor *colorPtr) {
+	if (!func_XParseColor) func_XParseColor=(proto_XParseColor *)_loadfunc("XParseColor");
+	return (func_XParseColor)( display, map, spec, colorPtr);
+}
+
+typedef int (proto_XParseGeometry)( const char* string, int* x, int* y, unsigned int* width, unsigned int* height);
+static proto_XParseGeometry *func_XParseGeometry = NULL;
+int XParseGeometry( const char* string, int* x, int* y, unsigned int* width, unsigned int* height) {
+	if (!func_XParseGeometry) func_XParseGeometry=(proto_XParseGeometry *)_loadfunc("XParseGeometry");
+	return (func_XParseGeometry)( string, x, y, width, height);
+}
+
+typedef int (proto_XPending)(Display *display);
+static proto_XPending *func_XPending = NULL;
+int XPending(Display *display) {
+	if (!func_XPending) func_XPending=(proto_XPending *)_loadfunc("XPending");
+	return (func_XPending)(display);
+}
+
+typedef int (proto_XPutBackEvent)(Display *display, XEvent *event);
+static proto_XPutBackEvent *func_XPutBackEvent = NULL;
+int XPutBackEvent(Display *display, XEvent *event) {
+	if (!func_XPutBackEvent) func_XPutBackEvent=(proto_XPutBackEvent *)_loadfunc("XPutBackEvent");
+	return (func_XPutBackEvent)(display, event);
+}
+
+typedef int (proto_XPutImage)( Display *display, Drawable w, GC gc, XImage *image, int sx,int sy,int dx,int dy, unsigned int width,unsigned int height);
+static proto_XPutImage *func_XPutImage = NULL;
+int XPutImage( Display *display, Drawable w, GC gc, XImage *image, int sx,int sy,int dx,int dy, unsigned int width,unsigned int height) {
+	if (!func_XPutImage) func_XPutImage=(proto_XPutImage *)_loadfunc("XPutImage");
+	return (func_XPutImage)( display, w, gc, image, sx,sy,dx,dy, width,height);
+}
+
+typedef int (proto_XQueryColor)( Display *display, Colormap cmap, XColor *cell);
+static proto_XQueryColor *func_XQueryColor = NULL;
+int XQueryColor( Display *display, Colormap cmap, XColor *cell) {
+	if (!func_XQueryColor) func_XQueryColor=(proto_XQueryColor *)_loadfunc("XQueryColor");
+	return (func_XQueryColor)( display, cmap, cell);
+}
+
+typedef int (proto_XQueryColors)( Display *display, Colormap cmap, XColor *cells, int nc);
+static proto_XQueryColors *func_XQueryColors = NULL;
+int XQueryColors( Display *display, Colormap cmap, XColor *cells, int nc) {
+	if (!func_XQueryColors) func_XQueryColors=(proto_XQueryColors *)_loadfunc("XQueryColors");
+	return (func_XQueryColors)( display, cmap, cells, nc);
+}
+
+typedef XFontStruct * (proto_XQueryFont)( Display *display, XID font_id);
+static proto_XQueryFont *func_XQueryFont = NULL;
+XFontStruct * XQueryFont( Display *display, XID font_id) {
+	if (!func_XQueryFont) func_XQueryFont=(proto_XQueryFont *)_loadfunc("XQueryFont");
+	return (func_XQueryFont)( display, font_id);
+}
+
+typedef BoolDef (proto_XQueryPointer)( Display* display, Window w, Window* root_return, Window* child_return, int* root_x_return, int* root_y_return, int* win_x_return, int* win_y_return, unsigned int* mask_return);
+static proto_XQueryPointer *func_XQueryPointer = NULL;
+BoolDef XQueryPointer( Display* display, Window w, Window* root_return, Window* child_return, int* root_x_return, int* root_y_return, int* win_x_return, int* win_y_return, unsigned int* mask_return) {
+	if (!func_XQueryPointer) func_XQueryPointer=(proto_XQueryPointer *)_loadfunc("XQueryPointer");
+	return (func_XQueryPointer)( display, w, root_return, child_return, root_x_return, root_y_return, win_x_return, win_y_return, mask_return);
+}
+
+typedef StatusDef (proto_XQueryTree)( Display *display, Window w, Window* root, Window* parent, Window** ch, unsigned int *n);
+static proto_XQueryTree *func_XQueryTree = NULL;
+StatusDef XQueryTree( Display *display, Window w, Window* root, Window* parent, Window** ch, unsigned int *n) {
+	if (!func_XQueryTree) func_XQueryTree=(proto_XQueryTree *)_loadfunc("XQueryTree");
+	return (func_XQueryTree)( display, w, root, parent, ch, n);
+}
+
+typedef int (proto_XRaiseWindow)( Display *display, Window w);
+static proto_XRaiseWindow *func_XRaiseWindow = NULL;
+int XRaiseWindow( Display *display, Window w) {
+	if (!func_XRaiseWindow) func_XRaiseWindow=(proto_XRaiseWindow *)_loadfunc("XRaiseWindow");
+	return (func_XRaiseWindow)( display, w);
+}
+
+typedef int (proto_XRecolorCursor)( Display *display, Cursor cursor, XColor *fg,XColor *bg);
+static proto_XRecolorCursor *func_XRecolorCursor = NULL;
+int XRecolorCursor( Display *display, Cursor cursor, XColor *fg,XColor *bg) {
+	if (!func_XRecolorCursor) func_XRecolorCursor=(proto_XRecolorCursor *)_loadfunc("XRecolorCursor");
+	return (func_XRecolorCursor)( display, cursor, fg,bg);
+}
+
+typedef int (proto_XRefreshKeyboardMapping)(XMappingEvent *event);
+static proto_XRefreshKeyboardMapping *func_XRefreshKeyboardMapping = NULL;
+int XRefreshKeyboardMapping(XMappingEvent *event) {
+	if (!func_XRefreshKeyboardMapping) func_XRefreshKeyboardMapping=(proto_XRefreshKeyboardMapping *)_loadfunc("XRefreshKeyboardMapping");
+	return (func_XRefreshKeyboardMapping)(event);
+}
+
+typedef int (proto_XResizeWindow)( Display* display, Window w, unsigned int width, unsigned int height);
+static proto_XResizeWindow *func_XResizeWindow = NULL;
+int XResizeWindow( Display* display, Window w, unsigned int width, unsigned int height) {
+	if (!func_XResizeWindow) func_XResizeWindow=(proto_XResizeWindow *)_loadfunc("XResizeWindow");
+	return (func_XResizeWindow)( display, w, width, height);
+}
+
+typedef Window (proto_XRootWindow)( Display *display, int scr);
+static proto_XRootWindow *func_XRootWindow = NULL;
+Window XRootWindow( Display *display, int scr) {
+	if (!func_XRootWindow) func_XRootWindow=(proto_XRootWindow *)_loadfunc("XRootWindow");
+	return (func_XRootWindow)( display, scr);
+}
+
+typedef Window (proto_XRootWindowOfScreen)(Screen *scr);
+static proto_XRootWindowOfScreen *func_XRootWindowOfScreen = NULL;
+Window XRootWindowOfScreen(Screen *scr) {
+	if (!func_XRootWindowOfScreen) func_XRootWindowOfScreen=(proto_XRootWindowOfScreen *)_loadfunc("XRootWindowOfScreen");
+	return (func_XRootWindowOfScreen)(scr);
+}
+
+typedef Screen * (proto_XScreenOfDisplay)( Display *display, int scr);
+static proto_XScreenOfDisplay *func_XScreenOfDisplay = NULL;
+Screen * XScreenOfDisplay( Display *display, int scr) {
+	if (!func_XScreenOfDisplay) func_XScreenOfDisplay=(proto_XScreenOfDisplay *)_loadfunc("XScreenOfDisplay");
+	return (func_XScreenOfDisplay)( display, scr);
+}
+
+typedef int (proto_XSelectInput)(Display *display, Window window, long mask);
+static proto_XSelectInput *func_XSelectInput = NULL;
+int XSelectInput(Display *display, Window window, long mask) {
+	if (!func_XSelectInput) func_XSelectInput=(proto_XSelectInput *)_loadfunc("XSelectInput");
+	return (func_XSelectInput)(display, window, mask);
+}
+
+typedef StatusDef (proto_XSendEvent)( Display *display, Window w, BoolDef prop, long emask, XEvent *event);
+static proto_XSendEvent *func_XSendEvent = NULL;
+StatusDef XSendEvent( Display *display, Window w, BoolDef prop, long emask, XEvent *event) {
+	if (!func_XSendEvent) func_XSendEvent=(proto_XSendEvent *)_loadfunc("XSendEvent");
+	return (func_XSendEvent)( display, w, prop, emask, event);
+}
+
+typedef char * (proto_XServerVendor)(Display *display);
+static proto_XServerVendor *func_XServerVendor = NULL;
+char * XServerVendor(Display *display) {
+	if (!func_XServerVendor) func_XServerVendor=(proto_XServerVendor *)_loadfunc("XServerVendor");
+	return (func_XServerVendor)(display);
+}
+
+typedef int (proto_XSetClassHint)( Display *display, Window w, XClassHint *chints);
+static proto_XSetClassHint *func_XSetClassHint = NULL;
+int XSetClassHint( Display *display, Window w, XClassHint *chints) {
+	if (!func_XSetClassHint) func_XSetClassHint=(proto_XSetClassHint *)_loadfunc("XSetClassHint");
+	return (func_XSetClassHint)( display, w, chints);
+}
+
+typedef int (proto_XSetClipMask)( Display *display, GC gc, Pixmap cmask);
+static proto_XSetClipMask *func_XSetClipMask = NULL;
+int XSetClipMask( Display *display, GC gc, Pixmap cmask) {
+	if (!func_XSetClipMask) func_XSetClipMask=(proto_XSetClipMask *)_loadfunc("XSetClipMask");
+	return (func_XSetClipMask)( display, gc, cmask);
+}
+
+typedef int (proto_XSetClipRectangles)( Display *display, GC gc, int clx, int cly, XRectangle *rs, int n, int order);
+static proto_XSetClipRectangles *func_XSetClipRectangles = NULL;
+int XSetClipRectangles( Display *display, GC gc, int clx, int cly, XRectangle *rs, int n, int order) {
+	if (!func_XSetClipRectangles) func_XSetClipRectangles=(proto_XSetClipRectangles *)_loadfunc("XSetClipRectangles");
+	return (func_XSetClipRectangles)( display, gc, clx, cly, rs, n, order);
+}
+
+typedef int (proto_XSetDashes)(Display *display, GC gc, int dash_offset, const char * dash_list, int n);
+static proto_XSetDashes *func_XSetDashes = NULL;
+int XSetDashes(Display *display, GC gc, int dash_offset, const char * dash_list, int n) {
+	if (!func_XSetDashes) func_XSetDashes=(proto_XSetDashes *)_loadfunc("XSetDashes");
+	return (func_XSetDashes)(display, gc, dash_offset, dash_list, n);
+}
+
+typedef XErrorHandler (proto_XSetErrorHandler)(XErrorHandler handler);
+static proto_XSetErrorHandler *func_XSetErrorHandler = NULL;
+XErrorHandler XSetErrorHandler(XErrorHandler handler) {
+	if (!func_XSetErrorHandler) func_XSetErrorHandler=(proto_XSetErrorHandler *)_loadfunc("XSetErrorHandler");
+	return (func_XSetErrorHandler)(handler);
+}
+
+typedef int (proto_XSetFillStyle)( Display *display, GC gc, int fs);
+static proto_XSetFillStyle *func_XSetFillStyle = NULL;
+int XSetFillStyle( Display *display, GC gc, int fs) {
+	if (!func_XSetFillStyle) func_XSetFillStyle=(proto_XSetFillStyle *)_loadfunc("XSetFillStyle");
+	return (func_XSetFillStyle)( display, gc, fs);
+}
+
+typedef int (proto_XSetFont)( Display *display, GC gc, Font font);
+static proto_XSetFont *func_XSetFont = NULL;
+int XSetFont( Display *display, GC gc, Font font) {
+	if (!func_XSetFont) func_XSetFont=(proto_XSetFont *)_loadfunc("XSetFont");
+	return (func_XSetFont)( display, gc, font);
+}
+
+typedef int (proto_XSetFontPath)( Display *display, char **dirs, int nd);
+static proto_XSetFontPath *func_XSetFontPath = NULL;
+int XSetFontPath( Display *display, char **dirs, int nd) {
+	if (!func_XSetFontPath) func_XSetFontPath=(proto_XSetFontPath *)_loadfunc("XSetFontPath");
+	return (func_XSetFontPath)( display, dirs, nd);
+}
+
+typedef int (proto_XSetForeground)( Display *display, GC gc, unsigned long color);
+static proto_XSetForeground *func_XSetForeground = NULL;
+int XSetForeground( Display *display, GC gc, unsigned long color) {
+	if (!func_XSetForeground) func_XSetForeground=(proto_XSetForeground *)_loadfunc("XSetForeground");
+	return (func_XSetForeground)( display, gc, color);
+}
+
+typedef int (proto_XSetFunction)( Display *display, GC gc, int fn);
+static proto_XSetFunction *func_XSetFunction = NULL;
+int XSetFunction( Display *display, GC gc, int fn) {
+	if (!func_XSetFunction) func_XSetFunction=(proto_XSetFunction *)_loadfunc("XSetFunction");
+	return (func_XSetFunction)( display, gc, fn);
+}
+
+typedef void (proto_XSetICFocus)(XIC ic);
+static proto_XSetICFocus *func_XSetICFocus = NULL;
+void XSetICFocus(XIC ic) {
+	if (!func_XSetICFocus) func_XSetICFocus=(proto_XSetICFocus *)_loadfunc("XSetICFocus");
+	(func_XSetICFocus)(ic);
+}
+
+typedef int (proto_XSetIconName)(Display *display, Window w, const char *iname);
+static proto_XSetIconName *func_XSetIconName = NULL;
+int XSetIconName(Display *display, Window w, const char *iname) {
+	if (!func_XSetIconName) func_XSetIconName=(proto_XSetIconName *)_loadfunc("XSetIconName");
+	return (func_XSetIconName)(display, w, iname);
+}
+
+typedef int (proto_XSetInputFocus)( Display *display, Window focus, int revto, Time time);
+static proto_XSetInputFocus *func_XSetInputFocus = NULL;
+int XSetInputFocus( Display *display, Window focus, int revto, Time time) {
+	if (!func_XSetInputFocus) func_XSetInputFocus=(proto_XSetInputFocus *)_loadfunc("XSetInputFocus");
+	return (func_XSetInputFocus)( display, focus, revto, time);
+}
+
+typedef int (proto_XSetLineAttributes)( Display *display, GC gc, unsigned int lw, int ls, int cs, int js);
+static proto_XSetLineAttributes *func_XSetLineAttributes = NULL;
+int XSetLineAttributes( Display *display, GC gc, unsigned int lw, int ls, int cs, int js) {
+	if (!func_XSetLineAttributes) func_XSetLineAttributes=(proto_XSetLineAttributes *)_loadfunc("XSetLineAttributes");
+	return (func_XSetLineAttributes)( display, gc, lw, ls, cs, js);
+}
+
+typedef char * (proto_XSetLocaleModifiers)(const char* modifier_list);
+static proto_XSetLocaleModifiers *func_XSetLocaleModifiers = NULL;
+char * XSetLocaleModifiers(const char* modifier_list) {
+	if (!func_XSetLocaleModifiers) func_XSetLocaleModifiers=(proto_XSetLocaleModifiers *)_loadfunc("XSetLocaleModifiers");
+	return (func_XSetLocaleModifiers)(modifier_list);
+}
+
+typedef int (proto_XSetNormalHints)( Display *display, Window w, XSizeHints *hints);
+static proto_XSetNormalHints *func_XSetNormalHints = NULL;
+int XSetNormalHints( Display *display, Window w, XSizeHints *hints) {
+	if (!func_XSetNormalHints) func_XSetNormalHints=(proto_XSetNormalHints *)_loadfunc("XSetNormalHints");
+	return (func_XSetNormalHints)( display, w, hints);
+}
+
+typedef int (proto_XSetPlaneMask)( Display *display, GC gc, unsigned long pmask);
+static proto_XSetPlaneMask *func_XSetPlaneMask = NULL;
+int XSetPlaneMask( Display *display, GC gc, unsigned long pmask) {
+	if (!func_XSetPlaneMask) func_XSetPlaneMask=(proto_XSetPlaneMask *)_loadfunc("XSetPlaneMask");
+	return (func_XSetPlaneMask)( display, gc, pmask);
+}
+
+typedef int (proto_XSetRegion)( Display *display, GC gc, Region hrgn);
+static proto_XSetRegion *func_XSetRegion = NULL;
+int XSetRegion( Display *display, GC gc, Region hrgn) {
+	if (!func_XSetRegion) func_XSetRegion=(proto_XSetRegion *)_loadfunc("XSetRegion");
+	return (func_XSetRegion)( display, gc, hrgn);
+}
+
+typedef int (proto_XSetSelectionOwner)( Display* display, Atom sel, Window owner, Time time);
+static proto_XSetSelectionOwner *func_XSetSelectionOwner = NULL;
+int XSetSelectionOwner( Display* display, Atom sel, Window owner, Time time) {
+	if (!func_XSetSelectionOwner) func_XSetSelectionOwner=(proto_XSetSelectionOwner *)_loadfunc("XSetSelectionOwner");
+	return (func_XSetSelectionOwner)( display, sel, owner, time);
+}
+
+typedef int (proto_XSetTile)( Display *display, GC gc, Pixmap tile);
+static proto_XSetTile *func_XSetTile = NULL;
+int XSetTile( Display *display, GC gc, Pixmap tile) {
+	if (!func_XSetTile) func_XSetTile=(proto_XSetTile *)_loadfunc("XSetTile");
+	return (func_XSetTile)( display, gc, tile);
+}
+
+typedef int (proto_XSetWMHints)( Display *display, Window w, XWMHints *wmhints);
+static proto_XSetWMHints *func_XSetWMHints = NULL;
+int XSetWMHints( Display *display, Window w, XWMHints *wmhints) {
+	if (!func_XSetWMHints) func_XSetWMHints=(proto_XSetWMHints *)_loadfunc("XSetWMHints");
+	return (func_XSetWMHints)( display, w, wmhints);
+}
+
+typedef void (proto_XSetWMNormalHints)(Display* display,Window w,XSizeHints* hints);
+static proto_XSetWMNormalHints *func_XSetWMNormalHints = NULL;
+void XSetWMNormalHints(Display* display,Window w,XSizeHints* hints) {
+	if (!func_XSetWMNormalHints) func_XSetWMNormalHints=(proto_XSetWMNormalHints *)_loadfunc("XSetWMNormalHints");
+	(func_XSetWMNormalHints)(display,w,hints);
+}
+
+typedef void (proto_XSetWMProperties)( Display* display, Window w, XTextProperty* window_name, XTextProperty* icon_name, char** argv, int argc, XSizeHints* normal_hints, XWMHints* wm_hints, XClassHint* class_hints);
+static proto_XSetWMProperties *func_XSetWMProperties = NULL;
+void XSetWMProperties( Display* display, Window w, XTextProperty* window_name, XTextProperty* icon_name, char** argv, int argc, XSizeHints* normal_hints, XWMHints* wm_hints, XClassHint* class_hints) {
+	if (!func_XSetWMProperties) func_XSetWMProperties=(proto_XSetWMProperties *)_loadfunc("XSetWMProperties");
+	(func_XSetWMProperties)( display, w, window_name, icon_name, argv, argc, normal_hints, wm_hints, class_hints);
+}
+
+typedef StatusDef (proto_XSetWMProtocols)( Display *display, Window w, Atom *prots, int co);
+static proto_XSetWMProtocols *func_XSetWMProtocols = NULL;
+StatusDef XSetWMProtocols( Display *display, Window w, Atom *prots, int co) {
+	if (!func_XSetWMProtocols) func_XSetWMProtocols=(proto_XSetWMProtocols *)_loadfunc("XSetWMProtocols");
+	return (func_XSetWMProtocols)( display, w, prots, co);
+}
+
+typedef int (proto_XSetWindowBackground)( Display *display, Window w, unsigned long bg);
+static proto_XSetWindowBackground *func_XSetWindowBackground = NULL;
+int XSetWindowBackground( Display *display, Window w, unsigned long bg) {
+	if (!func_XSetWindowBackground) func_XSetWindowBackground=(proto_XSetWindowBackground *)_loadfunc("XSetWindowBackground");
+	return (func_XSetWindowBackground)( display, w, bg);
+}
+
+typedef int (proto_XSetWindowBackgroundPixmap)( Display *display, Window w, Pixmap background_tile);
+static proto_XSetWindowBackgroundPixmap *func_XSetWindowBackgroundPixmap = NULL;
+int XSetWindowBackgroundPixmap( Display *display, Window w, Pixmap background_tile) {
+	if (!func_XSetWindowBackgroundPixmap) func_XSetWindowBackgroundPixmap=(proto_XSetWindowBackgroundPixmap *)_loadfunc("XSetWindowBackgroundPixmap");
+	return (func_XSetWindowBackgroundPixmap)( display, w, background_tile);
+}
+
+typedef int (proto_XStoreColor)( Display *display, Colormap cmap, XColor *cell);
+static proto_XStoreColor *func_XStoreColor = NULL;
+int XStoreColor( Display *display, Colormap cmap, XColor *cell) {
+	if (!func_XStoreColor) func_XStoreColor=(proto_XStoreColor *)_loadfunc("XStoreColor");
+	return (func_XStoreColor)( display, cmap, cell);
+}
+
+typedef int (proto_XStoreColors)( Display *display, Colormap cmap, XColor *cells, int nc);
+static proto_XStoreColors *func_XStoreColors = NULL;
+int XStoreColors( Display *display, Colormap cmap, XColor *cells, int nc) {
+	if (!func_XStoreColors) func_XStoreColors=(proto_XStoreColors *)_loadfunc("XStoreColors");
+	return (func_XStoreColors)( display, cmap, cells, nc);
+}
+
+typedef int (proto_XStoreName)(Display *display, Window w, const char *wname);
+static proto_XStoreName *func_XStoreName = NULL;
+int XStoreName(Display *display, Window w, const char *wname) {
+	if (!func_XStoreName) func_XStoreName=(proto_XStoreName *)_loadfunc("XStoreName");
+	return (func_XStoreName)(display, w, wname);
+}
+
+typedef KeySym (proto_XStringToKeysym)(const char *str);
+static proto_XStringToKeysym *func_XStringToKeysym = NULL;
+KeySym XStringToKeysym(const char *str) {
+	if (!func_XStringToKeysym) func_XStringToKeysym=(proto_XStringToKeysym *)_loadfunc("XStringToKeysym");
+	return (func_XStringToKeysym)(str);
+}
+
+typedef int (proto_XSync)(Display *display,int discard);
+static proto_XSync *func_XSync = NULL;
+int XSync(Display *display,int discard) {
+	if (!func_XSync) func_XSync=(proto_XSync *)_loadfunc("XSync");
+	return (func_XSync)(display,discard);
+}
+
+typedef int (proto_XTextExtents)( XFontStruct *fstruct, const char *str, int nc, int *dir,int *ascent,int *descent, XCharStruct *overall);
+static proto_XTextExtents *func_XTextExtents = NULL;
+int XTextExtents( XFontStruct *fstruct, const char *str, int nc, int *dir,int *ascent,int *descent, XCharStruct *overall) {
+	if (!func_XTextExtents) func_XTextExtents=(proto_XTextExtents *)_loadfunc("XTextExtents");
+	return (func_XTextExtents)( fstruct, str, nc, dir,ascent,descent, overall);
+}
+
+typedef int (proto_XTextExtents16)( XFontStruct *fstruct, const XChar2b *str, int nc, int *dir, int *ascent, int *descent, XCharStruct *overall);
+static proto_XTextExtents16 *func_XTextExtents16 = NULL;
+int XTextExtents16( XFontStruct *fstruct, const XChar2b *str, int nc, int *dir, int *ascent, int *descent, XCharStruct *overall) {
+	if (!func_XTextExtents16) func_XTextExtents16=(proto_XTextExtents16 *)_loadfunc("XTextExtents16");
+	return (func_XTextExtents16)( fstruct, str, nc, dir, ascent, descent, overall);
+}
+
+typedef int (proto_XTextWidth)( XFontStruct *fstruct, const char *str, int co);
+static proto_XTextWidth *func_XTextWidth = NULL;
+int XTextWidth( XFontStruct *fstruct, const char *str, int co) {
+	if (!func_XTextWidth) func_XTextWidth=(proto_XTextWidth *)_loadfunc("XTextWidth");
+	return (func_XTextWidth)( fstruct, str, co);
+}
+
+typedef int (proto_XTextWidth16)( XFontStruct *fstruct, const XChar2b *str, int co);
+static proto_XTextWidth16 *func_XTextWidth16 = NULL;
+int XTextWidth16( XFontStruct *fstruct, const XChar2b *str, int co) {
+	if (!func_XTextWidth16) func_XTextWidth16=(proto_XTextWidth16 *)_loadfunc("XTextWidth16");
+	return (func_XTextWidth16)( fstruct, str, co);
+}
+
+typedef BoolDef (proto_XTranslateCoordinates)( Display *display, Window sw, Window dw, int sx, int sy, int *dx, int *dy, Window *ch);
+static proto_XTranslateCoordinates *func_XTranslateCoordinates = NULL;
+BoolDef XTranslateCoordinates( Display *display, Window sw, Window dw, int sx, int sy, int *dx, int *dy, Window *ch) {
+	if (!func_XTranslateCoordinates) func_XTranslateCoordinates=(proto_XTranslateCoordinates *)_loadfunc("XTranslateCoordinates");
+	return (func_XTranslateCoordinates)( display, sw, dw, sx, sy, dx, dy, ch);
+}
+
+typedef int (proto_XUngrabServer)(Display *display);
+static proto_XUngrabServer *func_XUngrabServer = NULL;
+int XUngrabServer(Display *display) {
+	if (!func_XUngrabServer) func_XUngrabServer=(proto_XUngrabServer *)_loadfunc("XUngrabServer");
+	return (func_XUngrabServer)(display);
+}
+
+typedef int (proto_XUnionRectWithRegion)(XRectangle *rect, Region hrgnsrc, Region hrgndest);
+static proto_XUnionRectWithRegion *func_XUnionRectWithRegion = NULL;
+int XUnionRectWithRegion(XRectangle *rect, Region hrgnsrc, Region hrgndest) {
+	if (!func_XUnionRectWithRegion) func_XUnionRectWithRegion=(proto_XUnionRectWithRegion *)_loadfunc("XUnionRectWithRegion");
+	return (func_XUnionRectWithRegion)(rect, hrgnsrc, hrgndest);
+}
+
+typedef int (proto_XUnmapWindow)(Display *display, Window w);
+static proto_XUnmapWindow *func_XUnmapWindow = NULL;
+int XUnmapWindow(Display *display, Window w) {
+	if (!func_XUnmapWindow) func_XUnmapWindow=(proto_XUnmapWindow *)_loadfunc("XUnmapWindow");
+	return (func_XUnmapWindow)(display, w);
+}
+
+typedef void (proto_XUnsetICFocus)(XIC ic);
+static proto_XUnsetICFocus *func_XUnsetICFocus = NULL;
+void XUnsetICFocus(XIC ic) {
+	if (!func_XUnsetICFocus) func_XUnsetICFocus=(proto_XUnsetICFocus *)_loadfunc("XUnsetICFocus");
+	(func_XUnsetICFocus)(ic);
+}
+
+typedef int (proto_XWarpPointer)( Display *display, Window sw,Window dw, int sx,int sy, unsigned int swidth,unsigned int sheight, int dx, int dy);
+static proto_XWarpPointer *func_XWarpPointer = NULL;
+int XWarpPointer( Display *display, Window sw,Window dw, int sx,int sy, unsigned int swidth,unsigned int sheight, int dx, int dy) {
+	if (!func_XWarpPointer) func_XWarpPointer=(proto_XWarpPointer *)_loadfunc("XWarpPointer");
+	return (func_XWarpPointer)( display, sw,dw, sx,sy, swidth,sheight, dx, dy);
+}
+
+typedef int (proto_XWindowEvent)( Display *display, Window w, long emask, XEvent *rep);
+static proto_XWindowEvent *func_XWindowEvent = NULL;
+int XWindowEvent( Display *display, Window w, long emask, XEvent *rep) {
+	if (!func_XWindowEvent) func_XWindowEvent=(proto_XWindowEvent *)_loadfunc("XWindowEvent");
+	return (func_XWindowEvent)( display, w, emask, rep);
+}
+
+typedef int (proto_XmbLookupString)( XIC ic, XKeyPressedEvent* event, char* buffer_return, int bytes_buffer, KeySym* keysym_return, StatusDef* status_return);
+static proto_XmbLookupString *func_XmbLookupString = NULL;
+int XmbLookupString( XIC ic, XKeyPressedEvent* event, char* buffer_return, int bytes_buffer, KeySym* keysym_return, StatusDef* status_return) {
+	if (!func_XmbLookupString) func_XmbLookupString=(proto_XmbLookupString *)_loadfunc("XmbLookupString");
+	return (func_XmbLookupString)( ic, event, buffer_return, bytes_buffer, keysym_return, status_return);
+}
+
+typedef int (proto_XmbTextListToTextProperty)( Display *display, char **list, int count, XICCEncodingStyle style, XTextProperty *text_prop_return);
+static proto_XmbTextListToTextProperty *func_XmbTextListToTextProperty = NULL;
+int XmbTextListToTextProperty( Display *display, char **list, int count, XICCEncodingStyle style, XTextProperty *text_prop_return) {
+	if (!func_XmbTextListToTextProperty) func_XmbTextListToTextProperty=(proto_XmbTextListToTextProperty *)_loadfunc("XmbTextListToTextProperty");
+	return (func_XmbTextListToTextProperty)( display, list, count, style, text_prop_return);
+}
+
+typedef int (proto_XmbTextPropertyToTextList)( Display *display, XTextProperty *text_prop, char ***list_return, int *count_return);
+static proto_XmbTextPropertyToTextList *func_XmbTextPropertyToTextList = NULL;
+int XmbTextPropertyToTextList( Display *display, XTextProperty *text_prop, char ***list_return, int *count_return) {
+	if (!func_XmbTextPropertyToTextList) func_XmbTextPropertyToTextList=(proto_XmbTextPropertyToTextList *)_loadfunc("XmbTextPropertyToTextList");
+	return (func_XmbTextPropertyToTextList)( display, text_prop, list_return, count_return);
+}
+
+typedef char * (proto_XrmQuarkToString)(void *quark);
+static proto_XrmQuarkToString *func_XrmQuarkToString = NULL;
+char * XrmQuarkToString(void *quark) {
+	if (!func_XrmQuarkToString) func_XrmQuarkToString=(proto_XrmQuarkToString *)_loadfunc("XrmQuarkToString");
+	return (func_XrmQuarkToString)(quark);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/CHANGES rxvt-2.7.2/W11/xpm-3.4k/CHANGES
--- rxvt-2.7.2-orig/W11/xpm-3.4k/CHANGES	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/CHANGES	Mon May 14 08:23:10 2001
@@ -0,0 +1,957 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/**************************************************************************\
+* 									   *
+*  			HISTORY of user-visible changes			   *
+* 									   *
+\**************************************************************************/
+
+3.4k    (98/03/18)
+
+    ENHANCEMENTS:
+	- A new program called cxpm is provided to check on XPM files and help
+	  figuring out where the file might be invalid.
+        - The FAQ and README are now in HTML.
+
+    BUGS CORRECTED:
+        - A bug in writing pixmaps out on an 32 bit depth visual and MSBFirst
+	  machine.
+		- patch from Uwe Langenkamp <Uwe.Langenkamp@t-online.de>
+        - A severe bug in parsing the pixels section when an unknown character
+	  is encountered.
+
+3.4j	(96/12/31)
+
+    ENHANCEMENTS:
+	- The XPM library can now be built under Amiga DOS. This entirely comes
+	  from: Lorens Younes <d93-hyo@nada.kth.se>
+	  See the README.AMIGA file for details.
+	- Changes for MSW: big performance improvement in ParseAndPutPixels(),
+		fixed creation of the mask in SetColor()
+		- patch from Jan Wielemaker <jan@swi.psy.uva.nl>
+	- makefiles are provided for VMS
+		- given by Martin P.J. Zinser m.zinser@gsi.de  
+	- Imakefiles reworked to get smoother builds and fixes from:
+		- Paul DuBois dubois@primate.wisc.edu
+		- Larry Schwimmer schwim@cyclone.stanford.edu
+	- thanks to some code rearrangement the library is smaller (the size
+	  reduction goes from 4 to 7% depending on the system)
+
+    BUGS CORRECTED:
+	- A severe bug (introduced in 3.4i as part of the sprintf
+	  optimization) in code writing XPM extensions to a buffer
+	  XpmCreateBufferFromImage/Pixmap.
+	- The XpmAttributes definition in xpm.h was declaring nalloc_colors to
+	  be Bool, it's an int.
+
+3.4i	(96/09/13)
+
+    NEW FEATURES:
+	- The XPM library now allows the application to pass its own color
+	  allocation/free functions. For this matter the following was done:
+	  The XpmAttributes structure has three new fields alloc_color,
+	  free_color, and color_closure. The following new valuemasks were
+	  added XpmAllocColorFunc, XpmFreeColorsFunc, XpmColorClosure. And
+	  two new types were defined XpmAllocColorFunc and XpmFreeColorsFunc.
+	  See documentation for details.
+
+    ENHANCEMENTS:
+	- Windows NT support. It should compile and run fine based on the X
+	  Consortium X11R6 distribution.
+	- The README file contains information to compile on Solaris with gcc.
+	- Part of the code has been optimized by using the value returned by
+	  sprintf instead of calling strlen. Add the flag -DVOID_SPRINTF
+	  if on your system sprintf returns void.
+		  - patch from Thomas Ott thommy@rz.fh-augsburg.de
+
+    BUGS CORRECTED:
+	- XpmFree is now a real function (simply calling free by default).
+
+    CHANGES TO THE DOC:
+	- The documentation describes the new XpmAttributes fields and their
+	  use.
+
+3.4h	(96/02/01)
+
+    NEW FEATURES:
+	- The XpmAttributes has a new member called 'alloc_close_colors' which
+	  lets the caller specify whether close colors should be allocated
+	  using XAllocColor or not. This is especially useful when one uses a
+	  private colormap full of read/write cells.
+	  The xpm.h header file define a new bitmap flag called
+	  XpmAllocCloseColors to use along with this new slot.
+		  - Dale Pease peased@bigbird.cso.gtegsc.com
+	- The XpmAttributes has a new member called 'bitmap_format' which lets
+	  the caller specify the format of 1 bit depth images (XYBitmap or
+	  ZPixmap). The xpm.h header file define a new bitmap flag called
+	  XpmBitmapFormat to use along with this new field.
+
+    ENHANCEMENTS:
+	- XpmReadFileTo[Image/Pixmap], XpmCreate[Image/Pixmap]FromData,
+	  XpmCreateImageFromDataFromBuffer functions do no longer use a
+	  temporary XpmImage object, which reduces a lot the amount of memory
+	  used. On the other hand it can take a little more time, but given the
+	  following figures (based on sxpm) it is a real good trade-off.
+
+	  Reading a 22x22 pixmap with 5 colors no time change is detected
+	  using time:
+		  real        0.3
+		  user        0.1
+		  sys         0.1
+
+	  Reading a 1279x1023 pixmap with 14 colors (quite extreme case for
+	  XPM!) the time goes from:
+		  real        1.9
+		  user        0.8
+		  sys         0.8
+
+	  to:
+		  real        2.2
+		  user        1.8
+		  sys         0.3
+
+	  Reading the 22x22 pixmap with 5 colors the memory usage (under
+	  purify) goes from:
+		  255256 code
+		   55496 data/bss
+		  163848 heap (peak use)
+		    4248 stack
+	  to:
+		  271240 code
+		   55472 data/bss
+		  159752 heap (peak use)
+		    4224 stack
+
+	  And reading the 1279x1023 pixmap with 14 colors it goes from:
+		  255256 code
+		   55496 data/bss
+		 6705160 heap (peak use)
+		    4280 stack
+	  to:
+		  271240 code
+		   55472 data/bss
+		 1732616 heap (peak use)
+		    4264 stack
+
+	  This clearly shows that while for small pixmaps there is no real
+	  difference on both sides, for large pixmaps this makes a huge
+	  difference about the amount of memory used and it is not much
+	  slower.
+
+	  Note that you can still get the old behavior using both
+	  XpmReadFileToXpmImage and XpmCreate[Image/Pixmap]FromXpmImage instead
+	  of XpmReadFileTo[Image/Pixmap]. Once more XPM gives you the choice!
+
+    BUGS CORRECTED:
+        - when defined locally the global symbols strcasecmp and strdup are
+	  now called xpmstrcasecmp and xpmstrdup to avoid any possible
+	  conflict.
+	- VMS has a bogus file system which requires a work around in
+	  XpmReadFileToBuffer.
+		  - patch from Bob.Deen@jpl.nasa.gov
+	- the type of the exactColors attribute has been changed from unsigned
+	  int to Bool.
+
+    CHANGES TO THE DOC:
+	- the documentation describes the new XpmAttributes fields
+	  alloc_close_colors and bitmap_format.
+
+3.4g	(95/10/08)
+
+    ENHANCEMENTS:
+	- The XpmAttributes structure has now two new slots: alloc_pixels and
+	  nalloc_pixels in order to provide an easy way to free allocated
+	  colors. The new bitmask XpmReturnAllocPixels should be used to
+	  request this data through the valuemask. Unless you really know why,
+	  you should use this instead of XpmReturnPixels, pixels, and npixels.
+	- the XPM1 format parsing has been improved.
+		  - patch from Chuck Thompson <cthomp@cs.uiuc.edu>
+	- compilers defining _STDC_ to something different from 1 are now
+	  considered as ANSI compilers.
+	- the README file provides now more info on how to build XPM depending
+	  on the system.
+
+    BUGS CORRECTED:
+	- a bug introduced in 3.4f in the XPM1 format parsing function.
+		  - fix from Chuck Thompson <cthomp@cs.uiuc.edu>
+	- the hashtable was not free when the color parsing failed.
+		  - patch from ackley@cs.unm.edu (David Ackley)
+	- the close color mechanism wasn't used if one of the closeness
+          parameter was null. Now only one needs to be different from 0.
+                    Lorens Younes d93-hyo@nada.kth.se
+	- parsing of long comments failed with a segmentation fault.
+
+    CHANGES TO THE DOC:
+	- the documentation describes the new XpmAttributes fields
+	  alloc_pixels and nalloc_pixels and how they are used.
+
+3.4f	(95/05/29)
+
+    ENHANCEMENTS:
+    	- Defines IMAKE_DEFINES in the top Imakefile so one can easily avoid
+    	  building the shared library.
+	- Add some information about the installation process in the README.
+	- filenames are surrounded with quotes when calling gzip or compress in
+          order to allow spaces within filenames.
+		  - William Parn <parn@fgm.com>
+	- the compilation and the shared library building should be smoother
+	  on Alpha OSF/1.
+		  - patch from Dale Moore <Dale.Moore@CS.cmu.edu>
+
+    BUGS CORRECTED:
+	- a segmentation fault occurring in some weird case.
+
+3.4e	(95/03/01)
+
+    ENHANCEMENTS:
+    	- The top Imakefile passes CDEBUGFLAGS and DEFINES to subdirs. Thus
+    	  only this Imakefile should need to be edited by users.
+	- FAQ includes the answer to the question "How can I get a non
+    	  rectangular icon using XPM ?"
+	- VMS support updated
+		  - patch from Martin P.J. Zinser m.zinser@gsi.de
+
+    BUGS CORRECTED:
+	- XpmCreateImageFromXpmImage() called from XpmReadFileToPixmap() could
+	  lead to a segmentation fault since free was called on a memory block
+	  size variable instead of the block itself. Note: this bug has been
+	  introduced in 3.4d.
+
+3.4d	(95/01/31)
+
+    ENHANCEMENTS:
+    	- sxpm now supports a -version option command.
+
+    BUGS CORRECTED:
+	- the list of pixels returned in XpmAttributes was wrong when two
+	  colors were defined as None in the read XPM
+		  - Lionel.Mallet@sophia.inria.fr
+	- the parser was skipping whitespace reading extensions strings. This
+	  has been fixed so extensions lines are now returned exactly as they
+	  are.
+	- some compilation control added for the dec alpha with X11R5 (LONG64)
+		  - patch from Fredrik Lundh <Fredrik_Lundh@ivab.se>
+	- when writing an XPM file, '-' characters are replaced with '_'
+	  characters in the array name, in order to get a valid C syntax name.
+	- XYPixmap format images were not correctly handled.
+	- XPM1 file with names using multiple '_' characters are now handled
+	  correctly.
+	  	  - todd@erda.rl.af.mil (Todd Gleason)
+
+3.4c	(94/06/06)
+
+    Yes, this is kind of quick. But this is because no code has been modified,
+    this is just a new packaging to make the whole stuff more suitable to the
+    X development team's requests for inclusion in the R6 contrib.
+
+    ENHANCEMENTS:
+	- Several filenames were too long to fit without any conflict on DOS
+	  and CD-ROM filesystems. They have been renamed.
+	- Imakefiles use XCOMM for comments instead of the # character.
+	- the Postscript documentation file doc/xpm.ps is now distributed as
+	  doc/xpm.PS.gz and allows browsing with tools such as ghostview.
+	- Besides, parts of lib/misc.c have been moved to several new files,
+	  and some functions of data.c have been moved to other files in
+	  order to get a better link profile.
+	- I've also added a FAQ hoping this will prevent people from
+	  continuously filling my mailbox with the same questions.
+	- sxpm.c includes <X11/xpm.h> instead of "xpm.h" and BUILDINCTOP is
+	  used in Makefiles as expected.
+	- Everything can be done simply using "xmkmf -a" and "make".
+
+3.4b	(94/05/24)
+
+    ENHANCEMENTS:
+	- XPM can now be built under MS Windows. Yes, this is possible and this
+	  entirely comes from:
+		- Hermann Dunkel <hedu@cul-ipn.uni-kiel.de>
+	  See the README.MSW file for details.
+
+	- building the shared library now depends on the SharedLibXpm variable
+	  and no longer on the SharedLibX variable which is private to the X
+	  Window System project.
+		- patch from Stephen Gildea <gildea@x.org>
+	  Other variables can now be set for the various locations needed.
+
+	- lib/parse.c does no longer use a 256x256 array in the stack but
+	  malloc it instead.
+
+	- The Copyright notice which has been re-written from the X11R6's one
+	  should be clearer and is now present in every file.
+
+    BUGS CORRECTED:
+	- lib/xpmP.h does no longer define a Boolean type which conflicts with
+	  the Intrinsic definition. Instead the type Bool defined in Xlib is
+	  used.
+		- neumann@watson.ibm.com (Gustaf Neumann)
+
+3.4a	(94/03/29)
+
+    BUGS CORRECTED:
+	- passing NULL as shapemask_return to XpmReadFileToPixmap and similar
+	  functions was leading to a bus error.
+		- Dean Luick <dean@falcon.natinst.com>
+
+3.4	(94/03/14)
+
+    IMPORTANT NOTE:
+	This version is not compatible with 3.3. Fortunately most people should
+	only need to recompile.
+	I apology for this but CDE/Motif have put heavy pressure to go that
+	way. The point is that I designed and released Xpm 3.3 in order to let
+	OSF include a clean version of Xpm in Motif 2.0. This new version was
+	not fully compatible with 3.2 but I thought it didn't matter since this
+	was going to be the first version used within Motif. Unfortunately CDE
+	was already using xpm-3.2 internally and requires both source and
+	binary backward compatibility. By the way I must say they didn't drop
+	us a single line to let us know they were using it and thus were
+	expecting stability. All this could have been avoided...
+
+	However, since I had to go for a not compatible version I took this as
+	an opportunity to modify the lower level API, which was new in 3.3 and
+	which was somewhat clumsy, in order to provide yet a better API.
+
+	The library has been modified to have both source and binary backward
+	compatibility with xpm-3.2. This implies it is not either source or
+	binary compatible with 3.3. The fields related to the 3.2 XpmInfos
+	mechanism have been put back into the XpmAttributes structure. The new
+	3.3 XpmInfos struct has been renamed as XpmInfo to avoid conflict with
+	the old 3.2 flag which is back too. All the semantic related to the
+	XpmAttributes infos fields is back as well.
+
+	So this new version provides a high level API which is fully
+	compatible with 3.2 and still provides the 3.3 lower level API
+	(XpmImage) with the XpmInfos struct renamed as XpmInfo. This leads to
+	some redundancy but this was the best I could do to satisfy both
+	CDE/Motif people who needed the backward compatibility and myself (who
+	always tries to provide you with the best ;-).
+
+	Tests have been successfully performed with pixmap-2.1, pixmap-2.4, and
+	sxpm.
+
+    ENHANCEMENTS:
+	- The colorTable member of the XpmAttributes structure is now an
+	  (XpmColor*) in order to be compatible with an XpmImage colorTable.
+	  However in order to be backward compatible this field is cast to
+	  (XpmColor **), which is equivalent to (char ***), when it is used
+	  with the old flags XpmInfos and XpmReturnInfos. To handle the new
+	  type the new flags XpmColorTable and XpmReturnColorTable have been
+	  defined.
+	- The XpmInfo struct has been extended to avoid having to deal with an
+	  XpmAttributes at the lower level. The idea is that all the data
+	  stored in an Xpm file can be retrieve through both an XpmImage and
+	  an XpmInfo struct. See the documentation for details.
+	- XpmUndefPixel is defined and exported by xpm.h in order to let
+	  clients providing their own colorTable when writing out an Xpm file.
+	  See the documentation for details.
+	- in sxpm/sxpm.c, set attribute XtNinput to True on toplevel widget.
+	  Windows that don't "take" input, never get focus, as mandated by
+	  the ICCM.
+        	patch from Henrique Martins <martins@hplhasm.hpl.hp.com>
+	- lib/Imakefile modified to build the shared library under IRIX 5.
+                patch from simon@lia.di.epfl.ch (Simon Leinen)
+
+    NEW FEATURES:
+	- a new function and a new define should help client figuring out with
+	  which Xpm library version they are working. These are
+	  XpmIncludeVersion and XpmLibraryVersion().
+
+3.3	(93/12/20)
+
+    NEW FEATURES:
+	- XPM1 files are now supported.
+	- a new function is provided to get an error string related to the
+	  returned error code.
+		- suggested by Detlef Schmier <detlef@mfr.dec.com>
+
+    ENHANCEMENTS:
+	- gzip and gunzip are called with the -q option (quiet)
+		- patch from Chris P. Ross <cross@eng.umd.edu>
+	- the parser is again more flexible about the way the strings are
+	  distributed on lines. Actually a single line XPM file can be read.
+	- the documentation should be clearer about shapemask generation and
+	  XpmAttributes valuemask.
+
+    BUGS CORRECTED:
+	- reading some binary file was leading to a bus error.
+		- patch from Detlef Schmier <detlef@mfr.dec.com>
+	- the ? character is no longer used when writing an XPM file in order
+	  to avoid possible ANSI trigraphs.
+
+3.3alpha (93/08/13)
+
+    NEW FEATURES:
+	- a new level interface is provided to allow applications to do either
+	  icon editing or data caching.
+	  The XpmAttributes has been changed but most applications will just
+	  need to be recompiled.
+	- new structures are provided to deal with the new lower level:
+		 XpmImage, XpmColor, XpmInfos.
+
+	- a separate distribution called xpm-contrib is available. This
+	  includes the converters which used to be part of this distribution
+	  plus:
+		two new applications:
+		* nexpm to draw a pixmap in *any* existing window from
+			 Ralph Betza <gnohmon@ssiny.com>
+		* xpmview to display a list of Xpm files from
+			 Jean Michel Leon <leon@sophia.inria.fr>
+
+		a hacky string to pixmap converter, provided by
+			Robert H. Forsman Jr.  <thoth@manatee.cis.ufl.edu>
+
+		The Xpm editor called pixmap will also be part of this contrib.
+		This does not mean it is the best pixmap editor one can find
+		but it is the only one that I know of which tries to handle
+		all the features of this format.
+
+    ENHANCEMENTS:
+	- the code to build XImage data has been optimized by
+		 jules@x.co.uk (Julian Gosnell)
+	  the old code is still available when compiling with the
+	  -DWITHOUT_SPEEDUPS flag.
+
+	- closecolor code was not re-entrant
+		 - dbl@visual.com (David B. Lewis)
+	- fix gzip filename (*.gz and no longer *.z).
+		 - Jason Patterson <jasonp@fitmail.fit.qut.edu.au>
+	- sxpm has 2 new options:
+		 -nom to do not display the mask if there is one
+		 -cp <color> <pixel> to override a color value with a given
+		 pixel, i.e. sxpm plaid.xpm -cp red 4
+
+	  also the '-s' adn '-p' options have been renamed to '-sc' and '-sp'.
+
+	- xpm.h defines XpmFormat, XpmVersion, and XpmRevision numbers.
+
+    BUGS CORRECTED:
+	- closecolor minor fix
+		 - Jason Patterson <jasonp@fitmail.fit.qut.edu.au>
+
+3.2g	(93/04/26)
+
+    ENHANCEMENTS:
+	- much faster close colors
+	- piping from/to compressed files now handles GNU's gzip (.z)  format
+	- added XpmColorKey attribute - ability to specify which visual's
+	  colors to use (ie: now it's possible to read in a pixmap in a
+	  color visual, but use the colors specified for monochrome).
+	- added -mono, -grey4, -grey and -color options to sxpm to demonstrate
+	  the XpmColorKey attribute.
+		- Jason Patterson <jasonp@fitmail.qut.edu.au>
+
+    BUGS CORRECTED:
+	- fixed bug where redefining "None" as a pixel stopped mask generation
+	- minor SVR4 defines for <string.h>
+	- fixed annoying closecolor bug related to read/write color cells
+	- fixed minor bug in color value -> pixel overloading
+	- manual updated to include new red/green/blue closeness attributes
+		- Jason Patterson <jasonp@fitmail.qut.edu.au>
+
+	- the top Imakefile was missing the depend target
+	- sxpm/Imakefile fixed so that -L../lib is set before the standard
+	  library location.
+		- Vivek Khera <khera@cs.duke.edu>
+
+	- lib/xpmP.h now defines bcopy as memcpy for VMS (required by recent
+	  versions of VMS)
+		- J. Daniel Smith <dsmith@ann-arbor.applicon.slb.com>
+
+	- the lib/Imakefile didn't work with X11R4.
+
+
+3.2f		(93/03/17)
+
+    NEW FEATURES:
+	- the library provides four new functions to deal with Xpm files
+	  loaded in memory as single character strings buffers:
+
+			XpmCreateImageFromBuffer
+			XpmCreatePixmapFromBuffer
+			XpmCreateBufferFromImage
+			XpmCreateBufferFromPixmap
+
+	- in addition, as a convenience, two functions are provided to copy a
+	  file in a buffer and to write a file from a buffer:
+
+			XpmReadFileToBuffer
+			XpmWriteFileFromBuffer
+
+    ENHANCEMENTS:
+	- Files are now dispatched in the following sub-directories:
+	  lib, sxpm, and doc.
+	- Imakefiles will let you build a shared library as well as the static
+	  one (with either X11R4 or X11R5).
+	- The documentation has been ported from LaTeX to FrameMaker and is
+	  now included in the distribution in its PostScript form (doc/xpm.ps).
+	  Source files are available on request.
+	  Also the documentation has been reorganized and includes a table of
+	  contents and an index of the functions (the number of functions
+	  increasing this became a requisite).
+
+    BUGS CORRECTED:
+	- Many warnings have been fixed - patch from Daniel Dardailler 
+	  daniel@osf.org
+
+3.2e		(93/02/05)
+
+    ENHANCEMENTS:
+	- use XpmMalloc, XpmRealloc, XpmCalloc, and XpmFree which are defines
+	in xpmP.h. This should help people wanting to use their own functions.
+
+    BUGS CORRECTED:
+	- Intrinsic.h is no longer included.
+	- bzero is defined as memset on SYSV and SVR4.
+	- some memory initialization bug concerning XpmAttributes.
+
+3.2d		(93/01/27)
+
+    ENHANCEMENTS:
+    	- compile on Solaris 2.0
+		- patch from Clint Jeffery <cjeffery@cs.arizona.edu>
+
+    BUGS CORRECTED:
+	- shape masks are now set correctly for LSBFirst (Decs).
+	- pixmaps are now set correctly for 2 bit displays (Nexts).
+		- patch from Josef Leherbauer <joe@takeFive.co.at>
+	- isspace was called on getc which fails when EOF is returned.
+		- Marelli Paolo <marelli@colos3.usr.dsi.unimi.it>
+
+3.2c		(92/12/29)
+
+    ENHANCEMENTS:
+    	- parsing optimized for single and double characters color
+		- patch originally from Martin Brunecky 
+				       marbru@build1.auto-trol.com
+
+    BUGS CORRECTED:
+	- XpmFreeExtensions was calling free on some argument without checking
+	it was not NULL.
+	- strdup was not correctly defined for systems which do not provide
+	it.	- Hans-Peter Lichtin <lich@zellweger.ch>
+	- some bug in XpmCrDataFI.c
+	        - Sven Delmas garfield@avalanche.cs.tu-berlin.de
+
+    NOTE:
+    	- there is still a bug with the creation of the clipmask on display of
+	depth 2 but I can't find a fix because unfortunately I don't have such
+	a rendering system and nobody gets the time to investigate for me.
+
+3.2b		(92/10/19)
+
+    ENHANCEMENTS:
+	- Create XpmReadFileToData and XpmWriteFileFromData
+		- Dan Greening <dgreen@sti.com>
+    	- added "close colors" support and ability to redefine color values
+	  as pixels at load time, as well as color names
+		- Jason Patterson <jasonp@fitmail.qut.edu.au>
+	- errors while parsing or allocating colors now revert to other
+	  visual defaults, creating pixmap/image as expected, and returning
+	  XpmSuccess. The old behavior of XpmColorError being returned and no
+	  pixmap/image being created can be retained by setting the
+	  exactColors attribute.
+		- Jason Patterson <jasonp@fitmail.qut.edu.au>
+
+    BUGS CORRECTED:
+	- SVR4 defines for including <string.h> instead of <strings.h>
+		- Jason Patterson <jasonp@fitmail.qut.edu.au>
+	- attributes->extensions and attributes->nextensions fields were not 
+	  set correctly when no extensions present in file.
+		- Simon_Scott Cornish <cornish@ecr.mu.oz.au>
+
+3.2a		(92/08/17)
+
+    ENHANCEMENTS:
+    	- use the mock lisp hashing function instead of the gnu emacs one,
+	it is faster in some cases and never slower (I've not found any case).
+
+    BUGS CORRECTED:
+	- function prototypes for ansi compilers.
+	- some memory initialization bugs (purify is just great for this).
+	- empty strings in extensions are now correctly handled.
+
+3.2		(92/07/06)
+
+    NEW FEATURES:
+	- both format and functions handle extensions data. This allow people
+	to store additional data related to a pixmap. See documentation for
+	detail.
+	- sxpm supports the new option '-c' to use a private colormap. This is
+	useful when displaying pixmaps using a lot of colors.
+	- sxpm supports the new option '-v' (verbose) to get possible
+	extensions print out on standard error.
+
+    ENHANCEMENTS:
+    	- most of the code has been reworked to be improved and thus almost
+	every function is faster. It takes less than 6 seconds of real time on
+	a sun4 to display, with sxpm, a 487x635 pixmap using 213 colors, while
+	it takes 32 seconds with the old library! It takes 18 seconds to
+	display a 1279x1023 screen dump using 14 colors while xwud takes 10
+	seconds.
+	Of course performance improvements are not always that great, they
+	depend on the size and number of colors but I'm sure everybody will
+	appreciate ;-)
+	I know how to improve it more but this will require changes in the
+	architecture so this is not for now. Some optimizations have been
+	contributed by gregor@kafka.saic.com (gregg hanna) and
+	jnc@csl.biosci.arizona.edu (John N. Calley).
+	- the Imakefile is modified to let you install sxpm - Rainer Klute
+           <klute@irb.informatik.uni-dortmund.de>
+	- xpmP.h declares popen for Sequent platforms - Clinton Jeffery
+	   <cjeffery@cs.arizona.edu>
+	- XpmWriteFileFromImage/Pixmap rather than truncating the pixmap name
+	to the first dot changes dots to underscores to get a valid C syntax
+	name.
+
+
+    BUGS CORRECTED:
+	- there was a bug in the image creation function for some 24 bits
+	displays. It is fixed.
+	- allocated color pixels are now freed when an error occurs -
+	   nusser@dec1.wu-wien.ac.at (Stefan Nusser)
+
+    CHANGES TO THE DOC:
+	- the documentation describes the new XpmExtension structure and how
+	to use it with read and write functions.
+
+3.1		(92/02/03)
+
+    ENHANCEMENTS:
+    	- sxpm now have more standard options (mainly suggested by 
+	Rainer Sinkwitz <sinkwitz@ifi.unizh.ch>):
+
+	Usage:  sxpm [options...]
+	Where options are:
+
+	[-d host:display]            Display to connect to.
+	[-g geom]                    Geometry of window.
+	[-hints]                     Set ResizeInc for window.
+	[-icon filename]             Set pixmap for iconWindow.
+	[-s symbol_name color_name]  Overwrite color defaults.
+	[-p symbol_name pixel_value] Overwrite color defaults.
+	[-plaid]                     Read the included plaid pixmap.
+	[filename]                   Read from file 'filename', and from
+				     standard input if 'filename' is '-'.
+	[-o filename]                Write to file 'filename', and to standard
+				     output if 'filename' is '-'.
+	[-nod]                       Don't display in window.
+	[-rgb filename]              Search color names in the rgb text file
+				     'filename'.
+
+	if no input is specified sxpm reads from standard input.
+
+
+	- Xpm functions and Ppm converters now deal with multiword colornames.
+	  patches from Rainer Sinkwitz <sinkwitz@ifi.unizh.ch>.
+
+
+3.0		(91/10/03)
+
+	Functions name and defines have been modified again (sorry for that)
+	as follows:
+
+	     XpmReadPixmapFile    XpmReadFileToPixmap
+	     XpmWritePixmapFile   XpmWriteFileFromPixmap
+
+	     XpmPixmapColorError  XpmColorError
+	     XpmPixmapSuccess     XpmSuccess
+	     XpmPixmapOpenFailed  XpmOpenFailed
+	     XpmPixmapFileInvalid XpmFileInvalid
+	     XpmPixmapNoMemory    XpmNoMemory
+	     XpmPixmapColorFailed XpmColorFailed
+
+	To update code using Xpm you can use the included shell script called
+	rename with the sed commands files name-3.0b-3.0c and name-3.0c-3.0.
+	Old names still valid though.
+
+    NEW FEATURES:
+	- four new functions to work with images instead of pixmaps:
+
+	     XpmReadFileToImage
+	     XpmWriteFileFromImage
+	     XpmCreateImageFromData
+	     XpmCreateDataFromImage
+
+    ENHANCEMENTS:
+    	Algorithms to create and scan images and pixmaps are based on the
+	MIT's R5 code, thus they are much cleaner than old ones and should
+	avoid any problem with any visual (yes, I trust MIT folks :-)
+
+    BUGS CORRECTED:
+	Imakefile use INCDIR instead of ROOTDIR.
+
+    CHANGES TO THE DOC:
+	- the documentation presents the four new functions.
+
+3.0c		(91/09/18)
+
+	In answer to request of people functions, types and defines names have
+	been changed as follows:
+
+	     XCreatePixmapFromData	 XpmCreatePixmapFromData
+	     XCreateDataFromPixmap	 XpmCreateDataFromPixmap
+	     XReadPixmapFile		 XpmReadPixmapFile
+	     XWritePixmapFile		 XpmWritePixmapFile
+	     XFreeXpmAttributes		 XpmFreeAttributes
+
+	     PixmapColorError		 XpmPixmapColorError
+	     PixmapSuccess		 XpmPixmapSuccess
+	     PixmapOpenFailed		 XpmPixmapOpenFailed
+	     PixmapFileInvalid		 XpmPixmapFileInvalid
+	     PixmapNoMemory		 XpmPixmapNoMemory
+	     PixmapColorFailed		 XpmPixmapColorFailed
+
+	     ColorSymbol		 XpmColorSymbol
+
+	Generally speaking every public name begins with 'Xpm' and every
+	private one with 'xpm'. This should avoid any possible conflict.
+
+	Some files have also be renamed accordingly.
+
+    NEW FEATURES:
+	- support for VMS and two new options for sxpm: icon and hints (see
+	manual for details) Richard Hess <rhess%pleione%cimshop@uunet.UU.NET>
+	- DEFINES in Imakefile and Makefile.noXtree allows you to set the
+	following:
+
+	    	 ZPIPE for un/compressing piped feature (default is on)
+		 NEED_STRCASECMP for system which doesn't provide one (default
+				 is off)
+
+	- xpmtoppm.c has is own strstr function which is used if NEED_STRSTR
+	is defined when compiling - Hugues.Leroy@irisa.fr (Hugues Leroy).
+	
+    BUGS CORRECTED:
+	- many bugs have been fixed, especially for ansi compilers -
+	       Doyle C. Davidson (doyle@doyled.b23b.ingr.com) and
+	       Clifford D. Morrison (cdm%bigdaddy%edsr@uunet.UU.NET)
+	- parser is again a little more improved
+
+3.0b		(91/09/12)
+
+	This is a complete new version with a new API and where files and
+	structures have been renamed. So this should be taken as a new
+	starting release.
+	This release should be quickly followed by the 3.0 because I'm planning
+	to send it for X11R5 contrib which ends October 5th.
+
+    NEW FEATURES:
+	- support for transparent color.
+	- support for hotspot.
+	- a new function: XCreateDataFromPixmap to create an XPM data from a
+	pixmap in order to be able to create a new pixmap from this data using
+	the XCreatePixmapFromData function later on.
+	- a new structure: XpmAttributes which replace the XpmInfo structure
+	and which leads to a much simpler API with less arguments.
+	- arguments such as visual, colormap and depth are optional, default
+	values are taken if omitted.
+	- parsing and allocating color failures don't simply break anymore. If
+	another default color can be found it is used and a PixmapColorError
+	is returned. In case no color can be found then it breaks and returns
+	PixmapColorFailed.
+	- for this reason the ErrorStatus codes are redefined as follows:
+
+		   null     if full success
+		   positive if partial success
+		   negative if failure
+
+	with:
+		#define PixmapColorError    1
+		#define PixmapSuccess       0
+		#define PixmapOpenFailed   -1
+		#define PixmapFileInvalid  -2
+		#define PixmapNoMemory     -3
+		#define PixmapColorFailed  -4
+
+	- sxpm prints out a warning when a requested color could not be parsed
+	or alloc'ed, and an error when none has been found.
+	- sxpm handles pixmap with transparent color. For this purpose the
+	plaid_mask.xpm is added to the distribution.
+
+    BUGS CORRECTED:
+	- I've again improved the memory management.
+	- the parser is also improved.
+	- when writing a pixmap to a file the variable name could be
+	"plaid.xpm" which is not valid in C. Now the extension name is cut off
+	to give "plaid" as variable name.
+	- reading multiple words colornames such as "peach puff" where leading
+	to non readable Xpm files. They are now skipped to have only single
+	word colorname. Lionel Mallet (mallet@ipvpel.unipv.it).
+	- parser was triggered by the "/" character inside string.
+	Doyle C. Davidson (doyle@doyled.b23b.ingr.com). This is corrected.
+	- sxpm maps the window only if the option "-nod" is not selected. 
+
+    CHANGES TO THE DOC:
+	- the documentation presents the new API and features.
+
+3.0a		(91/04/10)
+
+	This is an alpha version because it supports the new version of XPM,
+	but the library interface is still the same. Indeed it will change in
+	future release to get rid of obsolete stuff such as the type argument
+	of the XWritePixmapFile function.
+
+    ******************************* WARNING *********************************
+	The format is not anymore XPM2, it is XPM version 3 which is XPM2
+	limited to the C syntax with the key word "XPM" in place of "XPM2 C".
+	The interface library has not changed yet but the type argument of
+	XWritePixmapFile and the type member of XpmInfo are not used anymore.
+	Meanwhile the library which is now called libXpm.a is backward
+	compatible as XPM2 files can be read. But the XWritePixmapFile
+	function only writes out XPM version 3 files.
+    *************************************************************************
+
+    NEW FEATURES:
+	- the library doesn't use global variables anymore, thus it should be
+	able to share it.
+	- sxpm has been rewritten on top of Xt, it can be used to convert
+	files from XPM2 to XPM version 3.
+	- xpm1to2c.perl has been upgraded to the new XPM version and renamed
+	as xpm1to3.perl
+	- ppmtoxpm2.c and ppmtoxpm2.1 have been upgraded too and renamed
+	ppmtoxpm.c and ppmtoxpm.1. In addition the xpmtoppm.c and xpmtoppm.1
+	of the pbmplus package have been upgraded too. xpmtoppm can thus
+	convert XPM version 1 and 3 to a portable pixmap. These files should
+	replace the original ones which are part of the pbmplus package. See
+	the ppm.README file for more details.
+	- the library contains RCS variables which allows you to get revision
+	numbers with ident (which is part of the RCS package). The Id number
+	is an internal rcs number for my eyes only. The official one is found
+	in Version.
+
+    BUGS CORRECTED:
+	- the memory management has been much improved in order to avoid
+	memory leaks.
+	- the XImage building algorithm has been changed to support correctly
+	different visual depths. There is special code to handle depths 1, 4,
+	6, 8, 24, and 32 to build the image and send it in one whack, and
+	other depths are supported by building the image with XPutPixel which
+	is slow but sure.
+	- similar algorithms are used to read pixmaps and write them out.
+
+    CHANGES TO THE DOC:
+	- the documentation presents the new XPM format.
+
+
+2.8		(90/12/19)
+
+    ******************************* WARNING *********************************
+        Since the last release two structures have been modified and have now
+	bigger sizes, so ANY CODE USING THE libXPM2 NEEDS TO BE RECOMPILED.
+    *************************************************************************
+
+    NEW FEATURES:
+	- the ColorSymbol struct contains the new member 'pixel' which allow
+	to override default colors by giving a pixel value (in such a case
+	symbol value must be set to NULL),
+	- the XpmInfo struct contains the new member 'rgb_fname' in which one
+	can specify an rgb text file name while writing a pixmap with the 
+	XWritePixmapFile function (otherwise this member should be set to
+	NULL). This way colorname will be searched and written out if found
+	instead of the RGB value,
+	- Imakefile originally provided by stolcke@ICSI.Berkeley.EDU,
+	- the old Makefile is now distributed as Makefile.noXtree and presents
+	install targets,
+	- the demo application is renamed sxpm (Show XPM), creates a window of
+	the size of the pixmap if no geometry is specified, prints out
+	messages instead of status when an error occurs, handles the new
+	option -p for overriding colors by giving a pixel value (not really
+	useful but is just here to show this new feature), handles the new
+	option -rgb for specifying an rgb text file, and ends on
+	keypress as buttonpress,
+	- defines for SYSV have been provided by Paul Breslaw
+	<paul@mecazh.uucp>,
+	- the distribution includes a new directory called converters which
+	contains xpm1to2 and xpm1to2c perl converters and a ppmtoxpm2
+	converter provided by Paul Breslaw who upgraded the original ppmtoxpm
+	written by Mark W. Snitily <mark@zok.uucp>.
+
+    CHANGES TO THE DOC:
+	- this file is created and will give old users a quick reference to
+	changes made from one release to the next one,
+	- documentation is changed to present the new ColorSymbol structure
+	and the way to override colors by giving a pixel value, and to present
+	the new XpmInfo structure and how to use it,
+	- a man page for sxpm is added to the distrib,
+	- the README file talks about sxpm and no more demo, and have
+	reference to the different converters.
+
+2.7		(90/11/12)
+
+    NEW FEATURES:
+	- XReadPixmapFile reads from stdin if filename is NULL,
+	- XWritePixmapFile writes to stdin if filename is NULL,
+	- the demo application handles the new option -nod for no displaying
+	the pixmap in a window (useful when used as converter).
+
+    CHANGES TO THE DOC:
+	- documentation about the new feature.
+
+2.6		(90/10/29)
+
+    NEW FEATURES:
+	- from nazgul@alphalpha.com (Kee Hinckley): changes to make the
+	library usable as C++ code, and on Apollo without any warning.
+
+    BUGS CORRECTED:
+	- from nazgul@alphalpha.com (Kee Hinckley): the xpm include files was
+	declaring XWritePixmapFile as taking in arg a Pixmap pointer instead
+	of a Pixmap.
+
+2.5		(90/10/17)
+
+    BUGS CORRECTED:
+	- XWritePixmapFile was not closing the file while ending normally.
+
+2.4		(90/09/06)
+
+    NEW FEATURES:
+	- XReadPixmapFile reads from a piped uncompress if the given filename
+	ends by .Z or if filename.Z exists,
+	- XWritePixmapFile writes to a piped compress if the given filename
+	ends by .Z.
+
+    BUGS CORRECTED:
+	- demo now deals with window manager.
+
+    CHANGES TO THE DOC:
+	- documentation about compressed files management.
+
+2.3		(90/08/30)
+
+    BUGS CORRECTED:
+	- handle monochrome display correctly,
+	- comments can be empty.
+
+2.2		(90/08/27)
+
+    BUGS CORRECTED:
+	- when reading some invalid free was dumping core on some machine.
+
+2.1		(90/08/24)
+
+    First distribution of XPM2.
+
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/COPYRIGHT rxvt-2.7.2/W11/xpm-3.4k/COPYRIGHT
--- rxvt-2.7.2-orig/W11/xpm-3.4k/COPYRIGHT	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/COPYRIGHT	Mon May 14 08:23:10 2001
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+Arnaud LE HORS      BULL Research FRANCE -- Koala Project 
+                    (XPM - X PixMap format version 2 & 3)
+    Internet:       lehors@sophia.inria.fr
+Surface Mail:       Arnaud LE HORS, INRIA - Sophia Antipolis, 
+                    2004, route des Lucioles, 06565 Valbonne Cedex -- FRANCE
+ Voice phone:       (33) 93.65.77.71, Fax: (33) 93 65 77 66, Telex: 97 00 50 F
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/FAQ.html rxvt-2.7.2/W11/xpm-3.4k/FAQ.html
--- rxvt-2.7.2-orig/W11/xpm-3.4k/FAQ.html	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/FAQ.html	Mon May 14 08:23:10 2001
@@ -0,0 +1,344 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+<html lang="en">
+<HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<TITLE>FAQ XPM</TITLE>
+</HEAD>
+
+<body>
+<h1 align="center">The XPM<br>
+Frequently Asked Questions</h1>
+<p>
+This article contains the answers to some Frequently Asked Questions about the
+XPM format and/or library. If you don't find the answer to your problem here,
+then you can mail either to lehors@sophia.inria.fr or to the mailing list
+xpm-talk@sophia.inria.fr.
+
+
+<h2>Contents</h2>
+
+<ol>
+<li><a href="#Q1">How do I convert my images to or from XPM ?</a>
+<li><a href="#Q2">Why are my XPM files said to be invalid ?</a>
+<li><a href="#Q3">Why does my program core dumps using XPM ?</a>
+<li><a href="#Q4">Why does my program core dumps using XPM with a widget ?</a>
+<li><a href="#Q5">How can I get a non rectangular icon using XPM ?</a>
+<li><a href="#Q6">What exactly triggers the creation of a mask when using XPM ?</a>
+<li><a href="#Q7">How should I use the mask ?</a>
+<li><a href="#Q8">Is there a string to pixmap converter somewhere ?</a>
+<li><a href="#Q9">How can I edit XPM icons ?</a>
+<li><a href="#Q10">Is there a collection of icons somewhere ?</a>
+<li><a href="#Q11">The documentation fails to print out. Why ?</a>
+<li><a href="#copy">Copyright</a>
+</ol>
+
+
+<h2><a name="Q1">1. How do I convert my images to or from XPM ?</a></h2>
+<p>
+  Netpbm is surely the best image conversion package that I know of. It defines
+  formats for color, gray and monochrome images and provides a set of filters.
+  Thus a GIF image can be converted to XPM with something like:
+<p>
+  $ giftoppm youricon.gif | ppmtoxpm > youricon.xpm
+<p>
+  The latest release can be found at least from wuarchive.wustl.edu
+  (128.252.135.4), directory /graphics/graphics/packages/NetPBM
+
+
+<h2><a name="Q2">2. Why are my XPM files said to be invalid ?</a></h2>
+<p>
+  There are three official versions of the XPM format. The XPM library since
+  version 3.3 can read all them but writes out only XPM 3. Also the small
+  program called sxpm which is part of the XPM library package can be used to
+  automatically translate XPM 1 and 2 files to XPM 3 with a command such as:
+<p>
+  $ sxpm -nod yourxpm1or2file -o yourxpm3file
+<p>
+  Also, the XPM format defines "None" to be the color name meaning
+  "transparent", but IXI used to hack the XPM library in its early days to
+  handle transparency as "#Transparent". This makes IXI format not compatible
+  with the official XPM format, and so not readable neither by the official XPM
+  library nor any of the programs built on top of it.
+<p>
+  The only solutions are either to stick on IXI programs which can deal with
+  their format or convert your files to the standard XPM format. This can be
+  done simply by changing "#Transparent" to "None".
+
+
+<h2><a name="Q3">3. Why does my program core dumps using XPM ?</a></h2>
+<p>
+  Be sure the XpmAttributes structure you pass by reference has a valid
+  valuemask. You can give NULL instead if you don't want to use an
+  XpmAttributes but if you do, you MUST initialize its valuemask component to
+  some valid value, at least 0, otherwise unpredictable errors can occur.
+<p>
+  So instead of doing something like:
+<pre>
+      XpmAttributes attrib;
+
+      XpmReadFileToPixmap(dpy, d, filename, &amp;pixmap, &amp;mask, &amp;attrib);
+</pre>
+<p>
+  you should do:
+<pre>
+      XpmAttributes attrib;
+
+      attrib.valuemask = 0;
+      XpmReadFileToPixmap(dpy, d, filename, &amp;pixmap, &amp;mask, &amp;attrib);
+</pre>
+
+
+<h2><a name="Q4">4. Why does my program core dumps using XPM with a widget ?</a></h2>
+<ul>
+<li>First the XPM library is Xlib level, so don't pass your widget as a
+    Drawable parameter. A Drawable is either a Window or a Pixmap. The widget's
+    window can do the job but:
+
+<li>Then a widget only gets a Window when realized, so passing XtWindow(widget)
+    with a not yet realized widget is wrong. Either realize you widget first or
+    use another window. Since the Drawable parameter is only used to specify
+    the screen to which the pixmap must be created on, most of the time the
+    default root window is just fine.
+</ul>
+
+
+<h2><a name="Q5">5. How can I get a non rectangular icon using XPM ?</a></h2>
+<p>
+  The X Window System does not support transparent color. However there are
+  several ways you can use to get the same visual effect using XPM:
+<ul>
+<li>First you can use the None color to get a shape mask and use it as
+    explained below (question 7).
+
+<li>Second you can define a symbolic color name such as "mask" in the XPM
+    format file, then use the color overriding mechanism to set this symbolic
+    color to the color of the underlying object. Note that in this case the XPM
+    library won't create a shape mask, and that if the color of the underlying
+    object is changed then you'll have to create a new pixmap.
+</ul>
+
+
+<h2><a name="Q6">6. What exactly triggers the creation of a mask when using XPM ?</a></h2>
+<p>
+  Basically a mask is created if "None" is used as one of the color of the
+  pixmap. Be aware that this is not only true if it is used in the XPM of the
+  pixmap since the colors can be overridden at load time. So a mask is created
+  if the "None" color is used at load time, coming either from the XPM
+  definition or the color overriding.
+
+
+<h2><a name="Q7">7. How should I use the mask ?</a></h2>
+<p>
+  There are basically two ways of using the mask:
+<ul>
+<li>Use the mask as a shapemask with the X11 Nonrectangular Saphe Window
+    Extension. Typically this is what should be done when the icon is used in a
+    desktop.
+
+<li>Use the mask as a clipmask in the GC you pass to XCopyArea when drawing the
+    pixmap. So the "transparent" pixels being not actually drawn will get the
+    underlying pixels colors.
+</ul>
+
+
+<h2><a name="Q8">8. Is there a string to pixmap converter for Motif ?</a></h2>
+<p>
+ Yes, Motif 2.0 or later does support XPM pixmaps as well as XBM bitmaps.
+
+
+<h2><a name="Q9">9. How can I edit XPM icons ?</a></h2>
+<p>
+  As listed below several editors either commercial or not are supporting the
+  XPM format. However, pixmap is the one I would recommend since it is freely
+  available and, being fully dedicated to XPM, it allows to edit all the
+  special things, such as the symbolic color names, which makes XPM different
+  from all the other image formats. Pixmap can always be found by ftp from
+  ftp.x.org (contrib) and avahi.inria.fr (pub/pixmap).
+<p>
+Last Update: 3 August 1994
+<table border=1>
+<caption>XPM Icon Editors</caption>
+<tr><th>Program<th>Infos<th>Source/Author<th>Platforms<th>SA<th>XPM<th>cost
+<tr><td>pixmap<td><ul>
+   <li><a href="ftp://ftp.x.org/contrib/application/pixmap/pixmap2.6.tar.gz">ftp://ftp.x.org/contrib/application/pixmap/pixmap2.6.tar.gz</a>
+   <li>requires 3.4 or higher revision of Xpm lib.
+   <li>supports all XPM format features
+   <li>current version doesn't work on 24-plane displays
+</ul>
+<td>Lionel Mallet<td>source<td>yes<td>3<td>NC
+
+<tr><td>pixt<td><ul>
+   <li><a href="ftp://ftp.x.org/contrib/pixt.tar.Z">ftp://ftp.x.org/contrib/pixt.tar.Z</a>
+   <li>doesn't work on 24-plane displays
+   <li>last updated November 1991
+</ul>
+<td>J. Michael Flanery<td>source<td>yes<td>1<td>NC
+
+<tr><td>pixed<td><ul>
+   <li>part of X.desktop
+   <li>current version doesn't work on 24-plane displays
+</ul>
+<td>IXI<td>Many UNIX<td>no<td>3<td>N/A
+
+<tr><td>olpixmap<td><ul>
+   <li>packaged with the OLIT (OpenLook) toolkit
+</ul>
+<td>USL<td>Sun, SVR4.2, UnixWare<td>no<td>1<td>N/A
+
+<tr><td>xfedor<td><ul>
+   <li>only uses XLIB
+   <li>doesn't work on 24-plane displays
+</ul>
+<td>Daniel Dardailler<td>source<td>yes<td>3<td>NC
+
+<tr><td>SCOpaint<td><ul>
+   <li>included with the ODT package
+</ul>
+<td>SCO/Wing Eng<td>ODT<td>yes<td>2.8<td>N/A
+
+<tr><td>pme.icn<td><ul>
+   <li>written in the Icon language
+</ul>
+<td>Icon Project<td>source<td>yes<td>3<td>NC
+
+<tr><td>PixEditT<td><ul>
+   <li>there is currently no support for editing the colormap
+</ul>
+<td>Free Widget Foundation<td>source<td>yes<td>3<td>NC
+
+<tr><td>xscribble<td><ul>
+   <li>requires the FWF, 8-bit pseudocolor
+   <li><a href="ftp://ftp.cis.ufl.edu/pub/thoth">ftp://ftp.cis.ufl.edu/pub/thoth</a>
+   <li>Alpha version (last updated April 1993)
+</ul>
+<td>Robert Forsman<td>source<td>yes<td>?<td>NC
+
+<tr><td>vueicon<td><ul>
+   <li>included with Vue3.0
+</ul>
+<td>Hewlett-Packard<td>HP<td>yes<td>3<td>N/A
+
+<tr><td>iconedit V3<td>&nbsp;<td>SunSoft<td>Sparc/Sun3<td>yes<td>2<td>N/A
+
+<tr><td>Pixmap Editor<td><ul>
+   <li>this is a Widget, not a complete program
+</ul>
+<td>ICS<td>?<td>yes<td>?<td>?
+
+<tr><td>ezX<td>&nbsp;<td>Sunrise Softwarey<td>?<td>?<td>?<td>N/A
+
+<tr><td>XPaint<td><ul>
+     <li>full featured, works on all displays
+     <li>current release is 2.1.1 (last update January 1994)
+</ul>
+<td>David Koblas<td>source<td>yes<td>3<td>NC
+
+<tr><td>Phoenix<td><ul>
+    <li>full featured, 24-bit painting program, requires Motif.
+    <li><a href="ftp://nic.funet.fi/pub/graphics/packages/phoenix">ftp://nic.funet.fi/pub/graphics/packages/phoenix</a>
+    <li>Beta version (last updated September 1993)
+</ul>
+<td>ohtcolor@niksula.hut.fi<td>source<td>yes<td>3<td>NC
+
+<tr><td>pixed<td><ul>
+    <li>pixed is part of the TeleUSE UIMS
+    <li>More info is available from service@ignite.alsys.com
+</ul>
+<td>Alsys<td>Many UNIX<td>yes<td>3<td>N/A
+
+<tr><td>display<td><ul>
+   <li><a href="ftp://ftp.x.org/contrib/application/ImageMagick/ImageMagick-3.2.tar.gz">ftp://ftp.x.org/contrib/application/ImageMagick/ImageMagick-3.2.tar.gz</a>
+   <li>lots of image conversion and manipulation features
+</ul>
+<td>John Cristy<td>source<td>yes<td>3<td>NC
+</table>
+
+<p>
+SA - Stand Alone program<br>
+NC - No Charge (i.e. free); most programs are copyrighted.<br>
+XPM - XPM format supported<br>
+source - built from source code; likely works on all standard X platforms<br>
+N/A - icon editor is normally distributed with other software
+
+<p>
+Send updates, additions, corrections, etc. to <a
+href="mailto:dan@bristol.com">dan@bristol.com</a>
+
+
+<h2><a name="Q10">10. Is there a collection of icons somewhere ?</a></h2>
+<p>
+  At least there is one freely available: Anthony's X Icon Library. You can
+  found it on several ftp servers, such as <a href="ftp://server.berkeley.edu/pub/AIcons">server.berkeley.edu/pub/AIcons</a>. It
+  contains only small icons (less than about 100x100 pixels in size) which are
+  stored in groups in a logical way. Color icons are stored in XPM format and
+  Black & White icons in XBM.
+
+
+<h2><a name="Q11">11. The documentation fails to print out. Why ?</a></h2>
+<p>
+  The PostScript documentation file is formatted for US letter paper. Frame
+  Maker tries very hard to ensure that you have the right paper and punts if
+  you don't. However, you can easily work around this problem by applying the
+  following patch. If for some reason applying the patch fails, you can still
+  do it by hand. Just locate the corresponding block in the PS file and remove
+  the lines with a leading '-' character.
+  By the way, this applies to any doc generated by Frame Maker. The
+  corresponding block might be slightly different depending on which version of
+  Frame Maker was used, but it is still easy to locate.
+
+<pre>
+*** xpm.PS      Wed Sep 11 15:47:43 1996
+--- xpm-A4.PS   Thu Nov 21 09:27:28 1996
+***************
+*** 647,668 ****
+        0 ne /edown exch def 
+        /yscale exch def
+        /xscale exch def
+-       FMLevel1 {
+-               manualfeed {setmanualfeed} if
+-               /FMdicttop countdictstack 1 add def 
+-               /FMoptop count def 
+-               setpapername 
+-               manualfeed {true} {papersize} ifelse 
+-               {manualpapersize} {false} ifelse 
+-               {desperatepapersize} {false} ifelse 
+-               { (Can't select requested paper size for Frame print job!) FMFAILURE } if
+-               count -1 FMoptop {pop pop} for
+-               countdictstack -1 FMdicttop {pop end} for 
+-               }
+-               {{1 dict dup /PageSize [paperwidth paperheight]put setpagedevice}stopped
+-               { (Can't select requested paper size for Frame print job!) FMFAILURE } if
+-                {1 dict dup /ManualFeed manualfeed put setpagedevice } stopped pop }
+-       ifelse 
+        
+        FMPColor {
+                currentcolorscreen
+--- 647,652 ----
+</pre>
+
+
+<hr>
+<h2><a name="copy">Copyright (C) 1989-95 GROUPE BULL</a></h2>
+<p>
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to
+deal in the Software without restriction, including without limitation the
+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+<p>
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+<p>
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+<p>
+Except as contained in this notice, the name of GROUPE BULL shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from GROUPE BULL.
+</body>
+</html>
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/FILES rxvt-2.7.2/W11/xpm-3.4k/FILES
--- rxvt-2.7.2-orig/W11/xpm-3.4k/FILES	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/FILES	Mon May 14 08:23:10 2001
@@ -0,0 +1,68 @@
+CHANGES
+COPYRIGHT
+FAQ.html
+FILES
+Imakefile
+Makefile.noX
+README.html
+README.AMIGA
+README.MSW
+namecvt
+lib
+lib/Imakefile
+lib/Makefile.noX
+lib/Makefile.AmigaGCC
+lib/Smakefile
+lib/Attrib.c
+lib/CrBufFrI.c
+lib/CrBufFrP.c
+lib/CrDatFrI.c
+lib/CrDatFrP.c
+lib/CrIFrBuf.c
+lib/CrIFrDat.c
+lib/CrIFrP.c
+lib/CrPFrBuf.c
+lib/CrPFrDat.c
+lib/CrPFrI.c
+lib/Image.c
+lib/Info.c
+lib/RdFToBuf.c
+lib/RdFToDat.c
+lib/RdFToI.c
+lib/RdFToP.c
+lib/WrFFrBuf.c
+lib/WrFFrDat.c
+lib/WrFFrI.c
+lib/WrFFrP.c
+lib/amigax.h
+lib/amigax.c
+lib/create.c
+lib/data.c
+lib/descrip.mms
+lib/hashtab.c
+lib/make.com
+lib/misc.c
+lib/parse.c
+lib/rgb.c
+lib/rgbtab.h
+lib/scan.c
+lib/simx.h
+lib/simx.c
+lib/xpm.h
+lib/XpmI.h
+lib/Xpm-def.cpp
+doc
+doc/xpm.PS
+sxpm
+sxpm/Imakefile
+sxpm/Makefile.noX
+sxpm/plaid.xpm
+sxpm/plaid_ext.xpm
+sxpm/plaid_mask.xpm
+sxpm/sxpm.c
+sxpm/sxpm.man
+cxpm
+cxpm/Imakefile
+cxpm/Makefile.noX
+cxpm/cxpm.c
+cxpm/cxpm.man
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/Imakefile rxvt-2.7.2/W11/xpm-3.4k/Imakefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/Imakefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/Imakefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,74 @@
+XCOMM
+XCOMM
+XCOMM Copyright (C) 1989-95 GROUPE BULL
+XCOMM
+XCOMM Permission is hereby granted, free of charge, to any person obtaining a
+XCOMM copy of this software and associated documentation files
+XCOMM (the "Software"), to deal in the Software without restriction, including
+XCOMM without limitation the rights to use, copy, modify, merge, publish,
+XCOMM distribute, sublicense, and/or sell copies of the Software, and to permit
+XCOMM persons to whom the Software is furnished to do so, subject to the
+XCOMM following conditions:
+XCOMM The above copyright notice and this permission notice shall be included
+XCOMM in all copies or substantial portions of the Software.
+XCOMM
+XCOMM THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+XCOMM OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+XCOMM MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+XCOMM IN NO EVENT SHALL GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+XCOMM LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+XCOMM FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+XCOMM DEALINGS IN THE SOFTWARE.
+XCOMM
+XCOMM Except as contained in this notice, the name of GROUPE BULL shall not be
+XCOMM used in advertising or otherwise to promote the sale, use or other
+XCOMM dealings in this Software without prior written authorization from
+XCOMM GROUPE BULL.
+XCOMM
+
+XCOMM
+XCOMM XPM Imakefile - Arnaud LE HORS
+XCOMM
+
+
+XCOMM You may need to modify the following DEFINES variable as follows:
+XCOMM if your system doesn't provide strcasecmp add -DNEED_STRCASECMP
+XCOMM if your system doesn't provide strdup add -DNEED_STRDUP
+XCOMM if your system doesn't provide pipe add -DNO_ZPIPE
+XCOMM if on your system sprintf doesn't return the number of bytes transmitted
+XCOMM add -DVOID_SPRINTF
+
+#if defined(UltrixArchitecture) || \
+    (defined(MipsArchitecture) && !defined(SGIArchitecture))
+STRDUPDEF = -DNEED_STRDUP
+#else
+# if defined(Win32Architecture) || defined(USLArchitecture) || \
+     (defined(HasStrcasecmp) && !HasStrcasecmp)
+STRCASECMPDEF = -DNEED_STRCASECMP
+# else
+#  if defined(SunArchitecture) && !defined(SVR4Architecture)
+SPRINTFDEF = -DVOID_SPRINTF
+#  endif
+# endif
+#endif
+#if defined(Win32Architecture)
+ZPIPEDEF = -DNO_ZPIPE
+#endif
+
+DEFINES = $(STRDUPDEF) $(STRCASECMPDEF) $(SPRINTFDEF) $(ZPIPEDEF)
+
+XCOMM You can uncomment the following line to avoid building the shared lib
+XCOMM IMAKE_DEFINES = -DSharedLibXpm=NO
+
+
+XCOMM
+XCOMM Normally the following part should not need to be edited
+XCOMM
+
+#define IHaveSubdirs
+#define PassCDebugFlags "CDEBUGFLAGS=$(CDEBUGFLAGS)" "DEFINES=$(DEFINES)"
+
+     SUBDIRS = lib sxpm cxpm
+
+MakeSubdirs($(SUBDIRS))
+DependSubdirs($(SUBDIRS))
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/Makefile rxvt-2.7.2/W11/xpm-3.4k/Makefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/Makefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/Makefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,677 @@
+# Makefile generated by imake - do not edit!
+# $TOG: imake.c /main/104 1998/03/24 12:45:15 kaleb $
+
+# ----------------------------------------------------------------------
+# Makefile generated from "Imake.tmpl" and <Imakefile>
+# $TOG: Imake.tmpl /main/249 1997/10/13 15:28:56 kaleb $
+#
+
+all::
+
+.SUFFIXES: .i
+
+# $TOG: Imake.cf /main/30 1998/04/28 13:55:25 barstow $
+
+# -----------------------------------------------------------------------
+# site-specific configuration parameters that need to come before
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ----------------------------------------------------------------------
+# platform-specific configuration parameters - edit cygwin.cf to change
+
+# platform:  $XConsortium: cygwin.cf sos 1996/02/08 18:59:31 gildea $
+#
+# changes since b18 cygwin32 release
+#	- avoided tons of "not in XXX directory" messages;
+#	- dlls are built stripped;
+#	- search for cpp in a default location;
+#	- fixed problem with missed netinet/tcp.h;
+#	- xterm compiles and works;
+#	- more libs are built as a dlls;
+#	- all dlls have different base addresses;
+
+# $XConsortium: cygwin.rules /main/12 1996/01/03 14:51:18 kaleb $
+
+BASE_COUNTER=/tmp/DLL_BASE_COUNTER
+
+# ----------------------------------------------------------------------
+# site-specific configuration parameters that go after
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ---------------------------------------------------------------------
+# Imake rules for building libraries, programs, scripts, and data files
+# rules:  $TOG: Imake.rules /main/227 1998/02/02 12:07:57 kaleb $
+
+          PATHSEP = /
+            SHELL = /bin/sh
+
+              TOP = .
+      CURRENT_DIR = .
+
+            IMAKE = imake
+           DEPEND = makedepend
+        MKDIRHIER = mkdir -p
+    EXPORTLISTGEN =
+        CONFIGSRC = $(TOP)/config
+         IMAKESRC = $(CONFIGSRC)/imake
+        DEPENDSRC = $(CONFIGSRC)/makedepend
+
+          INCROOT = /usr/X11R6.4/include
+        USRLIBDIR = /usr/X11R6.4/lib
+         SHLIBDIR = /usr/X11R6.4/lib
+       LINTLIBDIR = $(USRLIBDIR)/lint
+          MANPATH = /usr/X11R6.4/man
+    MANSOURCEPATH = $(MANPATH)/man
+           MANDIR = $(MANSOURCEPATH)1
+        LIBMANDIR = $(MANSOURCEPATH)3
+       FILEMANDIR = $(MANSOURCEPATH)5
+       MISCMANDIR = $(MANSOURCEPATH)$(MISCMANSUFFIX)
+
+               AR = ar clq
+  BOOTSTRAPCFLAGS =
+               CC = gcc
+               AS = as
+
+.SUFFIXES: .cc
+
+              CXX = g++
+          CXXFILT = c++filt
+           CXXLIB =
+    CXXDEBUGFLAGS = -O2 -s -mpentium
+CXXDEPENDINCLUDES =
+ CXXEXTRA_DEFINES =
+CXXEXTRA_INCLUDES =
+   CXXSTD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(CXXPROJECT_DEFINES)
+       CXXOPTIONS =
+      CXXINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(CXXEXTRA_INCLUDES)
+       CXXDEFINES = $(CXXINCLUDES) $(CXXSTD_DEFINES) $(THREADS_CXXDEFINES) $(CXXEXTRA_DEFINES) $(DEFINES)
+         CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
+
+         COMPRESS = compress
+          GZIPCMD = gzip
+              CPP = gcc -E - $(STD_CPP_DEFINES)
+    PREPROCESSCMD = gcc -E $(STD_CPP_DEFINES)
+          INSTALL = install
+     INSTALLFLAGS = -c
+               LD = ld
+              LEX = flex -l
+           LEXLIB = -lfl
+             YACC = byacc
+           CCYACC = byacc
+             LINT = lint
+      LINTLIBFLAG = -C
+         LINTOPTS = -axz
+               LN = ln -s
+             MAKE = make
+               MV = mv
+               CP = cp
+
+           RANLIB = ranlib
+  RANLIBINSTFLAGS =
+
+               RM = rm -f
+        MANSUFFIX = 1x
+     LIBMANSUFFIX = 3x
+    FILEMANSUFFIX = 5x
+    MISCMANSUFFIX = 7
+
+            TROFF = psroff
+            NROFF = nroff
+         MSMACROS = -ms
+        MANMACROS = -man
+              TBL = tbl
+              EQN = eqn
+             NEQN = neqn
+              COL = col
+
+            DVIPS = dvips
+            LATEX = latex
+
+     STD_INCLUDES =
+  STD_CPP_DEFINES = -traditional -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+      STD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+ EXTRA_LOAD_FLAGS =
+  EXTRA_LDOPTIONS =
+  EXTRA_LIBRARIES =
+             TAGS = ctags
+
+    SHAREDCODEDEF =
+         SHLIBDEF =
+
+     SHLIBLDFLAGS =
+
+    PROTO_DEFINES = -DFUNCPROTO=15 -DNARROWPROTO
+
+     INSTPGMFLAGS = -s
+
+     INSTBINFLAGS = -m 0755
+     INSTUIDFLAGS = -s -m 4711
+     INSTLIBFLAGS = -m 0644
+     INSTINCFLAGS = -m 0444
+     INSTMANFLAGS = -m 0444
+     INSTDATFLAGS = -m 0444
+    INSTKMEMFLAGS = -s -m 4711
+
+      PROJECTROOT = /usr/X11R6.4
+
+      CDEBUGFLAGS = -O2 -s -mpentium
+        CCOPTIONS =
+
+      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
+       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(THREADS_DEFINES) $(DEFINES)
+           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(THREADS_CFLAGS) $(ALLDEFINES)
+        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES) $(DEPEND_DEFINES)
+         LDPRELIB = -L$(USRLIBDIR)
+        LDPOSTLIB =
+        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)  $(EXTRA_LDOPTIONS) $(THREADS_LDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+     CXXLDOPTIONS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(EXTRA_LDOPTIONS) $(THREADS_CXXLDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+
+           LDLIBS = $(LDPOSTLIBS) $(THREADS_LIBS) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
+
+           CCLINK = $(CC)
+
+          CXXLINK = $(CXX)
+
+     LDSTRIPFLAGS = -x
+   LDCOMBINEFLAGS = -r
+      DEPENDFLAGS =
+
+        MACROFILE = cygwin.cf
+           RM_CMD = $(RM)
+
+    IMAKE_DEFINES =
+
+         IRULESRC = $(CONFIGDIR)
+        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
+
+     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/X11.tmpl 			$(IRULESRC)/site.def $(IRULESRC)/$(MACROFILE) 			 $(EXTRA_ICONFIGFILES)
+
+# $TOG: X11.rules /main/4 1997/04/30 15:23:24 kaleb $
+
+# ----------------------------------------------------------------------
+# X Window System Build Parameters and Rules
+# $TOG: X11.tmpl /main/308 1998/06/16 15:14:24 msr $
+
+# -----------------------------------------------------------------------
+# X Window System make variables; these need to be coordinated with rules
+
+             XTOP = $(TOP)
+           BINDIR = /usr/X11R6.4/bin
+     BUILDINCROOT = $(TOP)/exports
+      BUILDINCDIR = $(BUILDINCROOT)/include
+      BUILDINCTOP = ../..
+      BUILDLIBDIR = $(TOP)/exports/lib
+      BUILDLIBTOP = ../..
+      BUILDBINDIR = $(TOP)/exports/bin
+      BUILDBINTOP = ../..
+    XBUILDINCROOT = $(XTOP)/exports
+     XBUILDINCDIR = $(XBUILDINCROOT)/include/X11
+     XBUILDINCTOP = ../../..
+     XBUILDBINDIR = $(XBUILDINCROOT)/bin
+           INCDIR = $(INCROOT)
+           ADMDIR = /usr/adm
+           LIBDIR = $(USRLIBDIR)/X11
+   TOP_X_INCLUDES = -I$(XPROJECTROOT)/include
+
+           VARDIR = /var/X11
+
+          FONTDIR = $(LIBDIR)/fonts
+         XINITDIR = $(LIBDIR)/xinit
+           XDMDIR = $(LIBDIR)/xdm
+           TWMDIR = $(LIBDIR)/twm
+           XSMDIR = $(LIBDIR)/xsm
+           NLSDIR = $(LIBDIR)/nls
+       XLOCALEDIR = $(LIBDIR)/locale
+        PEXAPIDIR = $(LIBDIR)/PEX
+      LBXPROXYDIR = $(LIBDIR)/lbxproxy
+  PROXYMANAGERDIR = $(LIBDIR)/proxymngr
+        XPRINTDIR = $(LIBDIR)/xserver
+      XAPPLOADDIR = $(LIBDIR)/app-defaults
+       FONTCFLAGS = -t
+
+     INSTAPPFLAGS = $(INSTDATFLAGS)
+
+              RGB = $(BINDIR)/rgb
+            FONTC = $(BINDIR)/bdftopcf
+        MKFONTDIR = $(BINDIR)/mkfontdir
+
+       DOCUTILSRC = $(XTOP)/doc/util
+       XDOCMACROS = $(DOCUTILSRC)/macros.t
+       XIDXMACROS = $(DOCUTILSRC)/indexmacros.t
+       PROGRAMSRC = $(TOP)/programs
+           LIBSRC = $(XTOP)/lib
+          FONTSRC = $(XTOP)/fonts
+       INCLUDESRC = $(BUILDINCROOT)/include
+      XINCLUDESRC = $(INCLUDESRC)/X11
+        SERVERSRC = $(XTOP)/programs/Xserver
+       CONTRIBSRC = $(XTOP)/../contrib
+   UNSUPPORTEDSRC = $(XTOP)/unsupported
+           DOCSRC = $(XTOP)/doc
+           RGBSRC = $(XTOP)/programs/rgb
+      BDFTOPCFSRC = $(PROGRAMSRC)/bdftopcf
+     MKFONTDIRSRC = $(PROGRAMSRC)/mkfontdir
+    FONTSERVERSRC = $(PROGRAMSRC)/xfs
+       FONTINCSRC = $(XTOP)/include/fonts
+        EXTINCSRC = $(XTOP)/include/extensions
+     TRANSCOMMSRC = $(LIBSRC)/xtrans
+   TRANS_INCLUDES = -I$(TRANSCOMMSRC)
+
+   CLIENTENVSETUP =
+
+# $XConsortium: WinLib.tmpl,v 1.1 94/01/08 18:32:51 rws Exp $
+
+          XLIBSRC = $(LIBSRC)/X11
+
+SOXLIBREV = 6.1
+DEPXONLYLIB =
+XONLYLIB =  -lX11
+
+LINTXONLY = $(LINTLIBDIR)/llib-lX11.ln
+
+         XLIBONLY = $(XONLYLIB)
+
+      XEXTLIBSRC = $(LIBSRC)/Xext
+
+SOXEXTREV = 6.4
+DEPEXTENSIONLIB =
+EXTENSIONLIB =  -lXext
+
+LINTEXTENSION = $(LINTLIBDIR)/llib-lXext.ln
+
+LINTEXTENSIONLIB = $(LINTEXTENSION)
+          DEPXLIB = $(DEPEXTENSIONLIB) $(DEPXONLYLIB)
+             XLIB = $(EXTENSIONLIB) $(XONLYLIB)
+         LINTXLIB = $(LINTXONLYLIB)
+
+         XAUTHSRC = $(LIBSRC)/Xau
+
+DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
+XAUTHLIB =  -lXau
+
+LINTXAUTH = $(LINTLIBDIR)/llib-lXau.ln
+
+      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
+
+DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
+XDMCPLIB =  -lXdmcp
+
+LINTXDMCP = $(LINTLIBDIR)/llib-lXdmcp.ln
+
+           XMUSRC = $(LIBSRC)/Xmu
+
+DEPXMULIB = $(USRLIBDIR)/libXmu.a
+XMULIB =  -lXmu
+
+LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
+
+       OLDXLIBSRC = $(LIBSRC)/oldX
+
+SOOLDXREV = 6.0
+DEPOLDXLIB =
+OLDXLIB =  -loldX
+
+LINTOLDX = $(LINTLIBDIR)/llib-loldX.ln
+
+         XPLIBSRC = $(LIBSRC)/Xp
+
+SOXPREV = 6.2
+DEPXPLIB =
+XPLIB =  -lXp
+
+LINTXP = $(LINTLIBDIR)/llib-lXp.ln
+
+       TOOLKITSRC = $(LIBSRC)/Xt
+
+DEPXTOOLONLYLIB = $(USRLIBDIR)/libXt.a
+XTOOLONLYLIB =  -lXt
+
+LINTXTOOLONLY = $(LINTLIBDIR)/llib-lXt.ln
+
+      DEPXTOOLLIB = $(DEPXTOOLONLYLIB) $(DEPSMLIB) $(DEPICELIB)
+         XTOOLLIB = $(XTOOLONLYLIB) $(SMLIB) $(ICELIB)
+     LINTXTOOLLIB = $(LINTXTOOLONLYLIB)
+
+       XALIBSRC = $(LIBSRC)/Xa
+
+SOXAREV = 1.0
+DEPXALIB =
+XALIB =  -lXa
+
+LINTXA = $(LINTLIBDIR)/llib-lXa.ln
+
+       AWIDGETSRC = $(LIBSRC)/Xaw
+
+DEPXAWLIB = $(USRLIBDIR)/libXaw.a
+XAWLIB =  -lXaw
+
+LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
+
+         XILIBSRC = $(LIBSRC)/Xi
+
+SOXINPUTREV = 6.0
+DEPXILIB =
+XILIB =  -lXi
+
+LINTXI = $(LINTLIBDIR)/llib-lXi.ln
+
+      XTESTLIBSRC = $(LIBSRC)/Xtst
+
+SOXTESTREV = 6.1
+DEPXTESTLIB =
+XTESTLIB =  -lXtst
+
+LINTXTEST = $(LINTLIBDIR)/llib-lXtst.ln
+
+        PEXLIBSRC = $(LIBSRC)/PEX5
+
+SOPEXREV = 6.0
+DEPPEXLIB =
+PEXLIB =  -lPEX5
+
+LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
+
+        XIELIBSRC = $(LIBSRC)/XIE
+
+SOXIEREV = 6.0
+DEPXIELIB =
+XIELIB =  -lXIE
+
+LINTXIE = $(LINTLIBDIR)/llib-lXIE.ln
+
+      PHIGSLIBSRC = $(LIBSRC)/PHIGS
+
+DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
+PHIGSLIB =  -lphigs
+
+LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
+
+DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
+XBSDLIB =  -lXbsd
+
+LINTXBSD = $(LINTLIBDIR)/llib-lXbsd.ln
+
+           ICESRC = $(LIBSRC)/ICE
+
+SOICEREV = 6.3
+DEPICELIB =
+ICELIB =  -lICE
+
+LINTICE = $(LINTLIBDIR)/llib-lICE.ln
+
+            SMSRC = $(LIBSRC)/SM
+
+SOSMREV = 6.0
+DEPSMLIB =
+SMLIB =  -lSM
+
+LINTSM = $(LINTLIBDIR)/llib-lSM.ln
+
+           XKEYSRC = $(LIBSRC)/Xkey
+
+SOXKEYREV = 6.0
+DEPXKEYLIB =
+XKEYLIB =  -lXkey
+
+LINTXKEY = $(LINTLIBDIR)/llib-lXkey.ln
+
+         FSLIBSRC = $(LIBSRC)/FS
+
+DEPFSLIB = $(USRLIBDIR)/libFS.a
+FSLIB =  -lFS
+
+LINTFS = $(LINTLIBDIR)/llib-lFS.ln
+
+         FONTLIBSRC = $(LIBSRC)/font
+
+DEPFONTLIB = $(USRLIBDIR)/libfont.a
+FONTLIB =  -lfont
+
+LINTFONT = $(LINTLIBDIR)/llib-lfont.ln
+
+    XKBFILELIBSRC = $(LIBSRC)/xkbfile
+
+DEPXKBFILELIB = $(USRLIBDIR)/libxkbfile.a
+XKBFILELIB =  -lxkbfile
+
+LINTXKBFILE = $(LINTLIBDIR)/llib-lxkbfile.ln
+
+     XKBCOMPCMD = $(BINDIR)/xkbcomp
+
+          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
+
+         DEPLIBS1 = $(DEPLIBS)
+         DEPLIBS2 = $(DEPLIBS)
+         DEPLIBS3 = $(DEPLIBS)
+         DEPLIBS4 = $(DEPLIBS)
+         DEPLIBS5 = $(DEPLIBS)
+         DEPLIBS6 = $(DEPLIBS)
+         DEPLIBS7 = $(DEPLIBS)
+         DEPLIBS8 = $(DEPLIBS)
+         DEPLIBS9 = $(DEPLIBS)
+         DEPLIBS10 = $(DEPLIBS)
+
+XMULIBONLY = -lXmu
+XMULIB = $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+
+        CONFIGDIR = $(LIBDIR)/config
+
+    USRLIBDIRPATH = $(USRLIBDIR)
+        LDPRELIBS = -L$(USRLIBDIR)
+       LDPOSTLIBS =
+     TOP_INCLUDES = -I$(INCROOT) $(TOP_X_INCLUDES)
+  PROJECT_DEFINES =
+
+CXXPROJECT_DEFINES =
+
+# ----------------------------------------------------------------------
+# start of Imakefile
+
+#
+#
+# Copyright (C) 1989-95 GROUPE BULL
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files
+# (the "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to permit
+# persons to whom the Software is furnished to do so, subject to the
+# following conditions:
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN 0 EVENT SHALL GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+# DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of GROUPE BULL shall not be
+# used in advertising or otherwise to promote the sale, use or other
+# dealings in this Software without prior written authorization from
+# GROUPE BULL.
+#
+
+#
+# XPM Imakefile - Arnaud LE HORS
+#
+
+# You may need to modify the following DEFINES variable as follows:
+# if your system doesn't provide strcasecmp add -DNEED_STRCASECMP
+# if your system doesn't provide strdup add -DNEED_STRDUP
+# if your system doesn't provide pipe add -DNO_ZPIPE
+# if on your system sprintf doesn't return the number of bytes transmitted
+# add -DVOID_SPRINTF
+
+DEFINES = $(STRDUPDEF) $(STRCASECMPDEF) $(SPRINTFDEF) $(ZPIPEDEF)
+
+# You can uncomment the following line to avoid building the shared lib
+# IMAKE_DEFINES = -DSharedLibXpm=0
+
+#
+# Normally the following part should not need to be edited
+#
+
+     SUBDIRS = lib sxpm cxpm
+
+all::
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	echo "making" all "in $(CURRENT_DIR)/$$i..."; \
+	(cd $$i &&  $(MAKE) $(MFLAGS) "CDEBUGFLAGS=$(CDEBUGFLAGS)" "DEFINES=$(DEFINES)" all); \
+	done
+
+depend::
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	echo "depending" "in $(CURRENT_DIR)/$$i..."; \
+	(cd $$i &&  $(MAKE) $(MFLAGS)  depend); \
+	done
+
+# ----------------------------------------------------------------------
+# common rules for all Makefiles - do not edit
+
+.c.i:
+	$(RM) $@
+	 $(CC) -E $(CFLAGS) $(_NOOP_) $*.c > $@
+
+emptyrule::
+
+clean::
+	$(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut  "#"*
+
+Makefile::
+	-@if [ -f Makefile ]; then set -x; \
+	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
+	else exit 0; fi
+	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
+
+tags::
+	$(TAGS) -w *.[ch]
+	$(TAGS) -xw *.[ch] > TAGS
+
+man_keywords::
+
+# ----------------------------------------------------------------------
+# rules for building in SUBDIRS - do not edit
+
+install::
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	echo "installing" "in $(CURRENT_DIR)/$$i..."; \
+	(cd $$i &&  $(MAKE) $(MFLAGS) DESTDIR=$(DESTDIR) install); \
+	done
+
+install.man::
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
+	(cd $$i &&  $(MAKE) $(MFLAGS) DESTDIR=$(DESTDIR) install.man); \
+	done
+
+clean::
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
+	(cd $$i &&  $(MAKE) $(MFLAGS)  clean); \
+	done
+
+tags::
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	echo "tagging" "in $(CURRENT_DIR)/$$i..."; \
+	(cd $$i &&  $(MAKE) $(MFLAGS) TAGS='$(TAGS)' tags); \
+	done
+
+$(ONESUBDIR)/Makefile:
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[n]*) executeit="no";; esac; done; \
+	cd $(ONESUBDIR); \
+	if [ "$$executeit" != "no" ]; then \
+	$(IMAKE_CMD) -DTOPDIR=$(IMAKETOP) -DCURDIR=$(ONECURDIR)$(ONESUBDIR); \
+	fi;
+
+Makefiles::
+	-@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[n]*) executeit="no";; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	case "$(CURRENT_DIR)" in \
+	.) curdir= ;; \
+	*) curdir=$(CURRENT_DIR)/ ;; \
+	esac; \
+	echo "making Makefiles in $$curdir$$i..."; \
+	itmp=`echo $$i | sed -e 's;^\./;;g' -e 's;/\./;/;g'`; \
+	curtmp="$(CURRENT_DIR)" \
+	toptmp=""; \
+	case "$$itmp" in \
+	../?*) \
+	while echo "$$itmp" | grep '^\.\./' > /dev/null;\
+	do \
+	toptmp="/`basename $$curtmp`$$toptmp"; \
+	curtmp="`dirname $$curtmp`"; \
+	itmp="`echo $$itmp | sed 's;\.\./;;'`"; \
+	done \
+	;; \
+	esac; \
+	case "$$itmp" in \
+	*/?*/?*/?*/?*)	newtop=../../../../..;; \
+	*/?*/?*/?*)	newtop=../../../..;; \
+	*/?*/?*)	newtop=../../..;; \
+	*/?*)		newtop=../..;; \
+	*)		newtop=..;; \
+	esac; \
+	newtop="$$newtop$$toptmp"; \
+	case "$(TOP)" in \
+	/?*) imaketop=$(TOP) \
+	imakeprefix= ;; \
+	.) imaketop=$$newtop \
+	imakeprefix=$$newtop/ ;; \
+	*) imaketop=$$newtop/$(TOP) \
+	imakeprefix=$$newtop/ ;; \
+	esac; \
+	$(RM) $$i/Makefile.bak; \
+	if [ -f $$i/Makefile ]; then \
+	echo "	$(MV) Makefile Makefile.bak"; \
+	if [ "$$executeit" != "no" ]; then \
+	$(MV) $$i/Makefile $$i/Makefile.bak; \
+	fi; \
+	fi; \
+	$(MAKE) $(MFLAGS) $(MAKE_OPTS) ONESUBDIR=$$i ONECURDIR=$$curdir IMAKETOP=$$imaketop IMAKEPREFIX=$$imakeprefix $$i/Makefile; \
+	cd $$i;	\
+	$(MAKE) $(MFLAGS) Makefiles; \
+	cd $$newtop; \
+	done
+
+includes::
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[ik]*) set +e;; esac; done; \
+	for i in $(SUBDIRS) ;\
+	do \
+	echo including "in $(CURRENT_DIR)/$$i..."; \
+	(cd $$i &&  $(MAKE) $(MFLAGS)  includes); \
+	done
+
+# ----------------------------------------------------------------------
+# dependencies generated by makedepend
+
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/Makefile.noX rxvt-2.7.2/W11/xpm-3.4k/Makefile.noX
--- rxvt-2.7.2-orig/W11/xpm-3.4k/Makefile.noX	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/Makefile.noX	Mon May 14 08:23:10 2001
@@ -0,0 +1,70 @@
+#
+#  Copyright (C) 1989-95 GROUPE BULL
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#  GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+#  AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+#  Except as contained in this notice, the name of GROUPE BULL shall not be
+#  used in advertising or otherwise to promote the sale, use or other dealings
+#  in this Software without prior written authorization from GROUPE BULL.
+#
+
+#
+# XPM Makefile - Arnaud LE HORS
+#
+
+# NOTE: if the build fails on your system using this Makefile, you need to check
+# and possibly edit each of the Makefile in the subdirs lib, sxpm, and cxpm.
+
+SUBDIRS= lib sxpm cxpm
+
+MAKE=make
+MFLAGS=-f Makefile.noX
+INSTALL= install -c
+CURRENT_DIR=.
+
+all::
+	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
+	for i in $(SUBDIRS) ;\
+	do \
+	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
+	$(MAKE) $(MFLAGS)  all); \
+	done
+clean::
+	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
+	for i in $(SUBDIRS) ;\
+	do \
+	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
+	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
+	done
+
+
+install::
+	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
+	for i in $(SUBDIRS) ;\
+	do \
+	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
+	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' INSTALL='$(INSTALL)' install); \
+	done
+
+install.man::
+	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
+	for i in $(SUBDIRS) ;\
+	do \
+	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
+	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
+	done
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/README.AMIGA rxvt-2.7.2/W11/xpm-3.4k/README.AMIGA
--- rxvt-2.7.2-orig/W11/xpm-3.4k/README.AMIGA	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/README.AMIGA	Mon May 14 08:23:10 2001
@@ -0,0 +1,10 @@
+The XPM library for Amiga works best with AmigaOS 3.x, but will work
+(with limited color support) with earlier OS versions too. It can be
+compiled with both SAS/C and GCC (makefiles are included).
+
+All functions except the Xpm*Pixmap* functions are supported.
+
+I have also written some Amiga-specific utility functions (not
+included). Contact me if you would like to have them too.
+
+-Lorens Younes (d93-hyo@nada.kth.se)
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/README.MSW rxvt-2.7.2/W11/xpm-3.4k/README.MSW
--- rxvt-2.7.2-orig/W11/xpm-3.4k/README.MSW	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/README.MSW	Mon May 14 08:23:10 2001
@@ -0,0 +1,127 @@
+
+README.MSW	hedu@cul-ipn.uni-kiel.de	5/94
+
+		The XPM library for MS-Windows
+		
+Motivated by the wxWindows library, which is a (freely available) toolkit
+for developing multi-platform, graphical applications from the same body 
+of C++ code, I wanted to have XPM pixmaps for MS-windows. Instead of rewriting 
+a XPM-parser I managed to port the XPM-library-code to MS-windows.
+Thanks to Anaud Le Hors this became a part of the official XPM-library.
+
+Until now it's only used together with wxWindows. And even there it's more 
+a kind of beta. But it should be possible to run it as a simple libxpm.a 
+without wxWindows.
+
+The key is a transformation of some X types plus some basic X functions.
+There is not yet a special MSW-API, so you should know the X types used.
+
+The following is done in simx.h:
+
+typedef HDC Display;
+typedef COLORREF Pixel;
+
+typedef struct {
+    Pixel pixel;
+    BYTE red, green, blue;
+}      XColor;
+
+typedef struct {
+    HBITMAP bitmap;
+    unsigned int width;
+    unsigned int height;
+    unsigned int depth;
+}      XImage;
+
+With these defines and the according functions from simx.c you can call
+XPM-functions the way it's done under X windows. It can look like this:
+
+	ErrorStatus=XpmCreateImageFromData(&dc, data, 
+				&ximage,(XImage **)NULL, &xpmAttr);
+	ms_bitmap = ximage->bitmap;
+	// releases the malloc,but do not destroy the bitmap
+	XImageFree(ximage);
+	
+Supported functions are the Xpm*Image* but not the Xpm*Pixmap*.
+
+DRAWBACKS:
+The main drawback is the missing support for Colormaps! There was nothing for
+it in wxWindows, so I did not know how to deal with Colormaps.
+
+The size of the pixmaps is bounded by malloc() (width*height*2 < 64K).
+
+Close colors do not look that close. But that seems to be the window system.
+
+Neither a special API for MSW nor a special MSW documentation other than this.
+(I can only point you to wxxpm as an example , see below.)
+
+INSTALLATION:
+There is not yet a makefile with it. Simply take all the *.c files
+into your project except the files related to Pixmap operations: *P*.c.
+!!!You MUST set FOR_MSW on the preprocessor options!!!
+(You might uncomment NEED_STRCASECMP in xpm.h if it's in your lib)
+This should compile into libxpm.a. Good luck...
+
+FTP:  
+wxWindows is currently available from the Artificial Intelligence
+Applications Institute (University of Edinburgh) by anonymous FTP.
+	skye.aiai.ed.ac.uk  pub/wxwin/
+or read http://burray.aiai.ed.ac.uk/aiai/aiai.html
+
+wxxpm, XPM support for wxWindows, the latest version is available at
+	yoda.cul-ipn.uni-kiel.de pub/wxxpm/
+	and maybe in the contrib or tools of wxWindows
+	
+Please contact me if you have suggestions, comments or problems!
+
+================================================================
+Some fixes and comments by Jan Wielemaker (jan@swi.psy.uva.nl),
+Oct 24, 1996:
+
+	* Please try not to disturb me on this, XPM is not my
+	piece of cake.
+
+	* Hermann Dunkel has appearently moved in virtual space.
+
+Changes:
+
+	* I've used the xpm package under NT 4.0 and MSVC++ 4.2.
+
+	* I've made a big performance improvement in 
+	ParseAndPutPixels(), fixed creation of the mask in
+	SetColor() in create.c.  I looked into XCreateImage()
+	in simx.c, but commented out my improvement for reasons
+	you'll find there.  If you know what is going on, statement
+	(1) does not apply to you.
+
+Comments on installation:
+
+	* Donot include the to/from pixmap files into the project.
+	These are the ones containing a capital P somewhere in their
+	name.  You can also first include all, and then remove all
+	the files you get errors on :-)
+
+	* The DC that is requested should be a valid memory DC, thus
+	CreateCompatibleDC(NULL) provides a good generic one, but
+	GetDC(NULL) doesn't!  This costed me some time.
+
+	* The real difficulty is using the mask, mostly due to the
+	bad documentation.  If 95 or NT is your target, use:
+
+	MaskBlt(context.hdc,	// Destination DC
+		x, y, w, h,	// Destination area
+		mhdc,		// Memory DC with the image selected
+		sx, sy,		// Source X,Y
+		msk,		// HBITMAP of the mask
+		sx, sy,		// Mask X,Y
+		MAKEROP4(SRCPAINT, SRCCOPY));	// The magic op code.
+================================================================
+
+
+--
+   ////|\\\\   \\\\\\  Hermann Dunkel
+     O   O     //////  IPN Uni Kiel, Germany
+       |       \\\\\\  Tel: +49 431 / 880 3144
+     \___/     //////  E-mail: hedu@cul-ipn.uni-kiel.de
+      \_/      \\\\\\  X.400 : c=de;a=d400;p=uni-kiel;ou=nw-didaktik;s=dunkel
+
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/README.html rxvt-2.7.2/W11/xpm-3.4k/README.html
--- rxvt-2.7.2-orig/W11/xpm-3.4k/README.html	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/README.html	Mon May 14 08:23:10 2001
@@ -0,0 +1,303 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+<html lang="en">
+<HEAD>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+<TITLE>XPM README</TITLE>
+</HEAD>
+
+<body>
+<h1 align="center">XPM README</h1>
+
+<h2>Contents</h2>
+
+<ol>
+<li><a href="#sec1">What Is XPM?</a>
+<li><a href="#sec2">Where to get XPM?</a>
+<li><a href="#sec3">Documentation</a>
+<li><a href="#sec4">Installation</a>
+<ol>
+<li><a href="#sec4.1">With imake</a>
+<li><a href="#sec4.2">Without imake</a>
+</ol>
+<li><a href="#sec5">SXPM</a>
+<li><a href="#sec6">CXPM</a>
+<li><a href="#sec7">Other Tools</a>
+<li><a href="#sec8">Discussion</a>
+<li><a href="#copy">Copyright</a>
+</ol>
+
+
+<h2><a name="sec1">1. What Is XPM?</a></h2>
+<p>
+XPM (X PixMap) is a format for storing/retrieving X pixmaps to/from files.
+<p>
+Here is provided a library containing a set of four functions, similar to the
+X bitmap functions as defined in the Xlib: <code>XpmCreatePixmapFromData</code>,
+<code>XpmCreateDataFromPixmap</code>, <code>XpmReadFileToPixmap</code> and <code>XpmWriteFileFromPixmap</code> for
+respectively including, storing, reading and writing this format, plus four
+other: <code>XpmCreateImageFromData</code>, <code>XpmCreateDataFromImage</code>, <code>XpmReadFileToImage</code> and
+<code>XpmWriteFileFromImage</code> for working with images instead of pixmaps.
+<p>
+This new version provides a C includable format, defaults for different types
+of display: monochrome/color/grayscale, hotspot coordinates and symbol names
+for colors for overriding default colors when creating the pixmap. It provides
+a mechanism for storing information while reading a file which is re-used
+while writing. This way comments, default colors and symbol names aren't lost.
+It also handles "transparent pixels" by returning a shape mask in addition to
+the created pixmap.
+<p>
+See the XPM Manual for details.
+
+
+<h2><a name="sec2">2. Where to get XPM?</a></h2>
+<p>
+New XPM updates are announced on the comp.windows.x newsgroup, and on the
+"xpm-talk" list and you can always consult the XPM Home page at <a
+href="http://www.inria.fr/koala/lehors/xpm.html">http://www.inria.fr/koala/lehors/xpm.html</a>
+<p>The latest "official" XPM release can always be found at:
+<br>Boston, USA: <a
+href="ftp://ftp.x.org/contrib">ftp://ftp.x.org/contrib</a>
+<br>Sophia Antipolis, France: <a
+href="ftp://koala.inria.fr/pub/xpm">ftp://koala.inria.fr/pub/xpm</a>
+
+
+<h2><a name="sec3">3. Documentation</a></h2>
+<p>
+Old users might read the <a href="CHANGES">CHANGES</a> file for a history
+of changes interesting the user.
+<p>
+Read the doc. The documentation is in PostScript format (<a
+href="doc/xpm.PS">doc/xpm.PS</a>) and has been produced with
+FrameMaker. The source files are available on request.
+<p>
+A <a href="FAQ.html">FAQ</a> (Frequently Asked Questions) is also provided,
+so if you experience any problem you should have a look at this file.
+
+
+<h2><a name="sec4">4. Installation</a></h2>
+<p>
+To obtain the XPM library, first uncompress and untar the compressed tar file
+in an appropriate directory.
+<p>
+Then you can either compile XPM via "imake" or in a stand-alone way.
+
+<h3><a name="sec4.1">4.1. With imake</a></h3>
+<p>
+	Imakefiles are provided to build both shared and unshared libraries.
+	However, building a shared lib is very OS dependent and often requires
+	specific files which are not available. Also config files are often not
+	set correctly for this task. So if it fails you can avoid trying to
+	build one and simply build the static library instead. In order to do
+	so you should edit the top Imakefile to add -DSharedLibXpm=NO to the
+	definition of IMAKE_DEFINES as described.
+<p>
+	The compilation and installation of the library and the sxpm program
+	should only require you to edit the top Imakefile. But you should do so
+	in order to specify the locations where the various files should be
+	installed and to set the DEFINES variable accordingly to your system.
+<p>
+	On Solaris 2.* the compilation works only in the native svr4
+	environment, avoid the bsd one or it won't compile. Especially you
+	should be using /opt/SUNWspro/bin/cc and not /usr/ucb/cc.
+	Also since the compiler is no longer part of the OS distribution a lot
+	of people use gcc instead. This is fine, but be aware that the imake
+	tool you get as part of the X Window System on a solaris box is
+	configured for cc. Therefore the compilation using the generated
+	Makefiles will not succeed unless you have changed the default
+	configuration. An easy work around is to directly edit the generated
+	lib/Makefile to change '-K pic' to '-fpic'. Fixing your imake
+	configuration would be better though.
+<p>
+	On Linux, if you do not use ELF yet you'd better get the binary
+	distribution available from sunsite. Because it's really a pain to
+	build a shared lib and the current XPM distribution doesn't contain
+	the jump files you would need to do so. On the other hand people have
+	had no problems building it using ELF.
+<p>
+	Then execute the following command:
+<pre>
+		xmkmf -a
+</pre>
+<p>
+	or if this option is not supported by your version of xmkmf:
+<pre>
+		xmkmf
+		make Makefiles
+		make includes
+		make depend		(optional)
+</pre>
+<p>
+	Then simply execute: 
+<pre>
+		make
+</pre>
+<p>
+	which will build the XPM library and the sxpm application. 
+	Then do:
+<pre>
+	     	make install
+		make install.man
+</pre>
+<p>
+	which will install the library and the sxpm program and man page.
+<p>
+	If it fails, be sure you have set the DEFINES correctly in the top
+	Imakefile to suit your machine.
+
+<h4>NOTE ON USING IMAKE:</h4>
+<p>
+	Building the XPM distribution with imake requires to have imake
+	<strong>correctly installed and configured</strong> on your
+	system. I do my best at tweaking the Imakefiles so they work with
+	as many imake flavors people might have as possible but there is
+	nothing I can do against wrong imake configurations. So if your
+	build fails using imake, don't send me email for advice. Get your
+	imake configuration fixed or forget about it!
+
+
+<h3><a name="sec4.2">4.2. Without imake</a></h3>
+<p>
+	A set of makefiles is provided for those who do not have imake
+	available on their system. However, this is only provided as a
+	convenience and you should be considered as a starting point and not as
+	something ready to use. These makefiles, called Makefile.noX, will most
+	likely require some editing in order be set accordingly to your system.
+<p>
+	Once this setting is done, you should be able to compile XPM, by
+	executing the following command:
+<pre>
+	        make -f Makefile.noX
+</pre>
+<p>
+	Then to install it, do:
+<pre>
+		make -f Makefile.noX install
+</pre>
+
+
+<h2><a name="sec5">5. SXPM</a></h2>
+<p>
+In addition to the library the sxpm tool is provided to show XPM file and
+convert them from XPM1 or XPM2 to XPM version 3. If you have previously done
+'make' or 'make all' you should already have it, otherwise just do:
+<pre>
+		      cd sxpm; make
+</pre>
+<p>
+This application shows you most of the features of XPM and its source can be
+used to quickly see how to use the provided functions.
+<p>
+By executing 'sxpm -help' you will get the usage.
+<p>
+Executing 'sxpm -plaid' will show a demo of the XpmCreatePixmapFromData
+function. The pixmap is created from the static variable plaid defined in the
+sxpm.c file. sxpm will end when you press the key 'q' in the created window.
+<p>
+Executing 'sxpm -plaid -sc lines_in_mix blue' will show the feature of
+overriding color symbols giving a colorname, executing 'sxpm -plaid -sp
+lines_in_mix 1' will show overriding giving a pixel value, and executing 'sxpm
+-plaid -cp red 0' will show overriding giving a color value.
+<p>
+Then you should try 'sxpm -plaid -o output' to get an output file using the
+XpmWriteFileFromPixmap function.
+<p>
+You can now try 'sxpm -plaid -o - -nod -rgb /usr/lib/X11/rgb.txt' to directly
+get the pixmap printed out on the standard output with colornames instead of
+rgb values.
+<p>
+Then you should try 'sxpm plaid.xpm' to use the XpmReadFileToPixmap function,
+and 'cat plaid_mask.xpm|sxpm' to see how "transparent pixels" are handled.
+<p>
+The XpmCreatePixmapFromData function is on purpose called without any XpmInfos
+flag to show the utility of this one. Indeed, compare the color section of the
+two files foo and bar obtained from 'sxpm -nod -plaid -o foo' and 'sxpm -nod
+plaid.xpm -o bar'. All the default colors and also the comments have been
+restored.
+<p>
+To end look at plaid_ext.xpm and try "sxpm -nod plaid_ext.xpm -v" to see how
+extensions are handled.
+<p>
+Of course, other combinations are allowed and should be tried. Thus, 'sxpm
+plaid.xpm -o output -nod' will show you how to convert a file from XPM1 or XPM2
+to a XPM version 3 using sxpm.
+<p>
+See the manual page for more detail.
+
+
+<h2><a name="sec6">6. CXPM</a></h2>
+<p>
+The cxpm tool is provided to help you figure out whether an XPM file is correct
+or not with regard to its format. If you have previously done 'make' or
+'make all' you should already have it, otherwise just do:
+<pre>
+		      cd cxpm; make
+</pre>
+<p>
+The related man page will tell you everything about it but here is a simple
+example of what it does:
+<pre>
+$ ./cxpm bogus_pixmap
+Xpm Error: Invalid XPM file.
+Error found line 3 near character 5
+</pre>
+<p>
+It is pretty limited but at least, unlike sxpm, it gives you some hint on where
+the error occured within the file.
+
+
+<h2><a name="sec7">7. Other Tools</a></h2>
+<p>
+Several converters dealing with XPM and a pixmap editor can be found in the
+xpm-contrib distribution. Also I recommend the use of netpbm to do any kind of
+general image operations such as scaling, resizing, dithering, and to convert
+from and to any other image format.
+
+<h2><a name="sec8">8. Discussion</a></h2>
+<p>
+There is a mailing list to discuss about XPM which is <a
+href="mailto:xpm-talk@sophia.inria.fr">xpm-talk@sophia.inria.fr</a>.
+Any request to subscribe should be sent to <a
+href="mailto:xpm-talk-request@sophia.inria.fr">xpm-talk-request@sophia.inria.fr</a>.
+The archive of the xpm-talk list is available through the web at
+<a
+href="http://zenon.inria.fr/koala/xpm-talk-hypermail">http://zenon.inria.fr/koala/xpm-talk-hypermail</a>
+and through ftp at <a
+href="ftp://koala.inria.fr/pub/xpm/xpm-talk-archive">ftp://koala.inria.fr/pub/xpm/xpm-talk-archive</a>
+<p>
+Please mail any bug reports or modifications done, comments, suggestions,
+requests for updates or patches to port on another machine to:
+
+<p>Email: <a href="lehors@sophia.inria.fr">lehors@sophia.inria.fr</a>
+<br>Phone: +33 (0)4 93 65 78 89
+<br>Surface Mail:<br>
+Arnaud Le Hors<br>
+Inria BP.93<br>
+2004, Route des lucioles<br>
+06902 Sophia Antipolis Cedex<br>
+FRANCE
+
+
+<hr>
+<h2><a name="copy">Copyright (C) 1989-95 GROUPE BULL</a></h2>
+<p>
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to
+deal in the Software without restriction, including without limitation the
+rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+<p>
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+<p>
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+<p>
+Except as contained in this notice, the name of GROUPE BULL shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from GROUPE BULL.
+</body>
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/X11/xpm.h rxvt-2.7.2/W11/xpm-3.4k/X11/xpm.h
--- rxvt-2.7.2-orig/W11/xpm-3.4k/X11/xpm.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/X11/xpm.h	Mon May 14 08:23:10 2001
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* xpm.h:                                                                      *
+*                                                                             *
+*  XPM library                                                                *
+*  Include file                                                               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+/*
+ * The code related to AMIGA has been added by
+ * Lorens Younes (d93-hyo@nada.kth.se) 4/96
+ */
+
+#ifndef XPM_h
+#define XPM_h
+
+/*
+ * first some identification numbers:
+ * the version and revision numbers are determined with the following rule:
+ * SO Major number = LIB minor version number.
+ * SO Minor number = LIB sub-minor version number.
+ * e.g: Xpm version 3.2f
+ *      we forget the 3 which is the format number, 2 gives 2, and f gives 6.
+ *      thus we have XpmVersion = 2 and XpmRevision = 6
+ *      which gives  SOXPMLIBREV = 2.6
+ *
+ * Then the XpmIncludeVersion number is built from these numbers.
+ */
+#define XpmFormat 3
+#define XpmVersion 4
+#define XpmRevision 11
+#define XpmIncludeVersion ((XpmFormat * 100 + XpmVersion) * 100 + XpmRevision)
+
+#ifndef XPM_NUMBERS
+
+#ifdef FOR_MSW
+# define SYSV			/* uses memcpy string.h etc. */
+# include <malloc.h>
+# include "simx.h"		/* defines some X stuff using MSW types */
+#define NEED_STRCASECMP		/* at least for MSVC++ */
+#else /* FOR_MSW */
+# ifdef AMIGA
+#  include "amigax.h"
+# else /* not AMIGA */
+#  include <X11/Xlib.h>
+#  include <X11/Xutil.h>
+# endif /* not AMIGA */
+#endif /* FOR_MSW */
+
+/* let's define Pixel if it is not done yet */
+#if ! defined(_XtIntrinsic_h) && ! defined(PIXEL_ALREADY_TYPEDEFED)
+typedef unsigned long Pixel;	/* Index into colormap */
+# define PIXEL_ALREADY_TYPEDEFED
+#endif
+
+/* make sure we know whether function prototypes are needed or not */
+#ifndef NeedFunctionPrototypes
+# if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus)
+#  define NeedFunctionPrototypes 1
+# else
+#  define NeedFunctionPrototypes 0
+# endif
+#endif
+
+
+/* Return ErrorStatus codes:
+ * null     if full success
+ * positive if partial success
+ * negative if failure
+ */
+
+#define XpmColorError    1
+#define XpmSuccess       0
+#define XpmOpenFailed   -1
+#define XpmFileInvalid  -2
+#define XpmNoMemory     -3
+#define XpmColorFailed  -4
+
+typedef struct {
+    char *name;			/* Symbolic color name */
+    char *value;		/* Color value */
+    Pixel pixel;		/* Color pixel */
+}      XpmColorSymbol;
+
+typedef struct {
+    char *name;			/* name of the extension */
+    unsigned int nlines;	/* number of lines in this extension */
+    char **lines;		/* pointer to the extension array of strings */
+}      XpmExtension;
+
+typedef struct {
+    char *string;		/* characters string */
+    char *symbolic;		/* symbolic name */
+    char *m_color;		/* monochrom default */
+    char *g4_color;		/* 4 level grayscale default */
+    char *g_color;		/* other level grayscale default */
+    char *c_color;		/* color default */
+}      XpmColor;
+
+typedef struct {
+    unsigned int width;		/* image width */
+    unsigned int height;	/* image height */
+    unsigned int cpp;		/* number of characters per pixel */
+    unsigned int ncolors;	/* number of colors */
+    XpmColor *colorTable;	/* list of related colors */
+    unsigned int *data;		/* image data */
+}      XpmImage;
+
+typedef struct {
+    unsigned long valuemask;	/* Specifies which attributes are defined */
+    char *hints_cmt;		/* Comment of the hints section */
+    char *colors_cmt;		/* Comment of the colors section */
+    char *pixels_cmt;		/* Comment of the pixels section */
+    unsigned int x_hotspot;	/* Returns the x hotspot's coordinate */
+    unsigned int y_hotspot;	/* Returns the y hotspot's coordinate */
+    unsigned int nextensions;	/* number of extensions */
+    XpmExtension *extensions;	/* pointer to array of extensions */
+}      XpmInfo;
+
+typedef int (*XpmAllocColorFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    char*			/* colorname */,
+    XColor*			/* xcolor */,
+    void*			/* closure */
+#endif
+);
+
+typedef int (*XpmFreeColorsFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    Pixel*			/* pixels */,
+    int				/* npixels */,
+    void*			/* closure */
+#endif
+);
+
+typedef struct {
+    unsigned long valuemask;		/* Specifies which attributes are
+					   defined */
+
+    Visual *visual;			/* Specifies the visual to use */
+    Colormap colormap;			/* Specifies the colormap to use */
+    unsigned int depth;			/* Specifies the depth */
+    unsigned int width;			/* Returns the width of the created
+					   pixmap */
+    unsigned int height;		/* Returns the height of the created
+					   pixmap */
+    unsigned int x_hotspot;		/* Returns the x hotspot's
+					   coordinate */
+    unsigned int y_hotspot;		/* Returns the y hotspot's
+					   coordinate */
+    unsigned int cpp;			/* Specifies the number of char per
+					   pixel */
+    Pixel *pixels;			/* List of used color pixels */
+    unsigned int npixels;		/* Number of used pixels */
+    XpmColorSymbol *colorsymbols;	/* List of color symbols to override */
+    unsigned int numsymbols;		/* Number of symbols */
+    char *rgb_fname;			/* RGB text file name */
+    unsigned int nextensions;		/* Number of extensions */
+    XpmExtension *extensions;		/* List of extensions */
+
+    unsigned int ncolors;               /* Number of colors */
+    XpmColor *colorTable;               /* List of colors */
+/* 3.2 backward compatibility code */
+    char *hints_cmt;                    /* Comment of the hints section */
+    char *colors_cmt;                   /* Comment of the colors section */
+    char *pixels_cmt;                   /* Comment of the pixels section */
+/* end 3.2 bc */
+    unsigned int mask_pixel;            /* Color table index of transparent
+                                           color */
+
+    /* Color Allocation Directives */
+    Bool exactColors;			/* Only use exact colors for visual */
+    unsigned int closeness;		/* Allowable RGB deviation */
+    unsigned int red_closeness;		/* Allowable red deviation */
+    unsigned int green_closeness;	/* Allowable green deviation */
+    unsigned int blue_closeness;	/* Allowable blue deviation */
+    int color_key;			/* Use colors from this color set */
+
+    Pixel *alloc_pixels;		/* Returns the list of alloc'ed color
+					   pixels */
+    int nalloc_pixels;			/* Returns the number of alloc'ed
+					   color pixels */
+
+    Bool alloc_close_colors;    	/* Specify whether close colors should
+					   be allocated using XAllocColor
+					   or not */
+    int bitmap_format;			/* Specify the format of 1bit depth
+					   images: ZPixmap or XYBitmap */
+
+    /* Color functions */
+    XpmAllocColorFunc alloc_color;	/* Application color allocator */
+    XpmFreeColorsFunc free_colors;	/* Application color de-allocator */
+    void *color_closure;		/* Application private data to pass to
+					   alloc_color and free_colors */
+
+}      XpmAttributes;
+
+/* XpmAttributes value masks bits */
+#define XpmVisual	   (1L<<0)
+#define XpmColormap	   (1L<<1)
+#define XpmDepth	   (1L<<2)
+#define XpmSize		   (1L<<3)	/* width & height */
+#define XpmHotspot	   (1L<<4)	/* x_hotspot & y_hotspot */
+#define XpmCharsPerPixel   (1L<<5)
+#define XpmColorSymbols	   (1L<<6)
+#define XpmRgbFilename	   (1L<<7)
+/* 3.2 backward compatibility code */
+#define XpmInfos	   (1L<<8)
+#define XpmReturnInfos	   XpmInfos
+/* end 3.2 bc */
+#define XpmReturnPixels	   (1L<<9)
+#define XpmExtensions      (1L<<10)
+#define XpmReturnExtensions XpmExtensions
+
+#define XpmExactColors     (1L<<11)
+#define XpmCloseness	   (1L<<12)
+#define XpmRGBCloseness	   (1L<<13)
+#define XpmColorKey	   (1L<<14)
+
+#define XpmColorTable      (1L<<15)
+#define XpmReturnColorTable XpmColorTable
+
+#define XpmReturnAllocPixels (1L<<16)
+#define XpmAllocCloseColors (1L<<17)
+#define XpmBitmapFormat    (1L<<18)
+
+#define XpmAllocColor      (1L<<19)
+#define XpmFreeColors      (1L<<20)
+#define XpmColorClosure    (1L<<21)
+
+
+/* XpmInfo value masks bits */
+#define XpmComments        XpmInfos
+#define XpmReturnComments  XpmComments
+
+/* XpmAttributes mask_pixel value when there is no mask */
+#ifndef FOR_MSW
+#define XpmUndefPixel 0x80000000
+#else
+/* int is only 16 bit for MSW */
+#define XpmUndefPixel 0x8000
+#endif
+
+/*
+ * color keys for visual type, they must fit along with the number key of
+ * each related element in xpmColorKeys[] defined in XpmI.h
+ */
+#define XPM_MONO	2
+#define XPM_GREY4	3
+#define XPM_GRAY4	3
+#define XPM_GREY 	4
+#define XPM_GRAY 	4
+#define XPM_COLOR	5
+
+
+/* macros for forward declarations of functions with prototypes */
+#if NeedFunctionPrototypes
+#define FUNC(f, t, p) extern t f p
+#define LFUNC(f, t, p) static t f p
+#else
+#define FUNC(f, t, p) extern t f()
+#define LFUNC(f, t, p) static t f()
+#endif
+
+
+/*
+ * functions declarations
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* FOR_MSW, all ..Pixmap.. are excluded, only the ..XImage.. are used */
+/* Same for Amiga! */
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromData, int, (Display *display,
+					Drawable d,
+					char **data,
+					Pixmap *pixmap_return,
+					Pixmap *shapemask_return,
+					XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromPixmap, int, (Display *display,
+					char ***data_return,
+					Pixmap pixmap,
+					Pixmap shapemask,
+					XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToPixmap, int, (Display *display,
+				    Drawable d,
+				    char *filename,
+				    Pixmap *pixmap_return,
+				    Pixmap *shapemask_return,
+				    XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromPixmap, int, (Display *display,
+				       char *filename,
+				       Pixmap pixmap,
+				       Pixmap shapemask,
+				       XpmAttributes *attributes));
+#endif
+
+    FUNC(XpmCreateImageFromData, int, (Display *display,
+				       char **data,
+				       XImage **image_return,
+				       XImage **shapemask_return,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromImage, int, (Display *display,
+				       char ***data_return,
+				       XImage *image,
+				       XImage *shapeimage,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToImage, int, (Display *display,
+				   char *filename,
+				   XImage **image_return,
+				   XImage **shapeimage_return,
+				   XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromImage, int, (Display *display,
+				      char *filename,
+				      XImage *image,
+				      XImage *shapeimage,
+				      XpmAttributes *attributes));
+
+    FUNC(XpmCreateImageFromBuffer, int, (Display *display,
+					 char *buffer,
+					 XImage **image_return,
+					 XImage **shapemask_return,
+					 XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromBuffer, int, (Display *display,
+					  Drawable d,
+					  char *buffer,
+					  Pixmap *pixmap_return,
+					  Pixmap *shapemask_return,
+					  XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromImage, int, (Display *display,
+					 char **buffer_return,
+					 XImage *image,
+					 XImage *shapeimage,
+					 XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromPixmap, int, (Display *display,
+					  char **buffer_return,
+					  Pixmap pixmap,
+					  Pixmap shapemask,
+					  XpmAttributes *attributes));
+#endif
+    FUNC(XpmReadFileToBuffer, int, (char *filename, char **buffer_return));
+    FUNC(XpmWriteFileFromBuffer, int, (char *filename, char *buffer));
+
+    FUNC(XpmReadFileToData, int, (char *filename, char ***data_return));
+    FUNC(XpmWriteFileFromData, int, (char *filename, char **data));
+
+    FUNC(XpmAttributesSize, int, ());
+    FUNC(XpmFreeAttributes, void, (XpmAttributes *attributes));
+    FUNC(XpmFreeExtensions, void, (XpmExtension *extensions,
+				   int nextensions));
+
+    FUNC(XpmFreeXpmImage, void, (XpmImage *image));
+    FUNC(XpmFreeXpmInfo, void, (XpmInfo *info));
+    FUNC(XpmGetErrorString, char *, (int errcode));
+    FUNC(XpmLibraryVersion, int, ());
+
+    /* XpmImage functions */
+    FUNC(XpmReadFileToXpmImage, int, (char *filename,
+				      XpmImage *image,
+				      XpmInfo *info));
+
+    FUNC(XpmWriteFileFromXpmImage, int, (char *filename,
+					 XpmImage *image,
+					 XpmInfo *info));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromXpmImage, int, (Display *display,
+					    Drawable d,
+					    XpmImage *image,
+					    Pixmap *pixmap_return,
+					    Pixmap *shapemask_return,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateImageFromXpmImage, int, (Display *display,
+					   XpmImage *image,
+					   XImage **image_return,
+					   XImage **shapeimage_return,
+					   XpmAttributes *attributes));
+
+    FUNC(XpmCreateXpmImageFromImage, int, (Display *display,
+					   XImage *image,
+					   XImage *shapeimage,
+					   XpmImage *xpmimage,
+					   XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreateXpmImageFromPixmap, int, (Display *display,
+					    Pixmap pixmap,
+					    Pixmap shapemask,
+					    XpmImage *xpmimage,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateDataFromXpmImage, int, (char ***data_return,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromData, int, (char **data,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromBuffer, int, (char *buffer,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmCreateBufferFromXpmImage, int, (char **buffer_return,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmGetParseError, int, (char *filename,
+				 int *linenum_return,
+				 int *charnum_return));
+
+    FUNC(XpmFree, void, (void *ptr));
+
+#ifdef __cplusplus
+} /* for C++ V2.0 */
+#endif
+
+
+/* backward compatibility */
+
+/* for version 3.0c */
+#define XpmPixmapColorError  XpmColorError
+#define XpmPixmapSuccess     XpmSuccess
+#define XpmPixmapOpenFailed  XpmOpenFailed
+#define XpmPixmapFileInvalid XpmFileInvalid
+#define XpmPixmapNoMemory    XpmNoMemory
+#define XpmPixmapColorFailed XpmColorFailed
+
+#define XpmReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XpmWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+
+/* for version 3.0b */
+#define PixmapColorError  XpmColorError
+#define PixmapSuccess     XpmSuccess
+#define PixmapOpenFailed  XpmOpenFailed
+#define PixmapFileInvalid XpmFileInvalid
+#define PixmapNoMemory    XpmNoMemory
+#define PixmapColorFailed XpmColorFailed
+
+#define ColorSymbol XpmColorSymbol
+
+#define XReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+#define XCreatePixmapFromData(dpy, d, data, pix, mask, att) \
+    XpmCreatePixmapFromData(dpy, d, data, pix, mask, att)
+#define XCreateDataFromPixmap(dpy, data, pix, mask, att) \
+    XpmCreateDataFromPixmap(dpy, data, pix, mask, att)
+
+#endif /* XPM_NUMBERS */
+#endif
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Imakefile rxvt-2.7.2/W11/xpm-3.4k/cxpm/Imakefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Imakefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/cxpm/Imakefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,66 @@
+XCOMM
+XCOMM
+XCOMM Copyright (C) 1998 Arnaud LE HORS
+XCOMM
+XCOMM Permission is hereby granted, free of charge, to any person obtaining a
+XCOMM copy of this software and associated documentation files
+XCOMM (the "Software"), to deal in the Software without restriction, including
+XCOMM without limitation the rights to use, copy, modify, merge, publish,
+XCOMM distribute, sublicense, and/or sell copies of the Software, and to permit
+XCOMM persons to whom the Software is furnished to do so, subject to the
+XCOMM following conditions:
+XCOMM The above copyright notice and this permission notice shall be included
+XCOMM in all copies or substantial portions of the Software.
+XCOMM
+XCOMM THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+XCOMM OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+XCOMM MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+XCOMM IN NO EVENT SHALL Arnaud LE HORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+XCOMM OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+XCOMM ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+XCOMM OTHER DEALINGS IN THE SOFTWARE.
+XCOMM
+XCOMM Except as contained in this notice, the name of Arnaud LE HORS shall not
+XCOMM be used in advertising or otherwise to promote the sale, use or other
+XCOMM dealings in this Software without prior written authorization from
+XCOMM Arnaud LE HORS.
+XCOMM
+
+XCOMM
+XCOMM XPM Imakefile - Arnaud LE HORS
+XCOMM
+
+XCOMM default locations
+#ifndef XpmBinDir
+#define XpmBinDir $(BINDIR)
+#endif
+#ifndef XpmManDir
+#define XpmManDir $(MANDIR)
+#endif
+#ifndef XpmIncDir
+#define XpmIncDir $(BUILDINCTOP)
+#endif
+
+      XPMBINDIR = XpmBinDir
+      XPMMANDIR = XpmManDir
+      XPMINCDIR = XpmIncDir
+
+       INCLUDES = -I$(BUILDINCDIR) -I$(XPMINCDIR)
+
+#ifdef OsNameDefines
+OS_NAME_DEFINES = OsNameDefines
+#endif
+
+          SRCS = cxpm.c
+          OBJS = cxpm.o
+
+#if (ProjectX < 6)
+AllTarget(cxpm)
+#else
+AllTarget(ProgramTargetName(cxpm))
+#endif
+NormalProgramTarget(cxpm,$(OBJS),$(DEPLIB),$(LOCAL_LIBRARIES),)
+InstallProgram(cxpm,$(XPMBINDIR))
+InstallManPage(cxpm,$(XPMMANDIR))
+DependTarget()
+LintTarget()
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Makefile rxvt-2.7.2/W11/xpm-3.4k/cxpm/Makefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Makefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/cxpm/Makefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,597 @@
+# Makefile generated by imake - do not edit!
+# $TOG: imake.c /main/104 1998/03/24 12:45:15 kaleb $
+
+# ----------------------------------------------------------------------
+# Makefile generated from "Imake.tmpl" and <Imakefile>
+# $TOG: Imake.tmpl /main/249 1997/10/13 15:28:56 kaleb $
+#
+
+all::
+
+.SUFFIXES: .i
+
+# $TOG: Imake.cf /main/30 1998/04/28 13:55:25 barstow $
+
+# -----------------------------------------------------------------------
+# site-specific configuration parameters that need to come before
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ----------------------------------------------------------------------
+# platform-specific configuration parameters - edit cygwin.cf to change
+
+# platform:  $XConsortium: cygwin.cf sos 1996/02/08 18:59:31 gildea $
+#
+# changes since b18 cygwin32 release
+#	- avoided tons of "not in XXX directory" messages;
+#	- dlls are built stripped;
+#	- search for cpp in a default location;
+#	- fixed problem with missed netinet/tcp.h;
+#	- xterm compiles and works;
+#	- more libs are built as a dlls;
+#	- all dlls have different base addresses;
+
+# $XConsortium: cygwin.rules /main/12 1996/01/03 14:51:18 kaleb $
+
+BASE_COUNTER=/tmp/DLL_BASE_COUNTER
+
+# ----------------------------------------------------------------------
+# site-specific configuration parameters that go after
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ---------------------------------------------------------------------
+# Imake rules for building libraries, programs, scripts, and data files
+# rules:  $TOG: Imake.rules /main/227 1998/02/02 12:07:57 kaleb $
+
+          PATHSEP = /
+            SHELL = /bin/sh
+
+              TOP = ..
+      CURRENT_DIR = cxpm
+
+            IMAKE = imake
+           DEPEND = makedepend
+        MKDIRHIER = mkdir -p
+    EXPORTLISTGEN =
+        CONFIGSRC = $(TOP)/config
+         IMAKESRC = $(CONFIGSRC)/imake
+        DEPENDSRC = $(CONFIGSRC)/makedepend
+
+          INCROOT = /usr/X11R6.4/include
+        USRLIBDIR = /usr/X11R6.4/lib
+         SHLIBDIR = /usr/X11R6.4/lib
+       LINTLIBDIR = $(USRLIBDIR)/lint
+          MANPATH = /usr/X11R6.4/man
+    MANSOURCEPATH = $(MANPATH)/man
+           MANDIR = $(MANSOURCEPATH)1
+        LIBMANDIR = $(MANSOURCEPATH)3
+       FILEMANDIR = $(MANSOURCEPATH)5
+       MISCMANDIR = $(MANSOURCEPATH)$(MISCMANSUFFIX)
+
+               AR = ar clq
+  BOOTSTRAPCFLAGS =
+               CC = gcc
+               AS = as
+
+.SUFFIXES: .cc
+
+              CXX = g++
+          CXXFILT = c++filt
+           CXXLIB =
+    CXXDEBUGFLAGS = -O2 -s -mpentium
+CXXDEPENDINCLUDES =
+ CXXEXTRA_DEFINES =
+CXXEXTRA_INCLUDES =
+   CXXSTD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(CXXPROJECT_DEFINES)
+       CXXOPTIONS =
+      CXXINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(CXXEXTRA_INCLUDES)
+       CXXDEFINES = $(CXXINCLUDES) $(CXXSTD_DEFINES) $(THREADS_CXXDEFINES) $(CXXEXTRA_DEFINES) $(DEFINES)
+         CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
+
+         COMPRESS = compress
+          GZIPCMD = gzip
+              CPP = gcc -E - $(STD_CPP_DEFINES)
+    PREPROCESSCMD = gcc -E $(STD_CPP_DEFINES)
+          INSTALL = install
+     INSTALLFLAGS = -c
+               LD = ld
+              LEX = flex -l
+           LEXLIB = -lfl
+             YACC = byacc
+           CCYACC = byacc
+             LINT = lint
+      LINTLIBFLAG = -C
+         LINTOPTS = -axz
+               LN = ln -s
+             MAKE = make
+               MV = mv
+               CP = cp
+
+           RANLIB = ranlib
+  RANLIBINSTFLAGS =
+
+               RM = rm -f
+        MANSUFFIX = 1x
+     LIBMANSUFFIX = 3x
+    FILEMANSUFFIX = 5x
+    MISCMANSUFFIX = 7
+
+            TROFF = psroff
+            NROFF = nroff
+         MSMACROS = -ms
+        MANMACROS = -man
+              TBL = tbl
+              EQN = eqn
+             NEQN = neqn
+              COL = col
+
+            DVIPS = dvips
+            LATEX = latex
+
+     STD_INCLUDES =
+  STD_CPP_DEFINES = -traditional -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+      STD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+ EXTRA_LOAD_FLAGS =
+  EXTRA_LDOPTIONS =
+  EXTRA_LIBRARIES =
+             TAGS = ctags
+
+    SHAREDCODEDEF =
+         SHLIBDEF =
+
+     SHLIBLDFLAGS =
+
+    PROTO_DEFINES = -DFUNCPROTO=15 -DNARROWPROTO
+
+     INSTPGMFLAGS = -s
+
+     INSTBINFLAGS = -m 0755
+     INSTUIDFLAGS = -s -m 4711
+     INSTLIBFLAGS = -m 0644
+     INSTINCFLAGS = -m 0444
+     INSTMANFLAGS = -m 0444
+     INSTDATFLAGS = -m 0444
+    INSTKMEMFLAGS = -s -m 4711
+
+      PROJECTROOT = /usr/X11R6.4
+
+      CDEBUGFLAGS = -O2 -s -mpentium
+        CCOPTIONS =
+
+      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
+       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(THREADS_DEFINES) $(DEFINES)
+           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(THREADS_CFLAGS) $(ALLDEFINES)
+        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES) $(DEPEND_DEFINES)
+         LDPRELIB = -L$(USRLIBDIR)
+        LDPOSTLIB =
+        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)  $(EXTRA_LDOPTIONS) $(THREADS_LDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+     CXXLDOPTIONS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(EXTRA_LDOPTIONS) $(THREADS_CXXLDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+
+           LDLIBS = $(LDPOSTLIBS) $(THREADS_LIBS) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
+
+           CCLINK = $(CC)
+
+          CXXLINK = $(CXX)
+
+     LDSTRIPFLAGS = -x
+   LDCOMBINEFLAGS = -r
+      DEPENDFLAGS =
+
+        MACROFILE = cygwin.cf
+           RM_CMD = $(RM)
+
+    IMAKE_DEFINES =
+
+         IRULESRC = $(CONFIGDIR)
+        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
+
+     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/X11.tmpl 			$(IRULESRC)/site.def $(IRULESRC)/$(MACROFILE) 			 $(EXTRA_ICONFIGFILES)
+
+# $TOG: X11.rules /main/4 1997/04/30 15:23:24 kaleb $
+
+# ----------------------------------------------------------------------
+# X Window System Build Parameters and Rules
+# $TOG: X11.tmpl /main/308 1998/06/16 15:14:24 msr $
+
+# -----------------------------------------------------------------------
+# X Window System make variables; these need to be coordinated with rules
+
+             XTOP = $(TOP)
+           BINDIR = /usr/X11R6.4/bin
+     BUILDINCROOT = $(TOP)/exports
+      BUILDINCDIR = $(BUILDINCROOT)/include
+      BUILDINCTOP = ../..
+      BUILDLIBDIR = $(TOP)/exports/lib
+      BUILDLIBTOP = ../..
+      BUILDBINDIR = $(TOP)/exports/bin
+      BUILDBINTOP = ../..
+    XBUILDINCROOT = $(XTOP)/exports
+     XBUILDINCDIR = $(XBUILDINCROOT)/include/X11
+     XBUILDINCTOP = ../../..
+     XBUILDBINDIR = $(XBUILDINCROOT)/bin
+           INCDIR = $(INCROOT)
+           ADMDIR = /usr/adm
+           LIBDIR = $(USRLIBDIR)/X11
+   TOP_X_INCLUDES = -I$(XPROJECTROOT)/include
+
+           VARDIR = /var/X11
+
+          FONTDIR = $(LIBDIR)/fonts
+         XINITDIR = $(LIBDIR)/xinit
+           XDMDIR = $(LIBDIR)/xdm
+           TWMDIR = $(LIBDIR)/twm
+           XSMDIR = $(LIBDIR)/xsm
+           NLSDIR = $(LIBDIR)/nls
+       XLOCALEDIR = $(LIBDIR)/locale
+        PEXAPIDIR = $(LIBDIR)/PEX
+      LBXPROXYDIR = $(LIBDIR)/lbxproxy
+  PROXYMANAGERDIR = $(LIBDIR)/proxymngr
+        XPRINTDIR = $(LIBDIR)/xserver
+      XAPPLOADDIR = $(LIBDIR)/app-defaults
+       FONTCFLAGS = -t
+
+     INSTAPPFLAGS = $(INSTDATFLAGS)
+
+              RGB = $(BINDIR)/rgb
+            FONTC = $(BINDIR)/bdftopcf
+        MKFONTDIR = $(BINDIR)/mkfontdir
+
+       DOCUTILSRC = $(XTOP)/doc/util
+       XDOCMACROS = $(DOCUTILSRC)/macros.t
+       XIDXMACROS = $(DOCUTILSRC)/indexmacros.t
+       PROGRAMSRC = $(TOP)/programs
+           LIBSRC = $(XTOP)/lib
+          FONTSRC = $(XTOP)/fonts
+       INCLUDESRC = $(BUILDINCROOT)/include
+      XINCLUDESRC = $(INCLUDESRC)/X11
+        SERVERSRC = $(XTOP)/programs/Xserver
+       CONTRIBSRC = $(XTOP)/../contrib
+   UNSUPPORTEDSRC = $(XTOP)/unsupported
+           DOCSRC = $(XTOP)/doc
+           RGBSRC = $(XTOP)/programs/rgb
+      BDFTOPCFSRC = $(PROGRAMSRC)/bdftopcf
+     MKFONTDIRSRC = $(PROGRAMSRC)/mkfontdir
+    FONTSERVERSRC = $(PROGRAMSRC)/xfs
+       FONTINCSRC = $(XTOP)/include/fonts
+        EXTINCSRC = $(XTOP)/include/extensions
+     TRANSCOMMSRC = $(LIBSRC)/xtrans
+   TRANS_INCLUDES = -I$(TRANSCOMMSRC)
+
+   CLIENTENVSETUP =
+
+# $XConsortium: WinLib.tmpl,v 1.1 94/01/08 18:32:51 rws Exp $
+
+          XLIBSRC = $(LIBSRC)/X11
+
+SOXLIBREV = 6.1
+DEPXONLYLIB =
+XONLYLIB =  -lX11
+
+LINTXONLY = $(LINTLIBDIR)/llib-lX11.ln
+
+         XLIBONLY = $(XONLYLIB)
+
+      XEXTLIBSRC = $(LIBSRC)/Xext
+
+SOXEXTREV = 6.4
+DEPEXTENSIONLIB =
+EXTENSIONLIB =  -lXext
+
+LINTEXTENSION = $(LINTLIBDIR)/llib-lXext.ln
+
+LINTEXTENSIONLIB = $(LINTEXTENSION)
+          DEPXLIB = $(DEPEXTENSIONLIB) $(DEPXONLYLIB)
+             XLIB = $(EXTENSIONLIB) $(XONLYLIB)
+         LINTXLIB = $(LINTXONLYLIB)
+
+         XAUTHSRC = $(LIBSRC)/Xau
+
+DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
+XAUTHLIB =  -lXau
+
+LINTXAUTH = $(LINTLIBDIR)/llib-lXau.ln
+
+      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
+
+DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
+XDMCPLIB =  -lXdmcp
+
+LINTXDMCP = $(LINTLIBDIR)/llib-lXdmcp.ln
+
+           XMUSRC = $(LIBSRC)/Xmu
+
+DEPXMULIB = $(USRLIBDIR)/libXmu.a
+XMULIB =  -lXmu
+
+LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
+
+       OLDXLIBSRC = $(LIBSRC)/oldX
+
+SOOLDXREV = 6.0
+DEPOLDXLIB =
+OLDXLIB =  -loldX
+
+LINTOLDX = $(LINTLIBDIR)/llib-loldX.ln
+
+         XPLIBSRC = $(LIBSRC)/Xp
+
+SOXPREV = 6.2
+DEPXPLIB =
+XPLIB =  -lXp
+
+LINTXP = $(LINTLIBDIR)/llib-lXp.ln
+
+       TOOLKITSRC = $(LIBSRC)/Xt
+
+DEPXTOOLONLYLIB = $(USRLIBDIR)/libXt.a
+XTOOLONLYLIB =  -lXt
+
+LINTXTOOLONLY = $(LINTLIBDIR)/llib-lXt.ln
+
+      DEPXTOOLLIB = $(DEPXTOOLONLYLIB) $(DEPSMLIB) $(DEPICELIB)
+         XTOOLLIB = $(XTOOLONLYLIB) $(SMLIB) $(ICELIB)
+     LINTXTOOLLIB = $(LINTXTOOLONLYLIB)
+
+       XALIBSRC = $(LIBSRC)/Xa
+
+SOXAREV = 1.0
+DEPXALIB =
+XALIB =  -lXa
+
+LINTXA = $(LINTLIBDIR)/llib-lXa.ln
+
+       AWIDGETSRC = $(LIBSRC)/Xaw
+
+DEPXAWLIB = $(USRLIBDIR)/libXaw.a
+XAWLIB =  -lXaw
+
+LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
+
+         XILIBSRC = $(LIBSRC)/Xi
+
+SOXINPUTREV = 6.0
+DEPXILIB =
+XILIB =  -lXi
+
+LINTXI = $(LINTLIBDIR)/llib-lXi.ln
+
+      XTESTLIBSRC = $(LIBSRC)/Xtst
+
+SOXTESTREV = 6.1
+DEPXTESTLIB =
+XTESTLIB =  -lXtst
+
+LINTXTEST = $(LINTLIBDIR)/llib-lXtst.ln
+
+        PEXLIBSRC = $(LIBSRC)/PEX5
+
+SOPEXREV = 6.0
+DEPPEXLIB =
+PEXLIB =  -lPEX5
+
+LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
+
+        XIELIBSRC = $(LIBSRC)/XIE
+
+SOXIEREV = 6.0
+DEPXIELIB =
+XIELIB =  -lXIE
+
+LINTXIE = $(LINTLIBDIR)/llib-lXIE.ln
+
+      PHIGSLIBSRC = $(LIBSRC)/PHIGS
+
+DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
+PHIGSLIB =  -lphigs
+
+LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
+
+DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
+XBSDLIB =  -lXbsd
+
+LINTXBSD = $(LINTLIBDIR)/llib-lXbsd.ln
+
+           ICESRC = $(LIBSRC)/ICE
+
+SOICEREV = 6.3
+DEPICELIB =
+ICELIB =  -lICE
+
+LINTICE = $(LINTLIBDIR)/llib-lICE.ln
+
+            SMSRC = $(LIBSRC)/SM
+
+SOSMREV = 6.0
+DEPSMLIB =
+SMLIB =  -lSM
+
+LINTSM = $(LINTLIBDIR)/llib-lSM.ln
+
+           XKEYSRC = $(LIBSRC)/Xkey
+
+SOXKEYREV = 6.0
+DEPXKEYLIB =
+XKEYLIB =  -lXkey
+
+LINTXKEY = $(LINTLIBDIR)/llib-lXkey.ln
+
+         FSLIBSRC = $(LIBSRC)/FS
+
+DEPFSLIB = $(USRLIBDIR)/libFS.a
+FSLIB =  -lFS
+
+LINTFS = $(LINTLIBDIR)/llib-lFS.ln
+
+         FONTLIBSRC = $(LIBSRC)/font
+
+DEPFONTLIB = $(USRLIBDIR)/libfont.a
+FONTLIB =  -lfont
+
+LINTFONT = $(LINTLIBDIR)/llib-lfont.ln
+
+    XKBFILELIBSRC = $(LIBSRC)/xkbfile
+
+DEPXKBFILELIB = $(USRLIBDIR)/libxkbfile.a
+XKBFILELIB =  -lxkbfile
+
+LINTXKBFILE = $(LINTLIBDIR)/llib-lxkbfile.ln
+
+     XKBCOMPCMD = $(BINDIR)/xkbcomp
+
+          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
+
+         DEPLIBS1 = $(DEPLIBS)
+         DEPLIBS2 = $(DEPLIBS)
+         DEPLIBS3 = $(DEPLIBS)
+         DEPLIBS4 = $(DEPLIBS)
+         DEPLIBS5 = $(DEPLIBS)
+         DEPLIBS6 = $(DEPLIBS)
+         DEPLIBS7 = $(DEPLIBS)
+         DEPLIBS8 = $(DEPLIBS)
+         DEPLIBS9 = $(DEPLIBS)
+         DEPLIBS10 = $(DEPLIBS)
+
+XMULIBONLY = -lXmu
+XMULIB = $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+
+        CONFIGDIR = $(LIBDIR)/config
+
+    USRLIBDIRPATH = $(USRLIBDIR)
+        LDPRELIBS = -L$(USRLIBDIR)
+       LDPOSTLIBS =
+     TOP_INCLUDES = -I$(INCROOT) $(TOP_X_INCLUDES)
+  PROJECT_DEFINES =
+
+CXXPROJECT_DEFINES =
+
+# ----------------------------------------------------------------------
+# start of Imakefile
+
+#
+#
+# Copyright (C) 1998 Arnaud LE HORS
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files
+# (the "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to permit
+# persons to whom the Software is furnished to do so, subject to the
+# following conditions:
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN 0 EVENT SHALL Arnaud LE HORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of Arnaud LE HORS shall not
+# be used in advertising or otherwise to promote the sale, use or other
+# dealings in this Software without prior written authorization from
+# Arnaud LE HORS.
+#
+
+#
+# XPM Imakefile - Arnaud LE HORS
+#
+
+# default locations
+
+      XPMBINDIR = $(BINDIR)
+      XPMMANDIR = $(MANDIR)
+      XPMINCDIR = $(BUILDINCTOP)
+
+       INCLUDES = -I$(BUILDINCDIR) -I$(XPMINCDIR)
+
+OS_NAME_DEFINES =
+
+          SRCS = cxpm.c
+          OBJS = cxpm.o
+
+all:: cxpm.exe
+
+all:: cxpm.exe
+cxpm.exe: $(OBJS) $(DEPLIB)
+	$(RM) $@
+	$(CCLINK) -o $@ $(LDOPTIONS) $(OBJS) $(LOCAL_LIBRARIES) $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
+
+clean::
+	$(RM) cxpm.exe
+
+install:: cxpm.exe
+	@if [ -d $(DESTDIR)$(XPMBINDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMBINDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTPGMFLAGS)  cxpm.exe $(DESTDIR)$(XPMBINDIR)/cxpm.exe
+
+install.man:: cxpm.man
+	@if [ -d $(DESTDIR)$(XPMMANDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMMANDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTMANFLAGS) cxpm.man $(DESTDIR)$(XPMMANDIR)/cxpm.$(MANSUFFIX)
+
+depend::
+	$(DEPEND) $(DEPENDFLAGS) -- $(ALLDEFINES) $(DEPEND_DEFINES) -- $(SRCS)
+
+lint:
+	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
+lint1:
+	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
+
+# ----------------------------------------------------------------------
+# common rules for all Makefiles - do not edit
+
+.c.i:
+	$(RM) $@
+	 $(CC) -E $(CFLAGS) $(_NOOP_) $*.c > $@
+
+emptyrule::
+
+clean::
+	$(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut  "#"*
+
+Makefile::
+	-@if [ -f Makefile ]; then set -x; \
+	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
+	else exit 0; fi
+	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
+
+tags::
+	$(TAGS) -w *.[ch]
+	$(TAGS) -xw *.[ch] > TAGS
+
+man_keywords::
+
+# ----------------------------------------------------------------------
+# empty rules for directories that do not have SUBDIRS - do not edit
+
+install::
+	@echo "install in $(CURRENT_DIR) done"
+
+install.man::
+	@echo "install.man in $(CURRENT_DIR) done"
+
+install.linkkit::
+	@echo "install.linkkit in $(CURRENT_DIR) done"
+
+Makefiles::
+
+includes::
+
+depend::
+
+# ----------------------------------------------------------------------
+# dependencies generated by makedepend
+
+# DO NOT DELETE
+
+cxpm.o: ../lib/XpmI.h ../lib/xpm.h /usr/X11R6.4/include/X11/Xlib.h
+cxpm.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+cxpm.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+cxpm.o: ../lib/data.c ../lib/parse.c ../lib/XpmI.h ../lib/RdFToI.c
+cxpm.o: ../lib/hashtab.c ../lib/misc.c ../lib/Attrib.c ../lib/Image.c
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Makefile.bak rxvt-2.7.2/W11/xpm-3.4k/cxpm/Makefile.bak
--- rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Makefile.bak	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/cxpm/Makefile.bak	Mon May 14 08:23:10 2001
@@ -0,0 +1,590 @@
+# Makefile generated by imake - do not edit!
+# $TOG: imake.c /main/104 1998/03/24 12:45:15 kaleb $
+
+# ----------------------------------------------------------------------
+# Makefile generated from "Imake.tmpl" and <Imakefile>
+# $TOG: Imake.tmpl /main/249 1997/10/13 15:28:56 kaleb $
+#
+
+all::
+
+.SUFFIXES: .i
+
+# $TOG: Imake.cf /main/30 1998/04/28 13:55:25 barstow $
+
+# -----------------------------------------------------------------------
+# site-specific configuration parameters that need to come before
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ----------------------------------------------------------------------
+# platform-specific configuration parameters - edit cygwin.cf to change
+
+# platform:  $XConsortium: cygwin.cf sos 1996/02/08 18:59:31 gildea $
+#
+# changes since b18 cygwin32 release
+#	- avoided tons of "not in XXX directory" messages;
+#	- dlls are built stripped;
+#	- search for cpp in a default location;
+#	- fixed problem with missed netinet/tcp.h;
+#	- xterm compiles and works;
+#	- more libs are built as a dlls;
+#	- all dlls have different base addresses;
+
+# $XConsortium: cygwin.rules /main/12 1996/01/03 14:51:18 kaleb $
+
+BASE_COUNTER=/tmp/DLL_BASE_COUNTER
+
+# ----------------------------------------------------------------------
+# site-specific configuration parameters that go after
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ---------------------------------------------------------------------
+# Imake rules for building libraries, programs, scripts, and data files
+# rules:  $TOG: Imake.rules /main/227 1998/02/02 12:07:57 kaleb $
+
+          PATHSEP = /
+            SHELL = /bin/sh
+
+              TOP = ..
+      CURRENT_DIR = cxpm
+
+            IMAKE = imake
+           DEPEND = makedepend
+        MKDIRHIER = mkdir -p
+    EXPORTLISTGEN =
+        CONFIGSRC = $(TOP)/config
+         IMAKESRC = $(CONFIGSRC)/imake
+        DEPENDSRC = $(CONFIGSRC)/makedepend
+
+          INCROOT = /usr/X11R6.4/include
+        USRLIBDIR = /usr/X11R6.4/lib
+         SHLIBDIR = /usr/X11R6.4/lib
+       LINTLIBDIR = $(USRLIBDIR)/lint
+          MANPATH = /usr/X11R6.4/man
+    MANSOURCEPATH = $(MANPATH)/man
+           MANDIR = $(MANSOURCEPATH)1
+        LIBMANDIR = $(MANSOURCEPATH)3
+       FILEMANDIR = $(MANSOURCEPATH)5
+       MISCMANDIR = $(MANSOURCEPATH)$(MISCMANSUFFIX)
+
+               AR = ar clq
+  BOOTSTRAPCFLAGS =
+               CC = gcc
+               AS = as
+
+.SUFFIXES: .cc
+
+              CXX = g++
+          CXXFILT = c++filt
+           CXXLIB =
+    CXXDEBUGFLAGS = -O2 -s -mpentium
+CXXDEPENDINCLUDES =
+ CXXEXTRA_DEFINES =
+CXXEXTRA_INCLUDES =
+   CXXSTD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(CXXPROJECT_DEFINES)
+       CXXOPTIONS =
+      CXXINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(CXXEXTRA_INCLUDES)
+       CXXDEFINES = $(CXXINCLUDES) $(CXXSTD_DEFINES) $(THREADS_CXXDEFINES) $(CXXEXTRA_DEFINES) $(DEFINES)
+         CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
+
+         COMPRESS = compress
+          GZIPCMD = gzip
+              CPP = gcc -E - $(STD_CPP_DEFINES)
+    PREPROCESSCMD = gcc -E $(STD_CPP_DEFINES)
+          INSTALL = install
+     INSTALLFLAGS = -c
+               LD = ld
+              LEX = flex -l
+           LEXLIB = -lfl
+             YACC = byacc
+           CCYACC = byacc
+             LINT = lint
+      LINTLIBFLAG = -C
+         LINTOPTS = -axz
+               LN = ln -s
+             MAKE = make
+               MV = mv
+               CP = cp
+
+           RANLIB = ranlib
+  RANLIBINSTFLAGS =
+
+               RM = rm -f
+        MANSUFFIX = 1x
+     LIBMANSUFFIX = 3x
+    FILEMANSUFFIX = 5x
+    MISCMANSUFFIX = 7
+
+            TROFF = psroff
+            NROFF = nroff
+         MSMACROS = -ms
+        MANMACROS = -man
+              TBL = tbl
+              EQN = eqn
+             NEQN = neqn
+              COL = col
+
+            DVIPS = dvips
+            LATEX = latex
+
+     STD_INCLUDES =
+  STD_CPP_DEFINES = -traditional -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+      STD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+ EXTRA_LOAD_FLAGS =
+  EXTRA_LDOPTIONS =
+  EXTRA_LIBRARIES =
+             TAGS = ctags
+
+    SHAREDCODEDEF =
+         SHLIBDEF =
+
+     SHLIBLDFLAGS =
+
+    PROTO_DEFINES = -DFUNCPROTO=15 -DNARROWPROTO
+
+     INSTPGMFLAGS = -s
+
+     INSTBINFLAGS = -m 0755
+     INSTUIDFLAGS = -s -m 4711
+     INSTLIBFLAGS = -m 0644
+     INSTINCFLAGS = -m 0444
+     INSTMANFLAGS = -m 0444
+     INSTDATFLAGS = -m 0444
+    INSTKMEMFLAGS = -s -m 4711
+
+      PROJECTROOT = /usr/X11R6.4
+
+      CDEBUGFLAGS = -O2 -s -mpentium
+        CCOPTIONS =
+
+      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
+       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(THREADS_DEFINES) $(DEFINES)
+           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(THREADS_CFLAGS) $(ALLDEFINES)
+        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES) $(DEPEND_DEFINES)
+         LDPRELIB = -L$(USRLIBDIR)
+        LDPOSTLIB =
+        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)  $(EXTRA_LDOPTIONS) $(THREADS_LDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+     CXXLDOPTIONS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(EXTRA_LDOPTIONS) $(THREADS_CXXLDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+
+           LDLIBS = $(LDPOSTLIBS) $(THREADS_LIBS) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
+
+           CCLINK = $(CC)
+
+          CXXLINK = $(CXX)
+
+     LDSTRIPFLAGS = -x
+   LDCOMBINEFLAGS = -r
+      DEPENDFLAGS =
+
+        MACROFILE = cygwin.cf
+           RM_CMD = $(RM)
+
+    IMAKE_DEFINES =
+
+         IRULESRC = $(CONFIGDIR)
+        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
+
+     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/X11.tmpl 			$(IRULESRC)/site.def $(IRULESRC)/$(MACROFILE) 			 $(EXTRA_ICONFIGFILES)
+
+# $TOG: X11.rules /main/4 1997/04/30 15:23:24 kaleb $
+
+# ----------------------------------------------------------------------
+# X Window System Build Parameters and Rules
+# $TOG: X11.tmpl /main/308 1998/06/16 15:14:24 msr $
+
+# -----------------------------------------------------------------------
+# X Window System make variables; these need to be coordinated with rules
+
+             XTOP = $(TOP)
+           BINDIR = /usr/X11R6.4/bin
+     BUILDINCROOT = $(TOP)/exports
+      BUILDINCDIR = $(BUILDINCROOT)/include
+      BUILDINCTOP = ../..
+      BUILDLIBDIR = $(TOP)/exports/lib
+      BUILDLIBTOP = ../..
+      BUILDBINDIR = $(TOP)/exports/bin
+      BUILDBINTOP = ../..
+    XBUILDINCROOT = $(XTOP)/exports
+     XBUILDINCDIR = $(XBUILDINCROOT)/include/X11
+     XBUILDINCTOP = ../../..
+     XBUILDBINDIR = $(XBUILDINCROOT)/bin
+           INCDIR = $(INCROOT)
+           ADMDIR = /usr/adm
+           LIBDIR = $(USRLIBDIR)/X11
+   TOP_X_INCLUDES = -I$(XPROJECTROOT)/include
+
+           VARDIR = /var/X11
+
+          FONTDIR = $(LIBDIR)/fonts
+         XINITDIR = $(LIBDIR)/xinit
+           XDMDIR = $(LIBDIR)/xdm
+           TWMDIR = $(LIBDIR)/twm
+           XSMDIR = $(LIBDIR)/xsm
+           NLSDIR = $(LIBDIR)/nls
+       XLOCALEDIR = $(LIBDIR)/locale
+        PEXAPIDIR = $(LIBDIR)/PEX
+      LBXPROXYDIR = $(LIBDIR)/lbxproxy
+  PROXYMANAGERDIR = $(LIBDIR)/proxymngr
+        XPRINTDIR = $(LIBDIR)/xserver
+      XAPPLOADDIR = $(LIBDIR)/app-defaults
+       FONTCFLAGS = -t
+
+     INSTAPPFLAGS = $(INSTDATFLAGS)
+
+              RGB = $(BINDIR)/rgb
+            FONTC = $(BINDIR)/bdftopcf
+        MKFONTDIR = $(BINDIR)/mkfontdir
+
+       DOCUTILSRC = $(XTOP)/doc/util
+       XDOCMACROS = $(DOCUTILSRC)/macros.t
+       XIDXMACROS = $(DOCUTILSRC)/indexmacros.t
+       PROGRAMSRC = $(TOP)/programs
+           LIBSRC = $(XTOP)/lib
+          FONTSRC = $(XTOP)/fonts
+       INCLUDESRC = $(BUILDINCROOT)/include
+      XINCLUDESRC = $(INCLUDESRC)/X11
+        SERVERSRC = $(XTOP)/programs/Xserver
+       CONTRIBSRC = $(XTOP)/../contrib
+   UNSUPPORTEDSRC = $(XTOP)/unsupported
+           DOCSRC = $(XTOP)/doc
+           RGBSRC = $(XTOP)/programs/rgb
+      BDFTOPCFSRC = $(PROGRAMSRC)/bdftopcf
+     MKFONTDIRSRC = $(PROGRAMSRC)/mkfontdir
+    FONTSERVERSRC = $(PROGRAMSRC)/xfs
+       FONTINCSRC = $(XTOP)/include/fonts
+        EXTINCSRC = $(XTOP)/include/extensions
+     TRANSCOMMSRC = $(LIBSRC)/xtrans
+   TRANS_INCLUDES = -I$(TRANSCOMMSRC)
+
+   CLIENTENVSETUP =
+
+# $XConsortium: WinLib.tmpl,v 1.1 94/01/08 18:32:51 rws Exp $
+
+          XLIBSRC = $(LIBSRC)/X11
+
+SOXLIBREV = 6.1
+DEPXONLYLIB =
+XONLYLIB =  -lX11
+
+LINTXONLY = $(LINTLIBDIR)/llib-lX11.ln
+
+         XLIBONLY = $(XONLYLIB)
+
+      XEXTLIBSRC = $(LIBSRC)/Xext
+
+SOXEXTREV = 6.4
+DEPEXTENSIONLIB =
+EXTENSIONLIB =  -lXext
+
+LINTEXTENSION = $(LINTLIBDIR)/llib-lXext.ln
+
+LINTEXTENSIONLIB = $(LINTEXTENSION)
+          DEPXLIB = $(DEPEXTENSIONLIB) $(DEPXONLYLIB)
+             XLIB = $(EXTENSIONLIB) $(XONLYLIB)
+         LINTXLIB = $(LINTXONLYLIB)
+
+         XAUTHSRC = $(LIBSRC)/Xau
+
+DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
+XAUTHLIB =  -lXau
+
+LINTXAUTH = $(LINTLIBDIR)/llib-lXau.ln
+
+      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
+
+DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
+XDMCPLIB =  -lXdmcp
+
+LINTXDMCP = $(LINTLIBDIR)/llib-lXdmcp.ln
+
+           XMUSRC = $(LIBSRC)/Xmu
+
+DEPXMULIB = $(USRLIBDIR)/libXmu.a
+XMULIB =  -lXmu
+
+LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
+
+       OLDXLIBSRC = $(LIBSRC)/oldX
+
+SOOLDXREV = 6.0
+DEPOLDXLIB =
+OLDXLIB =  -loldX
+
+LINTOLDX = $(LINTLIBDIR)/llib-loldX.ln
+
+         XPLIBSRC = $(LIBSRC)/Xp
+
+SOXPREV = 6.2
+DEPXPLIB =
+XPLIB =  -lXp
+
+LINTXP = $(LINTLIBDIR)/llib-lXp.ln
+
+       TOOLKITSRC = $(LIBSRC)/Xt
+
+DEPXTOOLONLYLIB = $(USRLIBDIR)/libXt.a
+XTOOLONLYLIB =  -lXt
+
+LINTXTOOLONLY = $(LINTLIBDIR)/llib-lXt.ln
+
+      DEPXTOOLLIB = $(DEPXTOOLONLYLIB) $(DEPSMLIB) $(DEPICELIB)
+         XTOOLLIB = $(XTOOLONLYLIB) $(SMLIB) $(ICELIB)
+     LINTXTOOLLIB = $(LINTXTOOLONLYLIB)
+
+       XALIBSRC = $(LIBSRC)/Xa
+
+SOXAREV = 1.0
+DEPXALIB =
+XALIB =  -lXa
+
+LINTXA = $(LINTLIBDIR)/llib-lXa.ln
+
+       AWIDGETSRC = $(LIBSRC)/Xaw
+
+DEPXAWLIB = $(USRLIBDIR)/libXaw.a
+XAWLIB =  -lXaw
+
+LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
+
+         XILIBSRC = $(LIBSRC)/Xi
+
+SOXINPUTREV = 6.0
+DEPXILIB =
+XILIB =  -lXi
+
+LINTXI = $(LINTLIBDIR)/llib-lXi.ln
+
+      XTESTLIBSRC = $(LIBSRC)/Xtst
+
+SOXTESTREV = 6.1
+DEPXTESTLIB =
+XTESTLIB =  -lXtst
+
+LINTXTEST = $(LINTLIBDIR)/llib-lXtst.ln
+
+        PEXLIBSRC = $(LIBSRC)/PEX5
+
+SOPEXREV = 6.0
+DEPPEXLIB =
+PEXLIB =  -lPEX5
+
+LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
+
+        XIELIBSRC = $(LIBSRC)/XIE
+
+SOXIEREV = 6.0
+DEPXIELIB =
+XIELIB =  -lXIE
+
+LINTXIE = $(LINTLIBDIR)/llib-lXIE.ln
+
+      PHIGSLIBSRC = $(LIBSRC)/PHIGS
+
+DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
+PHIGSLIB =  -lphigs
+
+LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
+
+DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
+XBSDLIB =  -lXbsd
+
+LINTXBSD = $(LINTLIBDIR)/llib-lXbsd.ln
+
+           ICESRC = $(LIBSRC)/ICE
+
+SOICEREV = 6.3
+DEPICELIB =
+ICELIB =  -lICE
+
+LINTICE = $(LINTLIBDIR)/llib-lICE.ln
+
+            SMSRC = $(LIBSRC)/SM
+
+SOSMREV = 6.0
+DEPSMLIB =
+SMLIB =  -lSM
+
+LINTSM = $(LINTLIBDIR)/llib-lSM.ln
+
+           XKEYSRC = $(LIBSRC)/Xkey
+
+SOXKEYREV = 6.0
+DEPXKEYLIB =
+XKEYLIB =  -lXkey
+
+LINTXKEY = $(LINTLIBDIR)/llib-lXkey.ln
+
+         FSLIBSRC = $(LIBSRC)/FS
+
+DEPFSLIB = $(USRLIBDIR)/libFS.a
+FSLIB =  -lFS
+
+LINTFS = $(LINTLIBDIR)/llib-lFS.ln
+
+         FONTLIBSRC = $(LIBSRC)/font
+
+DEPFONTLIB = $(USRLIBDIR)/libfont.a
+FONTLIB =  -lfont
+
+LINTFONT = $(LINTLIBDIR)/llib-lfont.ln
+
+    XKBFILELIBSRC = $(LIBSRC)/xkbfile
+
+DEPXKBFILELIB = $(USRLIBDIR)/libxkbfile.a
+XKBFILELIB =  -lxkbfile
+
+LINTXKBFILE = $(LINTLIBDIR)/llib-lxkbfile.ln
+
+     XKBCOMPCMD = $(BINDIR)/xkbcomp
+
+          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
+
+         DEPLIBS1 = $(DEPLIBS)
+         DEPLIBS2 = $(DEPLIBS)
+         DEPLIBS3 = $(DEPLIBS)
+         DEPLIBS4 = $(DEPLIBS)
+         DEPLIBS5 = $(DEPLIBS)
+         DEPLIBS6 = $(DEPLIBS)
+         DEPLIBS7 = $(DEPLIBS)
+         DEPLIBS8 = $(DEPLIBS)
+         DEPLIBS9 = $(DEPLIBS)
+         DEPLIBS10 = $(DEPLIBS)
+
+XMULIBONLY = -lXmu
+XMULIB = $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+
+        CONFIGDIR = $(LIBDIR)/config
+
+    USRLIBDIRPATH = $(USRLIBDIR)
+        LDPRELIBS = -L$(USRLIBDIR)
+       LDPOSTLIBS =
+     TOP_INCLUDES = -I$(INCROOT) $(TOP_X_INCLUDES)
+  PROJECT_DEFINES =
+
+CXXPROJECT_DEFINES =
+
+# ----------------------------------------------------------------------
+# start of Imakefile
+
+#
+#
+# Copyright (C) 1998 Arnaud LE HORS
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files
+# (the "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to permit
+# persons to whom the Software is furnished to do so, subject to the
+# following conditions:
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN 0 EVENT SHALL Arnaud LE HORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of Arnaud LE HORS shall not
+# be used in advertising or otherwise to promote the sale, use or other
+# dealings in this Software without prior written authorization from
+# Arnaud LE HORS.
+#
+
+#
+# XPM Imakefile - Arnaud LE HORS
+#
+
+# default locations
+
+      XPMBINDIR = $(BINDIR)
+      XPMMANDIR = $(MANDIR)
+      XPMINCDIR = $(BUILDINCTOP)
+
+       INCLUDES = -I$(BUILDINCDIR) -I$(XPMINCDIR)
+
+OS_NAME_DEFINES =
+
+          SRCS = cxpm.c
+          OBJS = cxpm.o
+
+all:: cxpm.exe
+
+all:: cxpm.exe
+cxpm.exe: $(OBJS) $(DEPLIB)
+	$(RM) $@
+	$(CCLINK) -o $@ $(LDOPTIONS) $(OBJS) $(LOCAL_LIBRARIES) $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
+
+clean::
+	$(RM) cxpm.exe
+
+install:: cxpm.exe
+	@if [ -d $(DESTDIR)$(XPMBINDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMBINDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTPGMFLAGS)  cxpm.exe $(DESTDIR)$(XPMBINDIR)/cxpm.exe
+
+install.man:: cxpm.man
+	@if [ -d $(DESTDIR)$(XPMMANDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMMANDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTMANFLAGS) cxpm.man $(DESTDIR)$(XPMMANDIR)/cxpm.$(MANSUFFIX)
+
+depend::
+	$(DEPEND) $(DEPENDFLAGS) -- $(ALLDEFINES) $(DEPEND_DEFINES) -- $(SRCS)
+
+lint:
+	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
+lint1:
+	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
+
+# ----------------------------------------------------------------------
+# common rules for all Makefiles - do not edit
+
+.c.i:
+	$(RM) $@
+	 $(CC) -E $(CFLAGS) $(_NOOP_) $*.c > $@
+
+emptyrule::
+
+clean::
+	$(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut  "#"*
+
+Makefile::
+	-@if [ -f Makefile ]; then set -x; \
+	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
+	else exit 0; fi
+	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
+
+tags::
+	$(TAGS) -w *.[ch]
+	$(TAGS) -xw *.[ch] > TAGS
+
+man_keywords::
+
+# ----------------------------------------------------------------------
+# empty rules for directories that do not have SUBDIRS - do not edit
+
+install::
+	@echo "install in $(CURRENT_DIR) done"
+
+install.man::
+	@echo "install.man in $(CURRENT_DIR) done"
+
+install.linkkit::
+	@echo "install.linkkit in $(CURRENT_DIR) done"
+
+Makefiles::
+
+includes::
+
+depend::
+
+# ----------------------------------------------------------------------
+# dependencies generated by makedepend
+
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Makefile.noX rxvt-2.7.2/W11/xpm-3.4k/cxpm/Makefile.noX
--- rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/Makefile.noX	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/cxpm/Makefile.noX	Mon May 14 08:23:10 2001
@@ -0,0 +1,64 @@
+#
+#  Copyright (C) 1998 Arnaud LE HORS
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#  Arnaud LE HORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+#  Except as contained in this notice, the name of Arnaud LE HORS shall not be
+#  used in advertising or otherwise to promote the sale, use or other dealings
+#  in this Software without prior written authorization from Arnaud LE HORS.
+#
+
+#
+# XPM Makefile - Arnaud LE HORS
+#
+
+# where the program will be installed
+DESTBINDIR=/usr/local/bin/X11
+# where the man page will be installed
+MANDIR=/usr/local/man/manl
+
+CC = cc
+RM = rm -f
+# on sysV, define this as cp.
+INSTALL = install -c
+
+CDEBUGFLAGS= -O
+
+INCLUDES= -I..
+
+OBJS= cxpm.o
+
+CFLAGS= $(CDEBUGFLAGS) $(INCLUDES) $(DEFINES)
+
+all: cxpm
+
+clean: 
+	$(RM) *.o cxpm
+
+cxpm: cxpm.o
+	$(CC) $(CFLAGS) cxpm.o -o cxpm
+
+install:
+	$(INSTALL) -m 0755 cxpm $(DESTBINDIR)
+
+install.man:
+	$(INSTALL) -m 0644 cxpm.man $(MANDIR)/cxpm.l
+
+# Other dependencies.
+cxpm.o: ../lib/XpmI.h ../lib/data.c ../lib/parse.c ../lib/RdFToI.c \
+  ../lib/hashtab.c ../lib/misc.c ../lib/Attrib.c ../lib/Image.c
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/cxpm.c rxvt-2.7.2/W11/xpm-3.4k/cxpm/cxpm.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/cxpm.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/cxpm/cxpm.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 1998 Arnaud LE HORS
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * Arnaud LE HORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Arnaud LE HORS shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Arnaud LE HORS.
+ */
+
+/*****************************************************************************\
+* cxpm.c:                                                                     *
+*                                                                             *
+*  Check XPM File program                                                     *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#define CXPMPROG
+
+#include "../lib/XpmI.h"
+
+#undef xpmGetC
+#define xpmGetC(data) sGetc(data, data->stream.file)
+#define Getc sGetc
+#define Ungetc sUngetc
+
+
+/*
+ * special getc and ungetc counting read lines and characters
+ * note that 's' could stand both for "special" and "slow" ;-)
+ */
+static int
+sGetc(data)
+    xpmData *data;
+{
+    int c = getc(data->stream.file);
+    if (c == '\n') {
+        data->lineNum++;
+        data->charNum = 0;
+    } else {
+        data->charNum++;
+    }
+    return c;
+}
+
+static void
+sUngetc(data, c)
+    xpmData *data;
+    int c;
+{
+    ungetc(c, data->stream.file);
+    if (c == '\n') {
+        data->lineNum--;
+        data->charNum = 0;
+    } else {
+        data->charNum--;
+    }
+}
+
+/* include all the code we need (yeah, I know, quite ugly...) */
+#include "../lib/data.c"
+#include "../lib/parse.c"
+#include "../lib/RdFToI.c"	/* only for OpenReadFile and xpmDataClose */
+#include "../lib/hashtab.c"
+#include "../lib/misc.c"
+#include "../lib/Attrib.c"
+#include "../lib/Image.c"
+
+void
+ErrorMessage(ErrorStatus, data)
+    int ErrorStatus;
+    xpmData *data;
+
+{
+    char *error = NULL;
+
+    switch (ErrorStatus) {
+    case XpmSuccess:
+	return;
+    case XpmOpenFailed:
+	error = "Cannot open file";
+	break;
+    case XpmFileInvalid:
+	error = "Invalid XPM file";
+	break;
+    case XpmNoMemory:
+	error = "Not enough memory";
+	break;
+    case XpmColorFailed:
+	error = "Failed to parse color";
+	break;
+    }
+
+    if (error) {
+	fprintf(stderr, "Xpm Error: %s.\n", error);
+	if (ErrorStatus == XpmFileInvalid && data)
+	  fprintf(stderr, "Error found line %d near character %d\n",
+		  data->lineNum + 1,
+		  data->charNum + 1);
+	exit(1);
+    }
+}
+
+main(argc, argv)
+    int argc;
+    char **argv;
+{
+    XpmImage image;
+    char *filename;
+    int ErrorStatus;
+    xpmData data;
+
+    if (argc > 1) {
+        if (!strcmp(argv[1], "-?") || !strncmp(argv[1], "-h", 2)) {
+	    fprintf(stderr, "Usage: %s [filename]\n", argv[0]);
+	    exit(1);
+	}
+        filename = argv[1];
+    } else {
+        filename = NULL;
+    }
+
+    xpmInitXpmImage(&image);
+
+    if ((ErrorStatus = OpenReadFile(filename, &data)) != XpmSuccess)
+	ErrorMessage(ErrorStatus, NULL);
+
+    ErrorStatus = xpmParseData(&data, &image, NULL);
+    ErrorMessage(ErrorStatus, &data);
+
+    xpmDataClose(&data);
+    XpmFreeXpmImage(&image);
+
+    exit(0);
+}
Binary files rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/cxpm.exe and rxvt-2.7.2/W11/xpm-3.4k/cxpm/cxpm.exe differ
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/cxpm.man rxvt-2.7.2/W11/xpm-3.4k/cxpm/cxpm.man
--- rxvt-2.7.2-orig/W11/xpm-3.4k/cxpm/cxpm.man	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/cxpm/cxpm.man	Mon May 14 08:23:10 2001
@@ -0,0 +1,49 @@
+.\"Copyright (C) 1998 Arnaud LE HORS
+.\"
+.\"Permission is hereby granted, free of charge, to any person obtaining a copy
+.\"of this software and associated documentation files (the "Software"), to
+.\"deal in the Software without restriction, including without limitation the
+.\"rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+.\"sell copies of the Software, and to permit persons to whom the Software is
+.\"furnished to do so, subject to the following conditions:
+.\"
+.\"The above copyright notice and this permission notice shall be included in
+.\"all copies or substantial portions of the Software.
+.\"
+.\"THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+.\"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+.\"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+.\"Arnaud LE HORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+.\"IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+.\"CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+.\"
+.\"Except as contained in this notice, the name of Arnaud LE HORS shall not be
+.\"used in advertising or otherwise to promote the sale, use or other dealings
+.\"in this Software without prior written authorization from Arnaud LE HORS.
+.\"
+.nr )S 12
+.TH CXPM 1
+.PD
+.ad b
+.SH NAME
+cxpm \- Check an XPM (X PixMap) file - XPM 1, 2, or 3.
+.SH SYNOPSIS
+\fBcxpm\fR
+[\|\fIfilename\fP\|] 
+.SH DESCRIPTION
+.PP
+The \fBcxpm\fP program can be used to check the format of any XPM (version 1, 2,
+or 3) file. On error, unlike \fBsxpm\fR, \fBcxpm\fR prints out an error message
+indicating where the parser choked. This should help finding out what's wrong
+with an XPM file but do not expect too much from it though. This is not even
+close from being some kind of lint program for XPM. First, it stops at the
+first error it encounters - so several fix and retry cycles may be necessary to
+get your file to parse successfully. Second, \fBcxpm\fP only cares about
+the format. If, for instance, your pixmap uses too many colors for your system
+you still may experience difficulties displaying it. Be warned.
+.PP
+When no \fIfilename\fP is given \fBcxpm\fR reads from the standard input.
+.SH AUTHOR
+Arnaud Le Hors    (lehors@sophia.inria.fr)
+.br
+Copyright (C) 1998 by Arnaud LE HORS.
Binary files rxvt-2.7.2-orig/W11/xpm-3.4k/doc/xpm.PS.gz and rxvt-2.7.2/W11/xpm-3.4k/doc/xpm.PS.gz differ
Binary files rxvt-2.7.2-orig/W11/xpm-3.4k/exports/include/X11/xpm.h and rxvt-2.7.2/W11/xpm-3.4k/exports/include/X11/xpm.h differ
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Attrib.c rxvt-2.7.2/W11/xpm-3.4k/lib/Attrib.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Attrib.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Attrib.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* Attrib.c:                                                                   *
+*                                                                             *
+*  XPM library                                                                *
+*  Functions related to the XpmAttributes structure                           *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+/* 3.2 backward compatibility code */
+LFUNC(CreateOldColorTable, int, (XpmColor *ct, int ncolors,
+				 XpmColor ***oldct));
+
+LFUNC(FreeOldColorTable, void, (XpmColor **colorTable, int ncolors));
+
+/*
+ * Create a colortable compatible with the old style colortable
+ */
+static int
+CreateOldColorTable(ct, ncolors, oldct)
+    XpmColor *ct;
+    int ncolors;
+    XpmColor ***oldct;
+{
+    XpmColor **colorTable, **color;
+    int a;
+
+    colorTable = (XpmColor **) XpmMalloc(ncolors * sizeof(XpmColor *));
+    if (!colorTable) {
+	*oldct = NULL;
+	return (XpmNoMemory);
+    }
+    for (a = 0, color = colorTable; a < ncolors; a++, color++, ct++)
+	*color = ct;
+    *oldct = colorTable;
+    return (XpmSuccess);
+}
+
+static void
+FreeOldColorTable(colorTable, ncolors)
+    XpmColor **colorTable;
+    int ncolors;
+{
+    int a, b;
+    XpmColor **color;
+    char **sptr;
+
+    if (colorTable) {
+	for (a = 0, color = colorTable; a < ncolors; a++, color++) {
+	    for (b = 0, sptr = (char **) *color; b <= NKEYS; b++, sptr++)
+		if (*sptr)
+		    XpmFree(*sptr);
+	}
+	XpmFree(*colorTable);
+	XpmFree(colorTable);
+    }
+}
+
+/* end 3.2 bc */
+
+/*
+ * Free the computed color table
+ */
+void
+xpmFreeColorTable(colorTable, ncolors)
+    XpmColor *colorTable;
+    int ncolors;
+{
+    int a, b;
+    XpmColor *color;
+    char **sptr;
+
+    if (colorTable) {
+	for (a = 0, color = colorTable; a < ncolors; a++, color++) {
+	    for (b = 0, sptr = (char **) color; b <= NKEYS; b++, sptr++)
+		if (*sptr)
+		    XpmFree(*sptr);
+	}
+	XpmFree(colorTable);
+    }
+}
+
+/*
+ * Free array of extensions
+ */
+void
+XpmFreeExtensions(extensions, nextensions)
+    XpmExtension *extensions;
+    int nextensions;
+{
+    unsigned int i, j, nlines;
+    XpmExtension *ext;
+    char **sptr;
+
+    if (extensions) {
+	for (i = 0, ext = extensions; i < nextensions; i++, ext++) {
+	    if (ext->name)
+		XpmFree(ext->name);
+	    nlines = ext->nlines;
+	    for (j = 0, sptr = ext->lines; j < nlines; j++, sptr++)
+		if (*sptr)
+		    XpmFree(*sptr);
+	    if (ext->lines)
+		XpmFree(ext->lines);
+	}
+	XpmFree(extensions);
+    }
+}
+
+/*
+ * Return the XpmAttributes structure size
+ */
+
+int
+XpmAttributesSize()
+{
+    return sizeof(XpmAttributes);
+}
+
+/*
+ * Init returned data to free safely later on
+ */
+void
+xpmInitAttributes(attributes)
+    XpmAttributes *attributes;
+{
+    if (attributes) {
+	attributes->pixels = NULL;
+	attributes->npixels = 0;
+	attributes->colorTable = NULL;
+	attributes->ncolors = 0;
+/* 3.2 backward compatibility code */
+	attributes->hints_cmt = NULL;
+	attributes->colors_cmt = NULL;
+	attributes->pixels_cmt = NULL;
+/* end 3.2 bc */
+	if (attributes->valuemask & XpmReturnExtensions) {
+	    attributes->extensions = NULL;
+	    attributes->nextensions = 0;
+	}
+	if (attributes->valuemask & XpmReturnAllocPixels) {
+	    attributes->alloc_pixels = NULL;
+	    attributes->nalloc_pixels = 0;
+	}
+    }
+}
+
+/*
+ * Fill in the XpmAttributes with the XpmImage and the XpmInfo
+ */
+void
+xpmSetAttributes(attributes, image, info)
+    XpmAttributes *attributes;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    if (attributes->valuemask & XpmReturnColorTable) {
+	attributes->colorTable = image->colorTable;
+	attributes->ncolors = image->ncolors;
+
+	/* avoid deletion of copied data */
+	image->ncolors = 0;
+	image->colorTable = NULL;
+    }
+/* 3.2 backward compatibility code */
+    else if (attributes->valuemask & XpmReturnInfos) {
+	int ErrorStatus;
+
+	ErrorStatus = CreateOldColorTable(image->colorTable, image->ncolors,
+					  (XpmColor ***)
+					  &attributes->colorTable);
+
+	/* if error just say we can't return requested data */
+	if (ErrorStatus != XpmSuccess) {
+	    attributes->valuemask &= ~XpmReturnInfos;
+	    if (!(attributes->valuemask & XpmReturnPixels)) {
+		XpmFree(attributes->pixels);
+		attributes->pixels = NULL;
+		attributes->npixels = 0;
+	    }
+	    attributes->ncolors = 0;
+	} else {
+	    attributes->ncolors = image->ncolors;
+	    attributes->hints_cmt = info->hints_cmt;
+	    attributes->colors_cmt = info->colors_cmt;
+	    attributes->pixels_cmt = info->pixels_cmt;
+
+	    /* avoid deletion of copied data */
+	    image->ncolors = 0;
+	    image->colorTable = NULL;
+	    info->hints_cmt = NULL;
+	    info->colors_cmt = NULL;
+	    info->pixels_cmt = NULL;
+	}
+    }
+/* end 3.2 bc */
+    if (attributes->valuemask & XpmReturnExtensions) {
+	attributes->extensions = info->extensions;
+	attributes->nextensions = info->nextensions;
+
+	/* avoid deletion of copied data */
+	info->extensions = NULL;
+	info->nextensions = 0;
+    }
+    if (info->valuemask & XpmHotspot) {
+	attributes->valuemask |= XpmHotspot;
+	attributes->x_hotspot = info->x_hotspot;
+	attributes->y_hotspot = info->y_hotspot;
+    }
+    attributes->valuemask |= XpmCharsPerPixel;
+    attributes->cpp = image->cpp;
+    attributes->valuemask |= XpmSize;
+    attributes->width = image->width;
+    attributes->height = image->height;
+}
+
+/*
+ * Free the XpmAttributes structure members
+ * but the structure itself
+ */
+void
+XpmFreeAttributes(attributes)
+    XpmAttributes *attributes;
+{
+    if (attributes->valuemask & XpmReturnPixels && attributes->npixels) {
+	XpmFree(attributes->pixels);
+	attributes->pixels = NULL;
+	attributes->npixels = 0;
+    }
+    if (attributes->valuemask & XpmReturnColorTable) {
+	xpmFreeColorTable(attributes->colorTable, attributes->ncolors);
+	attributes->colorTable = NULL;
+	attributes->ncolors = 0;
+    }
+/* 3.2 backward compatibility code */
+    else if (attributes->valuemask & XpmInfos) {
+	if (attributes->colorTable) {
+	    FreeOldColorTable((XpmColor **) attributes->colorTable,
+			      attributes->ncolors);
+	    attributes->colorTable = NULL;
+	    attributes->ncolors = 0;
+	}
+	if (attributes->hints_cmt) {
+	    XpmFree(attributes->hints_cmt);
+	    attributes->hints_cmt = NULL;
+	}
+	if (attributes->colors_cmt) {
+	    XpmFree(attributes->colors_cmt);
+	    attributes->colors_cmt = NULL;
+	}
+	if (attributes->pixels_cmt) {
+	    XpmFree(attributes->pixels_cmt);
+	    attributes->pixels_cmt = NULL;
+	}
+	if (attributes->pixels) {
+	    XpmFree(attributes->pixels);
+	    attributes->pixels = NULL;
+	    attributes->npixels = 0;
+	}
+    }
+/* end 3.2 bc */
+    if (attributes->valuemask & XpmReturnExtensions
+	&& attributes->nextensions) {
+	XpmFreeExtensions(attributes->extensions, attributes->nextensions);
+	attributes->extensions = NULL;
+	attributes->nextensions = 0;
+    }
+    if (attributes->valuemask & XpmReturnAllocPixels
+	&& attributes->nalloc_pixels) {
+	XpmFree(attributes->alloc_pixels);
+	attributes->alloc_pixels = NULL;
+	attributes->nalloc_pixels = 0;
+    }
+    attributes->valuemask = 0;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrBufFrI.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrBufFrI.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrBufFrI.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrBufFrI.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,400 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrBufFrI.c:                                                                *
+*                                                                             *
+*  XPM library                                                                *
+*  Scan an image and possibly its mask and create an XPM buffer               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+LFUNC(WriteColors, int, (char **dataptr, unsigned int *data_size,
+			 unsigned int *used_size, XpmColor *colors,
+			 unsigned int ncolors, unsigned int cpp));
+
+LFUNC(WritePixels, void, (char *dataptr, unsigned int *used_size,
+			  unsigned int width, unsigned int height,
+			  unsigned int cpp, unsigned int *pixels,
+			  XpmColor *colors));
+
+LFUNC(WriteExtensions, void, (char *dataptr, unsigned int *used_size,
+			      XpmExtension *ext, unsigned int num));
+
+LFUNC(ExtensionsSize, int, (XpmExtension *ext, unsigned int num));
+LFUNC(CommentsSize, int, (XpmInfo *info));
+
+int
+XpmCreateBufferFromImage(display, buffer_return, image, shapeimage, attributes)
+    Display *display;
+    char **buffer_return;
+    XImage *image;
+    XImage *shapeimage;
+    XpmAttributes *attributes;
+{
+    XpmImage xpmimage;
+    XpmInfo info;
+    int ErrorStatus;
+
+    /* initialize return value */
+    if (buffer_return)
+	*buffer_return = NULL;
+
+    /* create an XpmImage from the image */
+    ErrorStatus = XpmCreateXpmImageFromImage(display, image, shapeimage,
+					     &xpmimage, attributes);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /* create the buffer from the XpmImage */
+    if (attributes) {
+	xpmSetInfo(&info, attributes);
+	ErrorStatus =
+	    XpmCreateBufferFromXpmImage(buffer_return, &xpmimage, &info);
+    } else
+	ErrorStatus =
+	    XpmCreateBufferFromXpmImage(buffer_return, &xpmimage, NULL);
+
+    /* free the XpmImage */
+    XpmFreeXpmImage(&xpmimage);
+
+    return (ErrorStatus);
+}
+
+
+#undef RETURN
+#define RETURN(status) \
+{ \
+      ErrorStatus = status; \
+      goto error; \
+}
+
+int
+XpmCreateBufferFromXpmImage(buffer_return, image, info)
+    char **buffer_return;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    /* calculation variables */
+    int ErrorStatus;
+    char buf[BUFSIZ];
+    unsigned int cmts, extensions, ext_size = 0;
+    unsigned int l, cmt_size = 0;
+    char *ptr = NULL, *p;
+    unsigned int ptr_size, used_size;
+
+    *buffer_return = NULL;
+
+    cmts = info && (info->valuemask & XpmComments);
+    extensions = info && (info->valuemask & XpmExtensions)
+	&& info->nextensions;
+
+    /* compute the extensions and comments size */
+    if (extensions)
+	ext_size = ExtensionsSize(info->extensions, info->nextensions);
+    if (cmts)
+	cmt_size = CommentsSize(info);
+
+    /* write the header line */
+#ifndef VOID_SPRINTF
+    used_size =
+#endif
+    sprintf(buf, "/* XPM */\nstatic char * image_name[] = {\n");
+#ifdef VOID_SPRINTF
+    used_size = strlen(buf);
+#endif
+    ptr_size = used_size + ext_size + cmt_size + 1;
+    ptr = (char *) XpmMalloc(ptr_size);
+    if (!ptr)
+	return XpmNoMemory;
+    strcpy(ptr, buf);
+
+    /* write the values line */
+    if (cmts && info->hints_cmt) {
+#ifndef VOID_SPRINTF
+	used_size +=
+#endif
+	sprintf(ptr + used_size, "/*%s*/\n", info->hints_cmt);
+#ifdef VOID_SPRINTF
+	used_size += strlen(info->hints_cmt) + 5;
+#endif
+    }
+#ifndef VOID_SPRINTF
+    l =
+#endif
+    sprintf(buf, "\"%d %d %d %d", image->width, image->height,
+	    image->ncolors, image->cpp);
+#ifdef VOID_SPRINTF
+    l = strlen(buf);
+#endif
+
+    if (info && (info->valuemask & XpmHotspot)) {
+#ifndef VOID_SPRINTF
+	l +=
+#endif
+	sprintf(buf + l, " %d %d", info->x_hotspot, info->y_hotspot);
+#ifdef VOID_SPRINTF
+	l = strlen(buf);
+#endif
+    }
+    if (extensions) {
+#ifndef VOID_SPRINTF
+	l +=
+#endif
+	sprintf(buf + l, " XPMEXT");
+#ifdef VOID_SPRINTF
+	l = strlen(buf);
+#endif
+    }
+#ifndef VOID_SPRINTF
+    l +=
+#endif
+    sprintf(buf + l, "\",\n");
+#ifdef VOID_SPRINTF
+    l = strlen(buf);
+#endif
+    ptr_size += l;
+    p = (char *) XpmRealloc(ptr, ptr_size);
+    if (!p)
+	RETURN(XpmNoMemory);
+    ptr = p;
+    strcpy(ptr + used_size, buf);
+    used_size += l;
+
+    /* write colors */
+    if (cmts && info->colors_cmt) {
+#ifndef VOID_SPRINTF
+	used_size +=
+#endif
+	sprintf(ptr + used_size, "/*%s*/\n", info->colors_cmt);
+#ifdef VOID_SPRINTF
+	used_size += strlen(info->colors_cmt) + 5;
+#endif
+    }
+    ErrorStatus = WriteColors(&ptr, &ptr_size, &used_size,
+			      image->colorTable, image->ncolors, image->cpp);
+ 
+    if (ErrorStatus != XpmSuccess)
+	RETURN(ErrorStatus);
+
+    /*
+     * now we know the exact size we need, realloc the data
+     * 4 = 1 (for '"') + 3 (for '",\n')
+     * 1 = - 2 (because the last line does not end with ',\n') + 3 (for '};\n')
+     */
+    ptr_size += image->height * (image->width * image->cpp + 4) + 1;
+
+    p = (char *) XpmRealloc(ptr, ptr_size);
+    if (!p)
+	RETURN(XpmNoMemory);
+    ptr = p;
+
+    /* print pixels */
+    if (cmts && info->pixels_cmt) {
+#ifndef VOID_SPRINTF
+	used_size +=
+#endif
+	sprintf(ptr + used_size, "/*%s*/\n", info->pixels_cmt);
+#ifdef VOID_SPRINTF
+	used_size += strlen(info->pixels_cmt) + 5;
+#endif
+    }
+    WritePixels(ptr + used_size, &used_size, image->width, image->height,
+		image->cpp, image->data, image->colorTable);
+
+    /* print extensions */
+    if (extensions)
+	WriteExtensions(ptr + used_size, &used_size,
+			info->extensions, info->nextensions);
+
+    /* close the array */
+    strcpy(ptr + used_size, "};\n");
+
+    *buffer_return = ptr;
+
+    return (XpmSuccess);
+
+/* exit point in case of error, free only locally allocated variables */
+error:
+    if (ptr)
+	XpmFree(ptr);
+    return (ErrorStatus);
+}
+
+static int
+WriteColors(dataptr, data_size, used_size, colors, ncolors, cpp)
+    char **dataptr;
+    unsigned int *data_size;
+    unsigned int *used_size;
+    XpmColor *colors;
+    unsigned int ncolors;
+    unsigned int cpp;
+{
+    char buf[BUFSIZ];
+    unsigned int a, key, l;
+    char *s, *s2;
+    char **defaults;
+
+    *buf = '"';
+    for (a = 0; a < ncolors; a++, colors++) {
+
+	defaults = (char **) colors;
+	s = buf + 1;
+	strncpy(s, *defaults++, cpp);
+	s += cpp;
+
+	for (key = 1; key <= NKEYS; key++, defaults++) {
+	    if (s2 = *defaults) {
+#ifndef VOID_SPRINTF
+		s +=
+#endif
+		sprintf(s, "\t%s %s", xpmColorKeys[key - 1], s2);
+#ifdef VOID_SPRINTF
+		s += strlen(s);
+#endif
+	    }
+	}
+	strcpy(s, "\",\n");
+	l = s + 3 - buf;
+	s = (char *) XpmRealloc(*dataptr, *data_size + l);
+	if (!s)
+	    return (XpmNoMemory);
+	*data_size += l;
+	strcpy(s + *used_size, buf);
+	*used_size += l;
+	*dataptr = s;
+    }
+    return (XpmSuccess);
+}
+
+static void
+WritePixels(dataptr, used_size, width, height, cpp, pixels, colors)
+    char *dataptr;
+    unsigned int *used_size;
+    unsigned int width;
+    unsigned int height;
+    unsigned int cpp;
+    unsigned int *pixels;
+    XpmColor *colors;
+{
+    char *s = dataptr;
+    unsigned int x, y, h;
+
+    h = height - 1;
+    for (y = 0; y < h; y++) {
+	*s++ = '"';
+	for (x = 0; x < width; x++, pixels++) {
+	    strncpy(s, colors[*pixels].string, cpp);
+	    s += cpp;
+	}
+	strcpy(s, "\",\n");
+	s += 3;
+    }
+    /* duplicate some code to avoid a test in the loop */
+    *s++ = '"';
+    for (x = 0; x < width; x++, pixels++) {
+	strncpy(s, colors[*pixels].string, cpp);
+	s += cpp;
+    }
+    *s++ = '"';
+    *used_size += s - dataptr;
+}
+
+static int
+ExtensionsSize(ext, num)
+    XpmExtension *ext;
+    unsigned int num;
+{
+    unsigned int x, y, a, size;
+    char **line;
+
+    size = 0;
+    for (x = 0; x < num; x++, ext++) {
+	/* 11 = 10 (for ',\n"XPMEXT ') + 1 (for '"') */
+	size += strlen(ext->name) + 11;
+	a = ext->nlines;
+	for (y = 0, line = ext->lines; y < a; y++, line++)
+	    /* 4 = 3 (for ',\n"') + 1 (for '"') */
+	    size += strlen(*line) + 4;
+    }
+    /* 13 is for ',\n"XPMENDEXT"' */
+    return size + 13;
+}
+
+static void
+WriteExtensions(dataptr, used_size, ext, num)
+    char *dataptr;
+    unsigned int *used_size;
+    XpmExtension *ext;
+    unsigned int num;
+{
+    unsigned int x, y, a;
+    char **line;
+    char *s = dataptr;
+
+    for (x = 0; x < num; x++, ext++) {
+#ifndef VOID_SPRINTF
+	s +=
+#endif
+	sprintf(s, ",\n\"XPMEXT %s\"", ext->name);
+#ifdef VOID_SPRINTF
+	s += strlen(ext->name) + 11;
+#endif
+	a = ext->nlines;
+	for (y = 0, line = ext->lines; y < a; y++, line++) {
+#ifndef VOID_SPRINTF
+	    s +=
+#endif
+	    sprintf(s, ",\n\"%s\"", *line);
+#ifdef VOID_SPRINTF
+	    s += strlen(*line) + 4;
+#endif
+	}
+    }
+    strcpy(s, ",\n\"XPMENDEXT\"");
+    *used_size += s - dataptr + 13;
+}
+
+static int
+CommentsSize(info)
+    XpmInfo *info;
+{
+    int size = 0;
+
+    /* 5 = 2 (for "/_*") + 3 (for "*_/\n") */
+    if (info->hints_cmt)
+	size += 5 + strlen(info->hints_cmt);
+
+    if (info->colors_cmt)
+	size += 5 + strlen(info->colors_cmt);
+
+    if (info->pixels_cmt)
+	size += 5 + strlen(info->pixels_cmt);
+
+    return size;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrBufFrP.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrBufFrP.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrBufFrP.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrBufFrP.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrBufFrP.c:                                                                *
+*                                                                             *
+*  XPM library                                                                *
+*  Scan a pixmap and possibly its mask and create an XPM buffer               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmCreateBufferFromPixmap(display, buffer_return, pixmap, shapemask,
+			  attributes)
+    Display *display;
+    char **buffer_return;
+    Pixmap pixmap;
+    Pixmap shapemask;
+    XpmAttributes *attributes;
+{
+    XImage *ximage = NULL;
+    XImage *shapeimage = NULL;
+    unsigned int width = 0;
+    unsigned int height = 0;
+    int ErrorStatus;
+
+    /* get geometry */
+    if (attributes && attributes->valuemask & XpmSize) {
+	width = attributes->width;
+	height = attributes->height;
+    }
+    /* get the ximages */
+    if (pixmap)
+	xpmCreateImageFromPixmap(display, pixmap, &ximage, &width, &height);
+    if (shapemask)
+	xpmCreateImageFromPixmap(display, shapemask, &shapeimage,
+				 &width, &height);
+
+    /* create the buffer */
+    ErrorStatus = XpmCreateBufferFromImage(display, buffer_return, ximage,
+					   shapeimage, attributes);
+
+    /* destroy the ximages */
+    if (ximage)
+	XDestroyImage(ximage);
+    if (shapeimage)
+	XDestroyImage(shapeimage);
+
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrDatFrI.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrDatFrI.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrDatFrI.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrDatFrI.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrDataFI.c:                                                                *
+*                                                                             *
+*  XPM library                                                                *
+*  Scan an image and possibly its mask and create an XPM array                *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+LFUNC(CreateColors, int, (char **dataptr, unsigned int *data_size,
+			  XpmColor *colors, unsigned int ncolors,
+			  unsigned int cpp));
+
+LFUNC(CreatePixels, void, (char **dataptr, unsigned int width,
+			   unsigned int height, unsigned int cpp,
+			   unsigned int *pixels, XpmColor *colors));
+
+LFUNC(CountExtensions, void, (XpmExtension *ext, unsigned int num,
+			      unsigned int *ext_size,
+			      unsigned int *ext_nlines));
+
+LFUNC(CreateExtensions, void, (char **dataptr, unsigned int offset,
+			       XpmExtension *ext, unsigned int num,
+			       unsigned int ext_nlines));
+
+int
+XpmCreateDataFromImage(display, data_return, image, shapeimage, attributes)
+    Display *display;
+    char ***data_return;
+    XImage *image;
+    XImage *shapeimage;
+    XpmAttributes *attributes;
+{
+    XpmImage xpmimage;
+    XpmInfo info;
+    int ErrorStatus;
+
+    /* initialize return value */
+    if (data_return)
+	*data_return = NULL;
+
+    /* create an XpmImage from the image */
+    ErrorStatus = XpmCreateXpmImageFromImage(display, image, shapeimage,
+					     &xpmimage, attributes);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /* create the data from the XpmImage */
+    if (attributes) {
+	xpmSetInfo(&info, attributes);
+	ErrorStatus = XpmCreateDataFromXpmImage(data_return, &xpmimage, &info);
+    } else
+	ErrorStatus = XpmCreateDataFromXpmImage(data_return, &xpmimage, NULL);
+
+    /* free the XpmImage */
+    XpmFreeXpmImage(&xpmimage);
+
+    return (ErrorStatus);
+}
+
+#undef RETURN
+#define RETURN(status) \
+{ \
+      ErrorStatus = status; \
+      goto exit; \
+}
+
+int
+XpmCreateDataFromXpmImage(data_return, image, info)
+    char ***data_return;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    /* calculation variables */
+    int ErrorStatus;
+    char buf[BUFSIZ];
+    char **header = NULL, **data, **sptr, **sptr2, *s;
+    unsigned int header_size, header_nlines;
+    unsigned int data_size, data_nlines;
+    unsigned int extensions = 0, ext_size = 0, ext_nlines = 0;
+    unsigned int offset, l, n;
+
+    *data_return = NULL;
+
+    extensions = info && (info->valuemask & XpmExtensions)
+	&& info->nextensions;
+
+    /* compute the number of extensions lines and size */
+    if (extensions)
+	CountExtensions(info->extensions, info->nextensions,
+			&ext_size, &ext_nlines);
+
+    /*
+     * alloc a temporary array of char pointer for the header section which
+     * is the hints line + the color table lines
+     */
+    header_nlines = 1 + image->ncolors;
+    header_size = sizeof(char *) * header_nlines;
+    header = (char **) XpmCalloc(header_size, sizeof(char *));
+    if (!header)
+	return (XpmNoMemory);
+
+    /* print the hints line */
+    s = buf;
+#ifndef VOID_SPRINTF
+    s +=
+#endif
+    sprintf(s, "%d %d %d %d", image->width, image->height,
+	    image->ncolors, image->cpp);
+#ifdef VOID_SPRINTF
+    s += strlen(s);
+#endif
+
+    if (info && (info->valuemask & XpmHotspot)) {
+#ifndef VOID_SPRINTF
+	s +=
+#endif
+	sprintf(s, " %d %d", info->x_hotspot, info->y_hotspot);
+#ifdef VOID_SPRINTF
+	s += strlen(s);
+#endif
+    }
+    if (extensions) {
+	strcpy(s, " XPMEXT");
+	s += 7;
+    }
+    l = s - buf + 1;
+    *header = (char *) XpmMalloc(l);
+    if (!*header)
+	RETURN(XpmNoMemory);
+    header_size += l;
+    strcpy(*header, buf);
+
+    /* print colors */
+    ErrorStatus = CreateColors(header + 1, &header_size,
+			       image->colorTable, image->ncolors, image->cpp);
+
+    if (ErrorStatus != XpmSuccess)
+	RETURN(ErrorStatus);
+
+    /* now we know the size needed, alloc the data and copy the header lines */
+    offset = image->width * image->cpp + 1;
+    data_size = header_size + (image->height + ext_nlines) * sizeof(char *)
+	+ image->height * offset + ext_size;
+
+    data = (char **) XpmMalloc(data_size);
+    if (!data)
+	RETURN(XpmNoMemory);
+
+    data_nlines = header_nlines + image->height + ext_nlines;
+    *data = (char *) (data + data_nlines);
+    n = image->ncolors;
+    for (l = 0, sptr = data, sptr2 = header; l <= n; l++, sptr++, sptr2++) {
+	strcpy(*sptr, *sptr2);
+	*(sptr + 1) = *sptr + strlen(*sptr2) + 1;
+    }
+
+    /* print pixels */
+    data[header_nlines] = (char *) data + header_size
+	+ (image->height + ext_nlines) * sizeof(char *);
+
+    CreatePixels(data + header_nlines, image->width, image->height,
+		 image->cpp, image->data, image->colorTable);
+
+    /* print extensions */
+    if (extensions)
+	CreateExtensions(data + header_nlines + image->height - 1, offset,
+			 info->extensions, info->nextensions,
+			 ext_nlines);
+
+    *data_return = data;
+    ErrorStatus = XpmSuccess;
+
+/* exit point, free only locally allocated variables */
+exit:
+    if (header) {
+	for (l = 0; l < header_nlines; l++)
+	    if (header[l])
+		XpmFree(header[l]);
+		XpmFree(header);
+    }
+    return(ErrorStatus);
+}
+
+static int
+CreateColors(dataptr, data_size, colors, ncolors, cpp)
+    char **dataptr;
+    unsigned int *data_size;
+    XpmColor *colors;
+    unsigned int ncolors;
+    unsigned int cpp;
+{
+    char buf[BUFSIZ];
+    unsigned int a, key, l;
+    char *s, *s2;
+    char **defaults;
+
+    for (a = 0; a < ncolors; a++, colors++, dataptr++) {
+
+	defaults = (char **) colors;
+	strncpy(buf, *defaults++, cpp);
+	s = buf + cpp;
+
+	for (key = 1; key <= NKEYS; key++, defaults++) {
+	    if (s2 = *defaults) {
+#ifndef VOID_SPRINTF
+		s +=
+#endif
+		sprintf(s, "\t%s %s", xpmColorKeys[key - 1], s2);
+#ifdef VOID_SPRINTF
+		s += strlen(s);
+#endif
+	    }
+	}
+	l = s - buf + 1;
+	s = (char *) XpmMalloc(l);
+	if (!s)
+	    return (XpmNoMemory);
+	*data_size += l;
+	*dataptr = strcpy(s, buf);
+    }
+    return (XpmSuccess);
+}
+
+static void
+CreatePixels(dataptr, width, height, cpp, pixels, colors)
+    char **dataptr;
+    unsigned int width;
+    unsigned int height;
+    unsigned int cpp;
+    unsigned int *pixels;
+    XpmColor *colors;
+{
+    char *s;
+    unsigned int x, y, h, offset;
+
+    h = height - 1;
+    offset = width * cpp + 1;
+    for (y = 0; y < h; y++, dataptr++) {
+	s = *dataptr;
+	for (x = 0; x < width; x++, pixels++) {
+	    strncpy(s, colors[*pixels].string, cpp);
+	    s += cpp;
+	}
+	*s = '\0';
+	*(dataptr + 1) = *dataptr + offset;
+    }
+    /* duplicate some code to avoid a test in the loop */
+    s = *dataptr;
+    for (x = 0; x < width; x++, pixels++) {
+	strncpy(s, colors[*pixels].string, cpp);
+	s += cpp;
+    }
+    *s = '\0';
+}
+
+static void
+CountExtensions(ext, num, ext_size, ext_nlines)
+    XpmExtension *ext;
+    unsigned int num;
+    unsigned int *ext_size;
+    unsigned int *ext_nlines;
+{
+    unsigned int x, y, a, size, nlines;
+    char **line;
+
+    size = 0;
+    nlines = 0;
+    for (x = 0; x < num; x++, ext++) {
+	/* 1 for the name */
+	nlines += ext->nlines + 1;
+	/* 8 = 7 (for "XPMEXT ") + 1 (for 0) */
+	size += strlen(ext->name) + 8;
+	a = ext->nlines;
+	for (y = 0, line = ext->lines; y < a; y++, line++)
+	    size += strlen(*line) + 1;
+    }
+    /* 10 and 1 are for the ending "XPMENDEXT" */
+    *ext_size = size + 10;
+    *ext_nlines = nlines + 1;
+}
+
+static void
+CreateExtensions(dataptr, offset, ext, num, ext_nlines)
+    char **dataptr;
+    unsigned int offset;
+    XpmExtension *ext;
+    unsigned int num;
+    unsigned int ext_nlines;
+{
+    unsigned int x, y, a, b;
+    char **line;
+
+    *(dataptr + 1) = *dataptr + offset;
+    dataptr++;
+    a = 0;
+    for (x = 0; x < num; x++, ext++) {
+	sprintf(*dataptr, "XPMEXT %s", ext->name);
+	a++;
+	if (a < ext_nlines)
+	    *(dataptr + 1) = *dataptr + strlen(ext->name) + 8;
+	dataptr++;
+	b = ext->nlines;
+	for (y = 0, line = ext->lines; y < b; y++, line++) {
+	    strcpy(*dataptr, *line);
+	    a++;
+	    if (a < ext_nlines)
+		*(dataptr + 1) = *dataptr + strlen(*line) + 1;
+	    dataptr++;
+	}
+    }
+    strcpy(*dataptr, "XPMENDEXT");
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrDatFrP.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrDatFrP.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrDatFrP.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrDatFrP.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrDataFP.c:                                                                *
+*                                                                             *
+*  XPM library                                                                *
+*  Scan a pixmap and possibly its mask and create an XPM array                *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmCreateDataFromPixmap(display, data_return, pixmap, shapemask, attributes)
+    Display *display;
+    char ***data_return;
+    Pixmap pixmap;
+    Pixmap shapemask;
+    XpmAttributes *attributes;
+{
+    XImage *ximage = NULL;
+    XImage *shapeimage = NULL;
+    unsigned int width = 0;
+    unsigned int height = 0;
+    int ErrorStatus;
+
+    /* get geometry */
+    if (attributes && attributes->valuemask & XpmSize) {
+	width = attributes->width;
+	height = attributes->height;
+    }
+    /* get the ximages */
+    if (pixmap)
+	xpmCreateImageFromPixmap(display, pixmap, &ximage, &width, &height);
+    if (shapemask)
+	xpmCreateImageFromPixmap(display, shapemask, &shapeimage,
+				 &width, &height);
+
+    /* create the data */
+    ErrorStatus = XpmCreateDataFromImage(display, data_return, ximage,
+					 shapeimage, attributes);
+
+    /* destroy the ximages */
+    if (ximage)
+	XDestroyImage(ximage);
+    if (shapeimage)
+	XDestroyImage(shapeimage);
+
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrIFrBuf.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrIFrBuf.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrIFrBuf.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrIFrBuf.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrIFrBuf.c:                                                                *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an Xpm buffer (file in memory) and create the image and possibly its *
+*  mask                                                                       *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+LFUNC(OpenBuffer, void, (char *buffer, xpmData *mdata));
+
+int
+XpmCreateImageFromBuffer(display, buffer, image_return,
+			 shapeimage_return, attributes)
+    Display *display;
+    char *buffer;
+    XImage **image_return;
+    XImage **shapeimage_return;
+    XpmAttributes *attributes;
+{
+    XpmImage image;
+    XpmInfo info;
+    int ErrorStatus;
+    xpmData mdata;
+
+    xpmInitXpmImage(&image);
+    xpmInitXpmInfo(&info);
+
+    /* open buffer to read */
+    OpenBuffer(buffer, &mdata);
+
+    /* create the XImage from the XpmData */
+    if (attributes) {
+	xpmInitAttributes(attributes);
+	xpmSetInfoMask(&info, attributes);
+	ErrorStatus = xpmParseDataAndCreate(display, &mdata,
+					    image_return, shapeimage_return,
+					    &image, &info, attributes);
+    } else
+	ErrorStatus = xpmParseDataAndCreate(display, &mdata,
+					    image_return, shapeimage_return,
+					    &image, NULL, attributes);
+    if (attributes) {
+	if (ErrorStatus >= 0)		/* no fatal error */
+	    xpmSetAttributes(attributes, &image, &info);
+	XpmFreeXpmInfo(&info);
+    }
+
+    /* free the XpmImage */
+    XpmFreeXpmImage(&image);
+
+    return (ErrorStatus);
+}
+
+int
+XpmCreateXpmImageFromBuffer(buffer, image, info)
+    char *buffer;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    xpmData mdata;
+    int ErrorStatus;
+
+    /* init returned values */
+    xpmInitXpmImage(image);
+    xpmInitXpmInfo(info);
+
+    /* open buffer to read */
+    OpenBuffer(buffer, &mdata);
+
+    /* create the XpmImage from the XpmData */
+    ErrorStatus = xpmParseData(&mdata, image, info);
+
+    return (ErrorStatus);
+}
+
+/*
+ * open the given buffer to be read or written as an xpmData which is returned
+ */
+static void
+OpenBuffer(buffer, mdata)
+    char *buffer;
+    xpmData *mdata;
+{
+    mdata->type = XPMBUFFER;
+    mdata->cptr = buffer;
+    mdata->CommentLength = 0;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrIFrDat.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrIFrDat.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrIFrDat.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrIFrDat.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrIFrData.c:                                                               *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an Xpm array and create the image and possibly its mask              *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+LFUNC(OpenArray, void, (char **data, xpmData *mdata));
+
+int
+XpmCreateImageFromData(display, data, image_return,
+		       shapeimage_return, attributes)
+    Display *display;
+    char **data;
+    XImage **image_return;
+    XImage **shapeimage_return;
+    XpmAttributes *attributes;
+{
+    XpmImage image;
+    XpmInfo info;
+    int ErrorStatus;
+    xpmData mdata;
+
+    xpmInitXpmImage(&image);
+    xpmInitXpmInfo(&info);
+
+    /* open data */
+    OpenArray(data, &mdata);
+
+    /* create an XpmImage from the file */
+    if (attributes) {
+	xpmInitAttributes(attributes);
+	xpmSetInfoMask(&info, attributes);
+	ErrorStatus = xpmParseDataAndCreate(display, &mdata,
+					    image_return, shapeimage_return,
+					    &image, &info, attributes);
+    } else
+	ErrorStatus = xpmParseDataAndCreate(display, &mdata,
+					    image_return, shapeimage_return,
+					    &image, NULL, attributes);
+    if (attributes) {
+	if (ErrorStatus >= 0)		/* no fatal error */
+	    xpmSetAttributes(attributes, &image, &info);
+	XpmFreeXpmInfo(&info);
+    }
+
+    /* free the XpmImage */
+    XpmFreeXpmImage(&image);
+
+    return (ErrorStatus);
+}
+
+int
+XpmCreateXpmImageFromData(data, image, info)
+    char **data;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    xpmData mdata;
+    int ErrorStatus;
+
+    /* init returned values */
+    xpmInitXpmImage(image);
+    xpmInitXpmInfo(info);
+
+    /* open data */
+    OpenArray(data, &mdata);
+
+    /* create the XpmImage from the XpmData */
+    ErrorStatus = xpmParseData(&mdata, image, info);
+
+    return (ErrorStatus);
+}
+
+/*
+ * open the given array to be read or written as an xpmData which is returned
+ */
+static void
+OpenArray(data, mdata)
+    char **data;
+    xpmData *mdata;
+{
+    mdata->type = XPMARRAY;
+    mdata->stream.data = data;
+    mdata->cptr = *data;
+    mdata->line = 0;
+    mdata->CommentLength = 0;
+    mdata->Bcmt = mdata->Ecmt = NULL;
+    mdata->Bos = mdata->Eos = '\0';
+    mdata->format = 0;			/* this can only be Xpm 2 or 3 */
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrIFrP.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrIFrP.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrIFrP.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrIFrP.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrIFrP.c:                                                                  *
+*                                                                             *
+*  XPM library                                                                *
+*  Create the XImage related to the given Pixmap.                             *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+void
+xpmCreateImageFromPixmap(display, pixmap, ximage_return, width, height)
+    Display *display;
+    Pixmap pixmap;
+    XImage **ximage_return;
+    unsigned int *width;
+    unsigned int *height;
+{
+    unsigned int dum;
+    int dummy;
+    Window win;
+
+    if (*width == 0 && *height == 0)
+	XGetGeometry(display, pixmap, &win, &dummy, &dummy,
+		     width, height, &dum, &dum);
+
+    *ximage_return = XGetImage(display, pixmap, 0, 0, *width, *height,
+			       AllPlanes, ZPixmap);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrPFrBuf.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrPFrBuf.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrPFrBuf.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrPFrBuf.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrPFrBuf.c:                                                                *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an Xpm buffer and create the pixmap and possibly its mask            *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmCreatePixmapFromBuffer(display, d, buffer, pixmap_return,
+			  shapemask_return, attributes)
+    Display *display;
+    Drawable d;
+    char *buffer;
+    Pixmap *pixmap_return;
+    Pixmap *shapemask_return;
+    XpmAttributes *attributes;
+{
+    XImage *ximage, *shapeimage;
+    int ErrorStatus;
+
+    /* initialize return values */
+    if (pixmap_return)
+	*pixmap_return = 0;
+    if (shapemask_return)
+	*shapemask_return = 0;
+
+    /* create the images */
+    ErrorStatus = XpmCreateImageFromBuffer(display, buffer,
+					   (pixmap_return ? &ximage : NULL),
+					   (shapemask_return ?
+					    &shapeimage : NULL),
+					   attributes);
+
+    if (ErrorStatus < 0)		/* fatal error */
+	return (ErrorStatus);
+
+    /* create the pixmaps and destroy images */
+    if (pixmap_return && ximage) {
+	xpmCreatePixmapFromImage(display, d, ximage, pixmap_return);
+	XDestroyImage(ximage);
+    }
+    if (shapemask_return && shapeimage) {
+	xpmCreatePixmapFromImage(display, d, shapeimage, shapemask_return);
+	XDestroyImage(shapeimage);
+    }
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrPFrDat.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrPFrDat.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrPFrDat.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrPFrDat.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrPFrData.c:                                                               *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an Xpm array and create the pixmap and possibly its mask             *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmCreatePixmapFromData(display, d, data, pixmap_return,
+			shapemask_return, attributes)
+    Display *display;
+    Drawable d;
+    char **data;
+    Pixmap *pixmap_return;
+    Pixmap *shapemask_return;
+    XpmAttributes *attributes;
+{
+    XImage *ximage, *shapeimage;
+    int ErrorStatus;
+
+    /* initialize return values */
+    if (pixmap_return)
+	*pixmap_return = 0;
+    if (shapemask_return)
+	*shapemask_return = 0;
+
+    /* create the images */
+    ErrorStatus = XpmCreateImageFromData(display, data,
+					 (pixmap_return ? &ximage : NULL),
+					 (shapemask_return ?
+					  &shapeimage : NULL),
+					 attributes);
+
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    if (ErrorStatus < 0)		/* fatal error */
+	return (ErrorStatus);
+
+    /* create the pixmaps and destroy images */
+    if (pixmap_return && ximage) {
+	xpmCreatePixmapFromImage(display, d, ximage, pixmap_return);
+	XDestroyImage(ximage);
+    }
+    if (shapemask_return && shapeimage) {
+	xpmCreatePixmapFromImage(display, d, shapeimage, shapemask_return);
+	XDestroyImage(shapeimage);
+    }
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrPFrI.c rxvt-2.7.2/W11/xpm-3.4k/lib/CrPFrI.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/CrPFrI.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/CrPFrI.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  CrPFrI.c:                                                                  *
+*                                                                             *
+*  XPM library                                                                *
+*  Create the Pixmap related to the given XImage.                             *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+void
+xpmCreatePixmapFromImage(display, d, ximage, pixmap_return)
+    Display *display;
+    Drawable d;
+    XImage *ximage;
+    Pixmap *pixmap_return;
+{
+    GC gc;
+    XGCValues values;
+
+    *pixmap_return = XCreatePixmap(display, d, ximage->width,
+				   ximage->height, ximage->depth);
+    /* set fg and bg in case we have an XYBitmap */
+    values.foreground = 1;
+    values.background = 0;
+    gc = XCreateGC(display, *pixmap_return,
+		   GCForeground | GCBackground, &values);
+
+    XPutImage(display, *pixmap_return, gc, ximage, 0, 0, 0, 0,
+	      ximage->width, ximage->height);
+
+    XFreeGC(display, gc);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Image.c rxvt-2.7.2/W11/xpm-3.4k/lib/Image.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Image.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Image.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  Image.c:                                                                   *
+*                                                                             *
+*  XPM library                                                                *
+*  Functions to init and free the XpmImage structure.                         *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+/*
+ * Init returned data to free safely later on
+ */
+void
+xpmInitXpmImage(image)
+    XpmImage *image;
+{
+    image->ncolors = 0;
+    image->colorTable = NULL;
+    image->data = NULL;
+}
+
+/*
+ * Free the XpmImage data which have been allocated
+ */
+void
+XpmFreeXpmImage(image)
+    XpmImage *image;
+{
+    if (image->colorTable)
+	xpmFreeColorTable(image->colorTable, image->ncolors);
+    if (image->data)
+	XpmFree(image->data);
+    image->data = NULL;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Imakefile rxvt-2.7.2/W11/xpm-3.4k/lib/Imakefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Imakefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Imakefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,186 @@
+XCOMM
+XCOMM Copyright (C) 1989-95 GROUPE BULL
+XCOMM
+XCOMM Permission is hereby granted, free of charge, to any person obtaining a
+XCOMM copy of this software and associated documentation files
+XCOMM (the "Software"), to deal in the Software without restriction, including
+XCOMM without limitation the rights to use, copy, modify, merge, publish,
+XCOMM distribute, sublicense, and/or sell copies of the Software, and to permit
+XCOMM persons to whom the Software is furnished to do so, subject to the
+XCOMM following conditions:
+XCOMM The above copyright notice and this permission notice shall be included
+XCOMM in all copies or substantial portions of the Software.
+XCOMM
+XCOMM THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+XCOMM OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+XCOMM MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+XCOMM IN NO EVENT SHALL GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+XCOMM LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+XCOMM FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+XCOMM DEALINGS IN THE SOFTWARE.
+XCOMM
+XCOMM Except as contained in this notice, the name of GROUPE BULL shall not be
+XCOMM used in advertising or otherwise to promote the sale, use or other
+XCOMM dealings in this Software without prior written authorization from
+XCOMM GROUPE BULL.
+XCOMM
+
+XCOMM
+XCOMM XPM Imakefile - Arnaud LE HORS
+XCOMM
+
+XCOMM default locations
+#ifndef XpmLibDir
+#define XpmLibDir $(USRLIBDIR)
+#endif
+#ifndef XpmIncDir
+#define XpmIncDir $(INCDIR)
+#endif
+
+XCOMM If not already set in top dir,
+XCOMM you can uncomment the following line to avoid building the shared lib
+XCOMM #define SharedLibXpm NO
+XCOMM SGI requires a specification file for shared library that we don't have
+#ifndef SharedLibXpm
+# define SharedLibXpm (HasSharedLibraries && \
+	!(defined(SGIArchitecture) && !SystemV4))
+#endif
+
+#ifndef NormalLibXpm
+#define NormalLibXpm (!SharedLibXpm || ForceNormalLib)
+#endif
+
+#if defined(RsArchitecture) || defined(Win32Architecture)
+REQUIREDLIBS = $(XLIB)
+#endif
+
+XCOMM on Dec Alpha we need to define the following to build the shared library
+#ifdef AlphaArchitecture
+REQUIREDLIBS = $(LDPRELIB) $(XLIB)
+SO_REQLIBS = -lX11 -lc
+#endif
+
+XCOMM If DEFINES has not been defined in top dir, this can be done here.
+XCOMM You may need to modify the following DEFINES variable as follows:
+XCOMM if your system doesn't provide strcasecmp add -DNEED_STRCASECMP
+XCOMM if your system doesn't provide strdup add -DNEED_STRDUP
+XCOMM if your system doesn't provide pipe add -DNO_ZPIPE
+XCOMM if on your system sprintf doesn't return the number of bytes transmitted
+XCOMM add -DVOID_SPRINTF
+
+#if defined(UltrixArchitecture) || \
+    (defined(MipsArchitecture) && !defined(SGIArchitecture))
+STRDUPDEF = -DNEED_STRDUP
+#else
+# if defined(Win32Architecture) || defined(USLArchitecture) || \
+     (defined(HasStrcasecmp) && !HasStrcasecmp)
+STRCASECMPDEF = -DNEED_STRCASECMP
+# else
+#  if defined(SunArchitecture) && !defined(SVR4Architecture)
+SPRINTFDEF = -DVOID_SPRINTF
+#  endif
+# endif
+#endif
+#if defined(Win32Architecture)
+ZPIPEDEF = -DNO_ZPIPE
+#endif
+
+DEFINES = $(STRDUPDEF) $(STRCASECMPDEF) $(SPRINTFDEF) $(ZPIPEDEF)
+
+XCOMM
+XCOMM Normally the following part should not need to be edited
+XCOMM
+
+XPMLIBDIR = XpmLibDir
+XPMINCDIR = XpmIncDir
+
+XCOMM get the version numbers from the xpm include file
+#define XPM_NUMBERS
+#include "xpm.h"
+SOXPMLIBREV = XpmVersion./**/XpmRevision
+
+HEADERS = xpm.h
+  SRCS = data.c create.c misc.c rgb.c scan.c parse.c hashtab.c \
+	 CrBufFrI.c CrDatFrP.c CrPFrBuf.c RdFToI.c WrFFrI.c \
+	 CrBufFrP.c CrIFrBuf.c CrPFrDat.c RdFToP.c WrFFrP.c \
+	 CrDatFrI.c CrIFrDat.c RdFToDat.c WrFFrDat.c \
+	 Attrib.c CrIFrP.c CrPFrI.c Image.c Info.c RdFToBuf.c WrFFrBuf.c
+
+  OBJS = data.o create.o misc.o rgb.o scan.o parse.o hashtab.o \
+	 CrBufFrI.o CrDatFrP.o CrPFrBuf.o RdFToI.o WrFFrI.o \
+	 CrBufFrP.o CrIFrBuf.o CrPFrDat.o RdFToP.o WrFFrP.o \
+	 CrDatFrI.o CrIFrDat.o RdFToDat.o WrFFrDat.o \
+	 Attrib.o CrIFrP.o CrPFrI.o Image.o Info.o RdFToBuf.o WrFFrBuf.o
+
+       INCLUDES = -I.
+       LINTLIBS = $(LINTXTOLL) $(LINTXLIB) 
+
+#ifdef OsNameDefines
+OS_NAME_DEFINES = OsNameDefines
+#endif
+
+#define DoSharedLib SharedLibXpm
+#define DoNormalLib NormalLibXpm
+
+#if (ProjectX < 5)
+    STD_DEFINES = LibraryDefines
+    CDEBUGFLAGS = LibraryCDebugFlags
+#else
+#define LibName Xpm
+#define SoRev SOXPMLIBREV
+#define IncSubdir X11
+/* we have to cheat on Library.tmpl to get what we want... */
+#define INCDIR XPMINCDIR
+#define USRLIBDIR XPMLIBDIR
+#define SHLIBDIR XPMLIBDIR
+#include <Library.tmpl>
+#undef INCDIR
+#undef USRLIBDIR
+#undef SHLIBDIR
+#endif
+
+#if (ProjectX < 6)
+
+   INSTALLFLAGS = $(INSTINCFLAGS)
+
+#if (ProjectX < 5)
+
+#if DoSharedLib
+SharedLibraryObjectRule()
+NormalSharedLibraryTarget(Xpm,$(SOXPMLIBREV),$(OBJS))
+InstallSharedLibrary(Xpm,$(SOXPMLIBREV),$(XPMLIBDIR))
+#else
+NormalLibraryObjectRule()
+#endif
+NormalLibraryTarget(Xpm,$(OBJS))
+InstallLibrary(Xpm,$(XPMLIBDIR))
+
+#else /* (ProjectX < 5) */
+
+LibraryObjectRule()
+
+#if DoSharedLib
+# if DoNormalLib
+SharedLibraryTarget(Xpm,$(SOXPMLIBREV),$(OBJS),shared,..)
+# else
+SharedLibraryTarget(Xpm,$(SOXPMLIBREV),$(OBJS),.,.)
+#endif
+InstallSharedLibrary(Xpm,$(SOXPMLIBREV),$(XPMLIBDIR))
+#endif
+#if DoNormalLib
+NormalLibraryTarget(Xpm,$(OBJS))
+InstallLibrary(Xpm,$(XPMLIBDIR))
+#endif
+
+#endif /* (ProjectX < 5) */
+
+InstallMultiple($(HEADERS),$(XPMINCDIR))
+BuildIncludes($(HEADERS),.,.)
+
+LintLibraryTarget(Xpm,$(SRCS))
+InstallLintLibrary(Xpm,$(LINTLIBDIR))
+NormalLintTarget($(SRCS))
+
+#endif /* (ProjectX < 6) */
+
+DependTarget()
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Info.c rxvt-2.7.2/W11/xpm-3.4k/lib/Info.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Info.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Info.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  Info.c:                                                                    *
+*                                                                             *
+*  XPM library                                                                *
+*  Functions related to the XpmInfo structure.                                *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+/*
+ * Init returned data to free safely later on
+ */
+void
+xpmInitXpmInfo(info)
+    XpmInfo *info;
+{
+    if (info) {
+	info->hints_cmt = NULL;
+	info->colors_cmt = NULL;
+	info->pixels_cmt = NULL;
+	info->extensions = NULL;
+	info->nextensions = 0;
+    }
+}
+
+/*
+ * Free the XpmInfo data which have been allocated
+ */
+void
+XpmFreeXpmInfo(info)
+    XpmInfo *info;
+{
+    if (info) {
+	if (info->valuemask & XpmComments) {
+	    if (info->hints_cmt) {
+		XpmFree(info->hints_cmt);
+		info->hints_cmt = NULL;
+	    }
+	    if (info->colors_cmt) {
+		XpmFree(info->colors_cmt);
+		info->colors_cmt = NULL;
+	    }
+	    if (info->pixels_cmt) {
+		XpmFree(info->pixels_cmt);
+		info->pixels_cmt = NULL;
+	    }
+	}
+	if (info->valuemask & XpmReturnExtensions && info->nextensions) {
+	    XpmFreeExtensions(info->extensions, info->nextensions);
+	    info->extensions = NULL;
+	    info->nextensions = 0;
+	}
+	info->valuemask = 0;
+    }
+}
+
+/*
+ * Set the XpmInfo valuemask to retrieve required info
+ */
+void
+xpmSetInfoMask(info, attributes)
+    XpmInfo *info;
+    XpmAttributes *attributes;
+{
+    info->valuemask = 0;
+    if (attributes->valuemask & XpmReturnInfos)
+	info->valuemask |= XpmReturnComments;
+    if (attributes->valuemask & XpmReturnExtensions)
+	info->valuemask |= XpmReturnExtensions;
+}
+
+/*
+ * Fill in the XpmInfo with the XpmAttributes
+ */
+void
+xpmSetInfo(info, attributes)
+    XpmInfo *info;
+    XpmAttributes *attributes;
+{
+    info->valuemask = 0;
+    if (attributes->valuemask & XpmInfos) {
+	info->valuemask |= XpmComments | XpmColorTable;
+	info->hints_cmt = attributes->hints_cmt;
+	info->colors_cmt = attributes->colors_cmt;
+	info->pixels_cmt = attributes->pixels_cmt;
+    }
+    if (attributes->valuemask & XpmExtensions) {
+	info->valuemask |= XpmExtensions;
+	info->extensions = attributes->extensions;
+	info->nextensions = attributes->nextensions;
+    }
+    if (attributes->valuemask & XpmHotspot) {
+	info->valuemask |= XpmHotspot;
+	info->x_hotspot = attributes->x_hotspot;
+	info->y_hotspot = attributes->y_hotspot;
+    }
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Makefile rxvt-2.7.2/W11/xpm-3.4k/lib/Makefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Makefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Makefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,812 @@
+# Makefile generated by imake - do not edit!
+# $TOG: imake.c /main/104 1998/03/24 12:45:15 kaleb $
+
+# ----------------------------------------------------------------------
+# Makefile generated from "Imake.tmpl" and <Imakefile>
+# $TOG: Imake.tmpl /main/249 1997/10/13 15:28:56 kaleb $
+#
+
+all::
+
+.SUFFIXES: .i
+
+# $TOG: Imake.cf /main/30 1998/04/28 13:55:25 barstow $
+
+# -----------------------------------------------------------------------
+# site-specific configuration parameters that need to come before
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ----------------------------------------------------------------------
+# platform-specific configuration parameters - edit cygwin.cf to change
+
+# platform:  $XConsortium: cygwin.cf sos 1996/02/08 18:59:31 gildea $
+#
+# changes since b18 cygwin32 release
+#	- avoided tons of "not in XXX directory" messages;
+#	- dlls are built stripped;
+#	- search for cpp in a default location;
+#	- fixed problem with missed netinet/tcp.h;
+#	- xterm compiles and works;
+#	- more libs are built as a dlls;
+#	- all dlls have different base addresses;
+
+# $XConsortium: cygwin.rules /main/12 1996/01/03 14:51:18 kaleb $
+
+BASE_COUNTER=/tmp/DLL_BASE_COUNTER
+
+# ----------------------------------------------------------------------
+# site-specific configuration parameters that go after
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ---------------------------------------------------------------------
+# Imake rules for building libraries, programs, scripts, and data files
+# rules:  $TOG: Imake.rules /main/227 1998/02/02 12:07:57 kaleb $
+
+          PATHSEP = /
+            SHELL = /bin/sh
+
+              TOP = ..
+      CURRENT_DIR = lib
+
+            IMAKE = imake
+           DEPEND = makedepend
+        MKDIRHIER = mkdir -p
+    EXPORTLISTGEN =
+        CONFIGSRC = $(TOP)/config
+         IMAKESRC = $(CONFIGSRC)/imake
+        DEPENDSRC = $(CONFIGSRC)/makedepend
+
+          INCROOT = /pkgs/rxvt/xlib
+        USRLIBDIR = /pkgs/rxvt/xlib
+         SHLIBDIR = /pkgs/rxvt/xlib
+       LINTLIBDIR = $(USRLIBDIR)/lint
+          MANPATH = /usr/X11R6.4/man
+    MANSOURCEPATH = $(MANPATH)/man
+           MANDIR = $(MANSOURCEPATH)1
+        LIBMANDIR = $(MANSOURCEPATH)3
+       FILEMANDIR = $(MANSOURCEPATH)5
+       MISCMANDIR = $(MANSOURCEPATH)$(MISCMANSUFFIX)
+
+               AR = ar clq
+  BOOTSTRAPCFLAGS =
+               CC = gcc
+               AS = as
+
+.SUFFIXES: .cc
+
+              CXX = g++
+          CXXFILT = c++filt
+           CXXLIB =
+    CXXDEBUGFLAGS = -g -mpentium
+CXXDEPENDINCLUDES =
+ CXXEXTRA_DEFINES =
+CXXEXTRA_INCLUDES =
+   CXXSTD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(CXXPROJECT_DEFINES)
+       CXXOPTIONS =
+      CXXINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(CXXEXTRA_INCLUDES)
+       CXXDEFINES = $(CXXINCLUDES) $(CXXSTD_DEFINES) $(THREADS_CXXDEFINES) $(CXXEXTRA_DEFINES) $(DEFINES)
+         CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
+
+         COMPRESS = compress
+          GZIPCMD = gzip
+              CPP = gcc -E - $(STD_CPP_DEFINES)
+    PREPROCESSCMD = gcc -E $(STD_CPP_DEFINES)
+          INSTALL = install
+     INSTALLFLAGS = -c
+               LD = ld
+              LEX = flex -l
+           LEXLIB = -lfl
+             YACC = byacc
+           CCYACC = byacc
+             LINT = lint
+      LINTLIBFLAG = -C
+         LINTOPTS = -axz
+               LN = ln -s
+             MAKE = make
+               MV = mv
+               CP = cp
+
+           RANLIB = ranlib
+  RANLIBINSTFLAGS =
+
+               RM = rm -f
+        MANSUFFIX = 1x
+     LIBMANSUFFIX = 3x
+    FILEMANSUFFIX = 5x
+    MISCMANSUFFIX = 7
+
+            TROFF = psroff
+            NROFF = nroff
+         MSMACROS = -ms
+        MANMACROS = -man
+              TBL = tbl
+              EQN = eqn
+             NEQN = neqn
+              COL = col
+
+            DVIPS = dvips
+            LATEX = latex
+
+     STD_INCLUDES =
+  STD_CPP_DEFINES = -traditional -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+      STD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+ EXTRA_LOAD_FLAGS =
+  EXTRA_LDOPTIONS =
+  EXTRA_LIBRARIES =
+             TAGS = ctags
+
+    SHAREDCODEDEF =
+         SHLIBDEF =
+
+     SHLIBLDFLAGS =
+
+    PROTO_DEFINES = -DFUNCPROTO=15 -DNARROWPROTO
+
+     INSTPGMFLAGS = -s
+
+     INSTBINFLAGS = -m 0755
+     INSTUIDFLAGS = -s -m 4711
+     INSTLIBFLAGS = -m 0644
+     INSTINCFLAGS = -m 0444
+     INSTMANFLAGS = -m 0444
+     INSTDATFLAGS = -m 0444
+    INSTKMEMFLAGS = -s -m 4711
+
+      PROJECTROOT = /usr/X11R6.4
+
+      CDEBUGFLAGS = -g -mpentium
+        CCOPTIONS =
+
+      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
+       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(THREADS_DEFINES) $(DEFINES)
+           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(THREADS_CFLAGS) $(ALLDEFINES)
+        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES) $(DEPEND_DEFINES)
+         LDPRELIB = -L/pkgs/rxvt/xlib -lX11 -L$(USRLIBDIR)
+        LDPOSTLIB =
+        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)  $(EXTRA_LDOPTIONS) $(THREADS_LDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+     CXXLDOPTIONS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(EXTRA_LDOPTIONS) $(THREADS_CXXLDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+
+           LDLIBS = $(LDPOSTLIBS) $(THREADS_LIBS) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
+
+           CCLINK = $(CC)
+
+          CXXLINK = $(CXX)
+
+     LDSTRIPFLAGS = -x
+   LDCOMBINEFLAGS = -r
+      DEPENDFLAGS =
+
+        MACROFILE = cygwin.cf
+           RM_CMD = $(RM)
+
+    IMAKE_DEFINES =
+
+         IRULESRC = $(CONFIGDIR)
+        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
+
+     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/X11.tmpl 			$(IRULESRC)/site.def $(IRULESRC)/$(MACROFILE) 			 $(EXTRA_ICONFIGFILES)
+
+# $TOG: X11.rules /main/4 1997/04/30 15:23:24 kaleb $
+
+# ----------------------------------------------------------------------
+# X Window System Build Parameters and Rules
+# $TOG: X11.tmpl /main/308 1998/06/16 15:14:24 msr $
+
+# -----------------------------------------------------------------------
+# X Window System make variables; these need to be coordinated with rules
+
+             XTOP = $(TOP)
+           BINDIR = /usr/X11R6.4/bin
+     BUILDINCROOT = $(TOP)/exports
+      BUILDINCDIR = $(BUILDINCROOT)/include
+      BUILDINCTOP = ../..
+      BUILDLIBDIR = $(TOP)/exports/lib
+      BUILDLIBTOP = ../..
+      BUILDBINDIR = $(TOP)/exports/bin
+      BUILDBINTOP = ../..
+    XBUILDINCROOT = $(XTOP)/exports
+     XBUILDINCDIR = $(XBUILDINCROOT)/include/X11
+     XBUILDINCTOP = ../../..
+     XBUILDBINDIR = $(XBUILDINCROOT)/bin
+           INCDIR = $(INCROOT)
+           ADMDIR = /usr/adm
+           LIBDIR = $(USRLIBDIR)/X11
+   TOP_X_INCLUDES = -I$(XPROJECTROOT)/include
+
+           VARDIR = /var/X11
+
+          FONTDIR = $(LIBDIR)/fonts
+         XINITDIR = $(LIBDIR)/xinit
+           XDMDIR = $(LIBDIR)/xdm
+           TWMDIR = $(LIBDIR)/twm
+           XSMDIR = $(LIBDIR)/xsm
+           NLSDIR = $(LIBDIR)/nls
+       XLOCALEDIR = $(LIBDIR)/locale
+        PEXAPIDIR = $(LIBDIR)/PEX
+      LBXPROXYDIR = $(LIBDIR)/lbxproxy
+  PROXYMANAGERDIR = $(LIBDIR)/proxymngr
+        XPRINTDIR = $(LIBDIR)/xserver
+      XAPPLOADDIR = $(LIBDIR)/app-defaults
+       FONTCFLAGS = -t
+
+     INSTAPPFLAGS = $(INSTDATFLAGS)
+
+              RGB = $(BINDIR)/rgb
+            FONTC = $(BINDIR)/bdftopcf
+        MKFONTDIR = $(BINDIR)/mkfontdir
+
+       DOCUTILSRC = $(XTOP)/doc/util
+       XDOCMACROS = $(DOCUTILSRC)/macros.t
+       XIDXMACROS = $(DOCUTILSRC)/indexmacros.t
+       PROGRAMSRC = $(TOP)/programs
+           LIBSRC = $(XTOP)/lib
+          FONTSRC = $(XTOP)/fonts
+       INCLUDESRC = $(BUILDINCROOT)/include
+      XINCLUDESRC = $(INCLUDESRC)/X11
+        SERVERSRC = $(XTOP)/programs/Xserver
+       CONTRIBSRC = $(XTOP)/../contrib
+   UNSUPPORTEDSRC = $(XTOP)/unsupported
+           DOCSRC = $(XTOP)/doc
+           RGBSRC = $(XTOP)/programs/rgb
+      BDFTOPCFSRC = $(PROGRAMSRC)/bdftopcf
+     MKFONTDIRSRC = $(PROGRAMSRC)/mkfontdir
+    FONTSERVERSRC = $(PROGRAMSRC)/xfs
+       FONTINCSRC = $(XTOP)/include/fonts
+        EXTINCSRC = $(XTOP)/include/extensions
+     TRANSCOMMSRC = $(LIBSRC)/xtrans
+   TRANS_INCLUDES = -I$(TRANSCOMMSRC)
+
+   CLIENTENVSETUP =
+
+# $XConsortium: WinLib.tmpl,v 1.1 94/01/08 18:32:51 rws Exp $
+
+          XLIBSRC = $(LIBSRC)/X11
+
+SOXLIBREV = 6.1
+DEPXONLYLIB =
+XONLYLIB =  -lX11
+
+LINTXONLY = $(LINTLIBDIR)/llib-lX11.ln
+
+         XLIBONLY = $(XONLYLIB)
+
+      XEXTLIBSRC = $(LIBSRC)/Xext
+
+SOXEXTREV = 6.4
+DEPEXTENSIONLIB =
+EXTENSIONLIB =  -lXext
+
+LINTEXTENSION = $(LINTLIBDIR)/llib-lXext.ln
+
+LINTEXTENSIONLIB = $(LINTEXTENSION)
+          DEPXLIB = $(DEPEXTENSIONLIB) $(DEPXONLYLIB)
+             XLIB = $(EXTENSIONLIB) $(XONLYLIB)
+         LINTXLIB = $(LINTXONLYLIB)
+
+         XAUTHSRC = $(LIBSRC)/Xau
+
+DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
+XAUTHLIB =  -lXau
+
+LINTXAUTH = $(LINTLIBDIR)/llib-lXau.ln
+
+      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
+
+DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
+XDMCPLIB =  -lXdmcp
+
+LINTXDMCP = $(LINTLIBDIR)/llib-lXdmcp.ln
+
+           XMUSRC = $(LIBSRC)/Xmu
+
+DEPXMULIB = $(USRLIBDIR)/libXmu.a
+XMULIB =  -lXmu
+
+LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
+
+       OLDXLIBSRC = $(LIBSRC)/oldX
+
+SOOLDXREV = 6.0
+DEPOLDXLIB =
+OLDXLIB =  -loldX
+
+LINTOLDX = $(LINTLIBDIR)/llib-loldX.ln
+
+         XPLIBSRC = $(LIBSRC)/Xp
+
+SOXPREV = 6.2
+DEPXPLIB =
+XPLIB =  -lXp
+
+LINTXP = $(LINTLIBDIR)/llib-lXp.ln
+
+       TOOLKITSRC = $(LIBSRC)/Xt
+
+DEPXTOOLONLYLIB = $(USRLIBDIR)/libXt.a
+XTOOLONLYLIB =  -lXt
+
+LINTXTOOLONLY = $(LINTLIBDIR)/llib-lXt.ln
+
+      DEPXTOOLLIB = $(DEPXTOOLONLYLIB) $(DEPSMLIB) $(DEPICELIB)
+         XTOOLLIB = $(XTOOLONLYLIB) $(SMLIB) $(ICELIB)
+     LINTXTOOLLIB = $(LINTXTOOLONLYLIB)
+
+       XALIBSRC = $(LIBSRC)/Xa
+
+SOXAREV = 1.0
+DEPXALIB =
+XALIB =  -lXa
+
+LINTXA = $(LINTLIBDIR)/llib-lXa.ln
+
+       AWIDGETSRC = $(LIBSRC)/Xaw
+
+DEPXAWLIB = $(USRLIBDIR)/libXaw.a
+XAWLIB =  -lXaw
+
+LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
+
+         XILIBSRC = $(LIBSRC)/Xi
+
+SOXINPUTREV = 6.0
+DEPXILIB =
+XILIB =  -lXi
+
+LINTXI = $(LINTLIBDIR)/llib-lXi.ln
+
+      XTESTLIBSRC = $(LIBSRC)/Xtst
+
+SOXTESTREV = 6.1
+DEPXTESTLIB =
+XTESTLIB =  -lXtst
+
+LINTXTEST = $(LINTLIBDIR)/llib-lXtst.ln
+
+        PEXLIBSRC = $(LIBSRC)/PEX5
+
+SOPEXREV = 6.0
+DEPPEXLIB =
+PEXLIB =  -lPEX5
+
+LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
+
+        XIELIBSRC = $(LIBSRC)/XIE
+
+SOXIEREV = 6.0
+DEPXIELIB =
+XIELIB =  -lXIE
+
+LINTXIE = $(LINTLIBDIR)/llib-lXIE.ln
+
+      PHIGSLIBSRC = $(LIBSRC)/PHIGS
+
+DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
+PHIGSLIB =  -lphigs
+
+LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
+
+DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
+XBSDLIB =  -lXbsd
+
+LINTXBSD = $(LINTLIBDIR)/llib-lXbsd.ln
+
+           ICESRC = $(LIBSRC)/ICE
+
+SOICEREV = 6.3
+DEPICELIB =
+ICELIB =  -lICE
+
+LINTICE = $(LINTLIBDIR)/llib-lICE.ln
+
+            SMSRC = $(LIBSRC)/SM
+
+SOSMREV = 6.0
+DEPSMLIB =
+SMLIB =  -lSM
+
+LINTSM = $(LINTLIBDIR)/llib-lSM.ln
+
+           XKEYSRC = $(LIBSRC)/Xkey
+
+SOXKEYREV = 6.0
+DEPXKEYLIB =
+XKEYLIB =  -lXkey
+
+LINTXKEY = $(LINTLIBDIR)/llib-lXkey.ln
+
+         FSLIBSRC = $(LIBSRC)/FS
+
+DEPFSLIB = $(USRLIBDIR)/libFS.a
+FSLIB =  -lFS
+
+LINTFS = $(LINTLIBDIR)/llib-lFS.ln
+
+         FONTLIBSRC = $(LIBSRC)/font
+
+DEPFONTLIB = $(USRLIBDIR)/libfont.a
+FONTLIB =  -lfont
+
+LINTFONT = $(LINTLIBDIR)/llib-lfont.ln
+
+    XKBFILELIBSRC = $(LIBSRC)/xkbfile
+
+DEPXKBFILELIB = $(USRLIBDIR)/libxkbfile.a
+XKBFILELIB =  -lxkbfile
+
+LINTXKBFILE = $(LINTLIBDIR)/llib-lxkbfile.ln
+
+     XKBCOMPCMD = $(BINDIR)/xkbcomp
+
+          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
+
+         DEPLIBS1 = $(DEPLIBS)
+         DEPLIBS2 = $(DEPLIBS)
+         DEPLIBS3 = $(DEPLIBS)
+         DEPLIBS4 = $(DEPLIBS)
+         DEPLIBS5 = $(DEPLIBS)
+         DEPLIBS6 = $(DEPLIBS)
+         DEPLIBS7 = $(DEPLIBS)
+         DEPLIBS8 = $(DEPLIBS)
+         DEPLIBS9 = $(DEPLIBS)
+         DEPLIBS10 = $(DEPLIBS)
+
+XMULIBONLY = -lXmu
+XMULIB = $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+
+        CONFIGDIR = $(LIBDIR)/config
+
+    USRLIBDIRPATH = $(USRLIBDIR)
+        LDPRELIBS = -L$(USRLIBDIR)
+       LDPOSTLIBS =
+     TOP_INCLUDES = -I$(INCROOT) $(TOP_X_INCLUDES)
+  PROJECT_DEFINES =
+
+CXXPROJECT_DEFINES =
+
+# ----------------------------------------------------------------------
+# start of Imakefile
+
+#
+# Copyright (C) 1989-95 GROUPE BULL
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files
+# (the "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to permit
+# persons to whom the Software is furnished to do so, subject to the
+# following conditions:
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN 0 EVENT SHALL GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+# DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of GROUPE BULL shall not be
+# used in advertising or otherwise to promote the sale, use or other
+# dealings in this Software without prior written authorization from
+# GROUPE BULL.
+#
+
+#
+# XPM Imakefile - Arnaud LE HORS
+#
+
+# default locations
+
+# If not already set in top dir,
+# you can uncomment the following line to avoid building the shared lib
+# #define SharedLibXpm 0
+# SGI requires a specification file for shared library that we don't have
+
+# on Dec Alpha we need to define the following to build the shared library
+
+# If DEFINES has not been defined in top dir, this can be done here.
+# You may need to modify the following DEFINES variable as follows:
+# if your system doesn't provide strcasecmp add -DNEED_STRCASECMP
+# if your system doesn't provide strdup add -DNEED_STRDUP
+# if your system doesn't provide pipe add -DNO_ZPIPE
+# if on your system sprintf doesn't return the number of bytes transmitted
+# add -DVOID_SPRINTF
+
+DEFINES = $(STRDUPDEF) $(STRCASECMPDEF) $(SPRINTFDEF) $(ZPIPEDEF)
+
+#
+# Normally the following part should not need to be edited
+#
+
+XPMLIBDIR = $(USRLIBDIR)
+XPMINCDIR = $(INCDIR)
+
+# get the version numbers from the xpm include file
+
+SOXPMLIBREV = 4.11
+
+HEADERS = xpm.h
+  SRCS = data.c create.c misc.c rgb.c scan.c parse.c hashtab.c 	 CrBufFrI.c CrDatFrP.c CrPFrBuf.c RdFToI.c WrFFrI.c 	 CrBufFrP.c CrIFrBuf.c CrPFrDat.c RdFToP.c WrFFrP.c 	 CrDatFrI.c CrIFrDat.c RdFToDat.c WrFFrDat.c 	 Attrib.c CrIFrP.c CrPFrI.c Image.c Info.c RdFToBuf.c WrFFrBuf.c
+
+  OBJS = data.o create.o misc.o rgb.o scan.o parse.o hashtab.o 	 CrBufFrI.o CrDatFrP.o CrPFrBuf.o RdFToI.o WrFFrI.o 	 CrBufFrP.o CrIFrBuf.o CrPFrDat.o RdFToP.o WrFFrP.o 	 CrDatFrI.o CrIFrDat.o RdFToDat.o WrFFrDat.o 	 Attrib.o CrIFrP.o CrPFrI.o Image.o Info.o RdFToBuf.o WrFFrBuf.o
+
+       INCLUDES = -I.
+       LINTLIBS = $(LINTXTOLL) $(LINTXLIB)
+
+OS_NAME_DEFINES =
+
+# $TOG: Library.tmpl /main/44 1997/04/28 11:47:53 kaleb $
+
+         CC = gcc
+  CCOPTIONS =
+STD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+CDEBUGFLAGS = -g -mpentium
+
+LIB_MT_DEFINES = LibraryMTDefines
+
+LIBNAME = Xpm
+
+all::
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+
+includes::
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+
+.c.o:
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+	$(RM) $@
+	 $(CC) -c $(CFLAGS) $(_NOOP_) $(SHLIBDEF) $(SHAREDCODEDEF) $(PICFLAGS) $*.c
+
+clean::
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+	$(_NULLCMD_)
+
+all:: lib$(LIBNAME).dll
+
+$(LIBNAME).def::  $(LIBNAME)-def.cpp $(ICONFIGFILES)
+	$(RM) $@
+	 $(CPP)  -DLIBRARY_VERSION=$(SOXPMLIBREV) <$(LIBNAME)-def.cpp | sed -e '/^#  *[0-9][0-9]*  *.*$$/d' -e '/^XCOMM$$/s//#/' -e '/^XCOMM[^a-zA-Z0-9_]/s/^XCOMM/#/' >$@
+
+clean::
+	$(RM) $(LIBNAME).def
+
+junk.c:
+	echo "#include <cygwin/cygwin_dll.h>"		>junk.c
+	echo "DECLARE_CYGWIN_DLL(dll_main);"		>>junk.c
+	echo "int WINAPI dll_main(HANDLE a, DWORD reason, void *q)" >>junk.c
+	echo "{ return 1; }"				>>junk.c
+lib$(LIBNAME).dll: $(OBJS) junk.o $(LIBNAME).def
+	$(RM) lib$(LIBNAME).a
+	$(RM) lib$(LIBNAME).dll
+
+	if [ -f $(BASE_COUNTER) ]; then true; \
+	else echo 0x67000000 > $(BASE_COUNTER); fi
+	dlltool --dllname lib$(LIBNAME).dll --def $(LIBNAME).def --output-lib lib$(LIBNAME).a
+	dllwrap -s -o lib$(LIBNAME).dll $(OBJS) junk.o $(REQUIREDLIBS) -L/pkgs/rxvt/xlib -lX11 -luser32 -lgdi32 -image-base `cat $(BASE_COUNTER)`
+	IMAGE_LENGTH=`objdump -x lib$(LIBNAME).dll |awk '/SizeOfImage/ {print "0x"$$2}'`; \
+	export IMAGE_LENGTH=`expr '(' \`printf %u $$IMAGE_LENGTH\` / 65536 + 1 ')' '*' 65536` ; \
+	export IMAGE_BASE=`cat $(BASE_COUNTER)`; \
+	printf 0x%x `expr \`printf %u $$IMAGE_BASE\` + $$IMAGE_LENGTH` > $(BASE_COUNTER)
+	$(_NULLCMD_)
+clean::
+	$(RM) lib$(LIBNAME).a
+	$(RM) lib$(LIBNAME).dll
+	$(RM) junk.o
+	$(RM) junk.c
+	$(RM) $(BASE_COUNTER)
+
+install:: lib$(LIBNAME).a
+	@if [ -d $(DESTDIR)$(XPMLIBDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMLIBDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTLIBFLAGS) lib$(LIBNAME).a $(DESTDIR)$(XPMLIBDIR)/lib$(LIBNAME).a
+
+install:: lib$(LIBNAME).dll
+	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTLIBFLAGS) lib$(LIBNAME).dll $(DESTDIR)$(BINDIR)/lib$(LIBNAME).dll
+
+lintlib:: llib-l$(LIBNAME).ln
+
+llib-l$(LIBNAME).ln: $(SRCS) $(EXTRALIBRARYDEPS)
+	$(RM) $@
+	$(LINT) $(LINTLIBFLAG)$(LIBNAME) $(LINTFLAGS) $(SRCS)
+
+install.ln:: llib-l$(LIBNAME).ln
+	@if [ -d $(DESTDIR)$(LINTLIBDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(LINTLIBDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTLIBFLAGS) llib-l$(LIBNAME).ln $(DESTDIR)$(LINTLIBDIR)/llib-l$(LIBNAME).ln
+
+includes:: $(HEADERS)
+	@if [ -d $(BUILDINCDIR)/X11 ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(BUILDINCDIR)/X11); fi
+	@(set -x; cd $(BUILDINCDIR)/X11; for i in $(HEADERS); do \
+	$(RM) $$i; \
+	$(LN) $(BUILDINCTOP)/../$(CURRENT_DIR)/$$i .; \
+	done)
+
+install:: $(HEADERS)
+	@if [ -d $(DESTDIR)$(XPMINCDIR)/X11 ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMINCDIR)/X11); fi
+	@for flag in ${MAKEFLAGS} ''; do \
+	case "$$flag" in *=*) ;;--*) ;; *[i]*) set +e;; esac; done; \
+	for i in $(HEADERS); do \
+	(set -x; $(INSTALL) $(INSTALLFLAGS) $(INSTINCFLAGS) $$i $(DESTDIR)$(XPMINCDIR)/X11); \
+	done
+
+lint:
+	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
+lint1:
+	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
+
+depend::
+	$(DEPEND) $(DEPENDFLAGS) -- $(ALLDEFINES) $(DEPEND_DEFINES) -- $(SRCS)
+
+# ----------------------------------------------------------------------
+# common rules for all Makefiles - do not edit
+
+.c.i:
+	$(RM) $@
+	 $(CC) -E $(CFLAGS) $(_NOOP_) $*.c > $@
+
+emptyrule::
+
+clean::
+	$(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut  "#"*
+
+Makefile::
+	-@if [ -f Makefile ]; then set -x; \
+	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
+	else exit 0; fi
+	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
+
+tags::
+	$(TAGS) -w *.[ch]
+	$(TAGS) -xw *.[ch] > TAGS
+
+man_keywords::
+
+# ----------------------------------------------------------------------
+# empty rules for directories that do not have SUBDIRS - do not edit
+
+install::
+	@echo "install in $(CURRENT_DIR) done"
+
+install.man::
+	@echo "install.man in $(CURRENT_DIR) done"
+
+install.linkkit::
+	@echo "install.linkkit in $(CURRENT_DIR) done"
+
+Makefiles::
+
+includes::
+
+depend::
+
+# ----------------------------------------------------------------------
+# dependencies generated by makedepend
+
+# DO NOT DELETE
+
+data.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+data.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+data.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+create.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+create.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+create.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+misc.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+misc.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+misc.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+rgb.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+rgb.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+rgb.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+scan.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+scan.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+scan.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+parse.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+parse.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+parse.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+hashtab.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+hashtab.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+hashtab.o: /usr/X11R6.4/include/X11/Xosdefs.h
+hashtab.o: /usr/X11R6.4/include/X11/Xutil.h
+CrBufFrI.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrBufFrI.o: /usr/X11R6.4/include/X11/X.h
+CrBufFrI.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrBufFrI.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrBufFrI.o: /usr/X11R6.4/include/X11/Xutil.h
+CrDatFrP.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrDatFrP.o: /usr/X11R6.4/include/X11/X.h
+CrDatFrP.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrDatFrP.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrDatFrP.o: /usr/X11R6.4/include/X11/Xutil.h
+CrPFrBuf.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrPFrBuf.o: /usr/X11R6.4/include/X11/X.h
+CrPFrBuf.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrPFrBuf.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrPFrBuf.o: /usr/X11R6.4/include/X11/Xutil.h
+RdFToI.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+RdFToI.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+RdFToI.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+WrFFrI.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+WrFFrI.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+WrFFrI.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+CrBufFrP.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrBufFrP.o: /usr/X11R6.4/include/X11/X.h
+CrBufFrP.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrBufFrP.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrBufFrP.o: /usr/X11R6.4/include/X11/Xutil.h
+CrIFrBuf.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrIFrBuf.o: /usr/X11R6.4/include/X11/X.h
+CrIFrBuf.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrIFrBuf.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrIFrBuf.o: /usr/X11R6.4/include/X11/Xutil.h
+CrPFrDat.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrPFrDat.o: /usr/X11R6.4/include/X11/X.h
+CrPFrDat.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrPFrDat.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrPFrDat.o: /usr/X11R6.4/include/X11/Xutil.h
+RdFToP.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+RdFToP.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+RdFToP.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+WrFFrP.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+WrFFrP.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+WrFFrP.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+CrDatFrI.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrDatFrI.o: /usr/X11R6.4/include/X11/X.h
+CrDatFrI.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrDatFrI.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrDatFrI.o: /usr/X11R6.4/include/X11/Xutil.h
+CrIFrDat.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrIFrDat.o: /usr/X11R6.4/include/X11/X.h
+CrIFrDat.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+CrIFrDat.o: /usr/X11R6.4/include/X11/Xosdefs.h
+CrIFrDat.o: /usr/X11R6.4/include/X11/Xutil.h
+RdFToDat.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+RdFToDat.o: /usr/X11R6.4/include/X11/X.h
+RdFToDat.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+RdFToDat.o: /usr/X11R6.4/include/X11/Xosdefs.h
+RdFToDat.o: /usr/X11R6.4/include/X11/Xutil.h
+WrFFrDat.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+WrFFrDat.o: /usr/X11R6.4/include/X11/X.h
+WrFFrDat.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+WrFFrDat.o: /usr/X11R6.4/include/X11/Xosdefs.h
+WrFFrDat.o: /usr/X11R6.4/include/X11/Xutil.h
+Attrib.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+Attrib.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+Attrib.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+CrIFrP.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrIFrP.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+CrIFrP.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+CrPFrI.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+CrPFrI.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+CrPFrI.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+Image.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+Image.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+Image.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+Info.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+Info.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+Info.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+RdFToBuf.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+RdFToBuf.o: /usr/X11R6.4/include/X11/X.h
+RdFToBuf.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+RdFToBuf.o: /usr/X11R6.4/include/X11/Xosdefs.h
+RdFToBuf.o: /usr/X11R6.4/include/X11/Xutil.h
+WrFFrBuf.o: XpmI.h xpm.h /usr/X11R6.4/include/X11/Xlib.h
+WrFFrBuf.o: /usr/X11R6.4/include/X11/X.h
+WrFFrBuf.o: /usr/X11R6.4/include/X11/Xfuncproto.h
+WrFFrBuf.o: /usr/X11R6.4/include/X11/Xosdefs.h
+WrFFrBuf.o: /usr/X11R6.4/include/X11/Xutil.h
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Makefile.AmigaGCC rxvt-2.7.2/W11/xpm-3.4k/lib/Makefile.AmigaGCC
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Makefile.AmigaGCC	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Makefile.AmigaGCC	Mon May 14 08:23:10 2001
@@ -0,0 +1,92 @@
+#
+#  Copyright (C) 1996 Lorens Younes
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#  Lorens Younes BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+#  Except as contained in this notice, the name of Lorens Younes shall not be
+#  used in advertising or otherwise to promote the sale, use or other dealings
+#  in this Software without prior written authorization from Lorens Younes.
+#
+
+#
+# XPM Amiga GCC Makefile - Lorens Younes (d93-hyo@nada.kth.se)
+#
+
+CC = gcc
+AR = ar r
+RANLIB = ranlib
+RM = rm -f
+INSTALL = install -c
+MKDIRHIER = mkdir
+LN = ln -s
+CHMOD = chmod
+
+CDEBUGFLAGS = -O
+DEFINES = -DNO_ZPIPE -DAMIGA
+
+DESTBINDIR= /projects/bin
+DESTLIBDIR= /projects/lib
+DESTINCLUDEDIR= /projects/include
+
+OBJS= data.o create.o misc.o rgb.o scan.o parse.o hashtab.o \
+      WrFFrI.o RdFToI.o CrIFrDat.o CrDatFrI.o \
+      CrIFrBuf.o CrBufFrI.o \
+      RdFToDat.o WrFFrDat.o \
+      Attrib.o Image.o Info.o RdFToBuf.o WrFFrBuf.o \
+      amigax.o
+
+CFLAGS = $(CDEBUGFLAGS) $(DEFINES) 
+
+all: libXpm.a
+
+clean:
+	-$(RM) *.o libXpm.a
+
+libXpm.a: $(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+install:
+	$(INSTALL) -m 0664 libXpm.a $(DESTLIBDIR)
+	cd $(DESTLIBDIR); $(RANLIB) libXpm.a
+	-$(MKDIRHIER) $(DESTINCLUDEDIR)
+	-$(CHMOD) ugo+rx $(DESTINCLUDEDIR)
+	$(INSTALL) -m 0444 xpm.h $(DESTINCLUDEDIR)
+
+# Other dependencies.
+CrBufFrI.o:  XpmI.h xpm.h amigax.h
+CrDatFI.o:  XpmI.h xpm.h amigax.h
+CrIFrBuf.o:  XpmI.h xpm.h amigax.h
+CrIFrDat.o:  XpmI.h xpm.h amigax.h
+RdFToDat.o:  XpmI.h xpm.h amigax.h
+RdFToI.o:  XpmI.h xpm.h amigax.h
+WrFFrDat.o:  XpmI.h xpm.h amigax.h
+WrFFrI.o:  XpmI.h xpm.h amigax.h
+create.o:  XpmI.h xpm.h amigax.h
+data.o:  XpmI.h xpm.h amigax.h
+hashtab.o:  XpmI.h xpm.h amigax.h
+misc.o:  XpmI.h xpm.h amigax.h
+parse.o:  XpmI.h xpm.h amigax.h
+rgb.o:  XpmI.h xpm.h amigax.h
+scan.o:  XpmI.h xpm.h amigax.h
+Attrib.o:  XpmI.h xpm.h amigax.h
+Image.o:  XpmI.h xpm.h amigax.h
+Info.o:  XpmI.h xpm.h amigax.h
+RdFToBuf.o:  XpmI.h xpm.h amigax.h
+WrFFrBuf.o:  XpmI.h xpm.h amigax.h
+amigax.o:  XpmI.h xpm.h amigax.h
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Makefile.noX rxvt-2.7.2/W11/xpm-3.4k/lib/Makefile.noX
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Makefile.noX	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Makefile.noX	Mon May 14 08:25:12 2001
@@ -0,0 +1,112 @@
+#
+#  Copyright (C) 1989-95 GROUPE BULL
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#  GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+#  AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+#  Except as contained in this notice, the name of GROUPE BULL shall not be
+#  used in advertising or otherwise to promote the sale, use or other dealings
+#  in this Software without prior written authorization from GROUPE BULL.
+#
+
+#
+# XPM Makefile - Arnaud LE HORS
+#
+
+# if your system doesn't provide strcasecmp add -DNEED_STRCASECMP
+# if your system doesn't provide strdup add -DNEED_STRDUP
+# if your system doesn't provide pipe add -DNO_ZPIPE
+# if on your system sprintf doesn't return the number of bytes transmitted
+# add -DVOID_SPRINTF
+DEFINES =
+
+# where the library will be installed
+DESTLIBDIR=../../lib
+# where the include file (pxm.h) will be installed
+DESTINCLUDEDIR=../../X11
+
+CC = gcc
+AR = ar r
+RANLIB = ranlib
+RM = rm -f
+# on sysV, define this as cp.
+INSTALL = install -c
+MKDIRHIER = mkdir
+LN = ln -s
+INCLUDES=-I../..
+CDEBUGFLAGS= -O
+
+OBJS= data.o create.o misc.o rgb.o scan.o parse.o hashtab.o \
+      WrFFrP.o RdFToP.o CrPFrDat.o CrDatFrP.o \
+      WrFFrI.o RdFToI.o CrIFrDat.o CrDatFrI.o \
+      CrIFrBuf.o CrPFrBuf.o CrBufFrI.o CrBufFrP.o \
+      RdFToDat.o WrFFrDat.o \
+      Attrib.o CrIFrP.o CrPFrI.o Image.o Info.o RdFToBuf.o WrFFrBuf.o
+
+CFLAGS= $(CDEBUGFLAGS) $(DEFINES) $(INCLUDES)
+
+all: ../X11/xpm.h libXpm.a
+
+clean: 
+	$(RM) *.o libXpm.a
+
+libXpm.a: $(OBJS)
+	$(AR) libXpm.a $(OBJS)
+	$(RANLIB) libXpm.a
+
+install:
+	$(INSTALL) -m 0664 libXpm.a $(DESTLIBDIR)
+	cd $(DESTLIBDIR); $(RANLIB) libXpm.a
+	-mkdir $(DESTINCLUDEDIR)
+	-chmod ugo+rx $(DESTINCLUDEDIR)
+	$(INSTALL) -m 0444 xpm.h $(DESTINCLUDEDIR)
+
+../X11/xpm.h: xpm.h
+	@if [ -d ../X11 ]; then set +x; \
+	else (set -x; $(MKDIRHIER) ../X11); fi
+	$(RM) ../X11/xpm.h; \
+	$(LN) ../lib/xpm.h ../X11
+
+# Other dependencies.
+CrBufFrI.o:  XpmI.h xpm.h
+CrBufFrP.o:  XpmI.h xpm.h
+CrDatFI.o:  XpmI.h xpm.h
+CrDatFP.o:  XpmI.h xpm.h
+CrIFrBuf.o:  XpmI.h xpm.h
+CrIFrDat.o:  XpmI.h xpm.h
+CrPFrBuf.o:  XpmI.h xpm.h
+CrPFrDat.o:  XpmI.h xpm.h
+RdFToDat.o:  XpmI.h xpm.h
+RdFToI.o:  XpmI.h xpm.h
+RdFToP.o:  XpmI.h xpm.h
+WrFFrDat.o:  XpmI.h xpm.h
+WrFFrI.o:  XpmI.h xpm.h
+WrFFrP.o:  XpmI.h xpm.h
+create.o:  XpmI.h xpm.h
+data.o:  XpmI.h xpm.h
+hashtab.o:  XpmI.h xpm.h
+misc.o:  XpmI.h xpm.h
+parse.o:  XpmI.h xpm.h
+rgb.o:  XpmI.h xpm.h
+scan.o:  XpmI.h xpm.h
+Attrib.o:  XpmI.h xpm.h
+CrIFrP.o:  XpmI.h xpm.h
+CrPFrI.o:  XpmI.h xpm.h
+Image.o:  XpmI.h xpm.h
+Info.o:  XpmI.h xpm.h
+RdFToBuf.o:  XpmI.h xpm.h
+WrFFrBuf.o:  XpmI.h xpm.h
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToBuf.c rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToBuf.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToBuf.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToBuf.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* RdFToBuf.c:                                                                 *
+*                                                                             *
+*  XPM library                                                                *
+*  Copy a file to a malloc'ed buffer, provided as a convenience.              *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+#include "XpmI.h"
+#include <sys/stat.h>
+#if !defined(FOR_MSW) && !defined(WIN32)
+#include <unistd.h>
+#endif
+#ifndef VAX11C
+#include <fcntl.h>
+#endif
+#if defined(FOR_MSW) || defined(WIN32)
+#include <io.h>
+#define stat _stat
+#define fstat _fstat
+#define fdopen _fdopen
+#define O_RDONLY _O_RDONLY
+#endif
+
+int
+XpmReadFileToBuffer(filename, buffer_return)
+    char *filename;
+    char **buffer_return;
+{
+    int fd, fcheck, len;
+    char *ptr;
+    struct stat stats;
+    FILE *fp;
+
+    *buffer_return = NULL;
+
+#ifndef VAX11C
+    fd = open(filename, O_RDONLY);
+#else
+    fd = open(filename, O_RDONLY, NULL);
+#endif
+    if (fd < 0)
+	return XpmOpenFailed;
+
+    if (fstat(fd, &stats)) {
+	close(fd);
+	return XpmOpenFailed;
+    }
+    fp = fdopen(fd, "r");
+    if (!fp) {
+	close(fd);
+	return XpmOpenFailed;
+    }
+    len = (int) stats.st_size;
+    ptr = (char *) XpmMalloc(len + 1);
+    if (!ptr) {
+	fclose(fp);
+	return XpmNoMemory;
+    }
+    fcheck = fread(ptr, 1, len, fp);
+    fclose(fp);
+#ifdef VMS
+    /* VMS often stores text files in a variable-length record format,
+       where there are two bytes of size followed by the record.  fread	
+       converts this so it looks like a record followed by a newline.	
+       Unfortunately, the size reported by fstat() (and fseek/ftell)	
+       counts the two bytes for the record terminator, while fread()	
+       counts only one.  So, fread() sees fewer bytes in the file (size	
+       minus # of records) and thus when asked to read the amount	
+       returned by stat(), it fails.
+       The best solution, suggested by DEC, seems to consider the length
+       returned from fstat() as an upper bound and call fread() with
+       a record length of 1. Then don't check the return value.
+       We'll check for 0 for gross error that's all.
+    */
+    len = fcheck;
+    if (fcheck == 0) {
+#else
+    if (fcheck != len) {
+#endif
+	XpmFree(ptr);
+	return XpmOpenFailed;
+    }
+    ptr[len] = '\0';
+    *buffer_return = ptr;
+    return XpmSuccess;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToDat.c rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToDat.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToDat.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToDat.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  RdFToDat.c:                                                                *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an XPM file and create an array of strings corresponding to it.      *
+*                                                                             *
+*  Developed by Dan Greening dgreen@cs.ucla.edu / dgreen@sti.com              *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmReadFileToData(filename, data_return)
+    char *filename;
+    char ***data_return;
+{
+    XpmImage image;
+    XpmInfo info;
+    int ErrorStatus;
+
+    info.valuemask = XpmReturnComments | XpmReturnExtensions;
+
+    /*
+     * initialize return value
+     */
+    if (data_return)
+	*data_return = NULL;
+
+    ErrorStatus = XpmReadFileToXpmImage(filename, &image, &info);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    ErrorStatus =
+	XpmCreateDataFromXpmImage(data_return, &image, &info);
+
+    XpmFreeXpmImage(&image);
+    XpmFreeXpmInfo(&info);
+
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToI.c rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToI.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToI.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToI.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  RdFToI.c:                                                                  *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an XPM file and create the image and possibly its mask               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+#include <sys/stat.h>
+#if !defined(NO_ZPIPE) && defined(WIN32)
+# define popen _popen
+# define pclose _pclose
+# if defined(STAT_ZFILE)
+#  include <io.h>
+#  define stat _stat
+#  define fstat _fstat
+# endif
+#endif
+
+LFUNC(OpenReadFile, int, (char *filename, xpmData *mdata));
+LFUNC(xpmDataClose, void, (xpmData *mdata));
+
+#ifndef CXPMPROG
+int
+XpmReadFileToImage(display, filename,
+		   image_return, shapeimage_return, attributes)
+    Display *display;
+    char *filename;
+    XImage **image_return;
+    XImage **shapeimage_return;
+    XpmAttributes *attributes;
+{
+    XpmImage image;
+    XpmInfo info;
+    int ErrorStatus;
+    xpmData mdata;
+
+    xpmInitXpmImage(&image);
+    xpmInitXpmInfo(&info);
+
+    /* open file to read */
+    if ((ErrorStatus = OpenReadFile(filename, &mdata)) != XpmSuccess)
+	return (ErrorStatus);
+
+    /* create the XImage from the XpmData */
+    if (attributes) {
+	xpmInitAttributes(attributes);
+	xpmSetInfoMask(&info, attributes);
+	ErrorStatus = xpmParseDataAndCreate(display, &mdata,
+					    image_return, shapeimage_return,
+					    &image, &info, attributes);
+    } else
+	ErrorStatus = xpmParseDataAndCreate(display, &mdata,
+					    image_return, shapeimage_return,
+					    &image, NULL, attributes);
+    if (attributes) {
+	if (ErrorStatus >= 0)		/* no fatal error */
+	    xpmSetAttributes(attributes, &image, &info);
+	XpmFreeXpmInfo(&info);
+    }
+
+    xpmDataClose(&mdata);
+    /* free the XpmImage */
+    XpmFreeXpmImage(&image);
+
+    return (ErrorStatus);
+}
+
+int
+XpmReadFileToXpmImage(filename, image, info)
+    char *filename;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    xpmData mdata;
+    int ErrorStatus;
+
+    /* init returned values */
+    xpmInitXpmImage(image);
+    xpmInitXpmInfo(info);
+
+    /* open file to read */
+    if ((ErrorStatus = OpenReadFile(filename, &mdata)) != XpmSuccess)
+	return (ErrorStatus);
+
+    /* create the XpmImage from the XpmData */
+    ErrorStatus = xpmParseData(&mdata, image, info);
+
+    xpmDataClose(&mdata);
+
+    return (ErrorStatus);
+}
+#endif /* CXPMPROG */
+
+/*
+ * open the given file to be read as an xpmData which is returned.
+ */
+static int
+OpenReadFile(filename, mdata)
+    char *filename;
+    xpmData *mdata;
+{
+#ifndef NO_ZPIPE
+    char *compressfile, buf[BUFSIZ];
+# ifdef STAT_ZFILE
+    struct stat status;
+# endif
+#endif
+
+    if (!filename) {
+	mdata->stream.file = (stdin);
+	mdata->type = XPMFILE;
+    } else {
+#ifndef NO_ZPIPE
+	int len = strlen(filename);
+	if ((len > 2) && !strcmp(".Z", filename + (len - 2))) {
+	    mdata->type = XPMPIPE;
+	    sprintf(buf, "uncompress -c \"%s\"", filename);
+	    if (!(mdata->stream.file = popen(buf, "r")))
+		return (XpmOpenFailed);
+
+	} else if ((len > 3) && !strcmp(".gz", filename + (len - 3))) {
+	    mdata->type = XPMPIPE;
+	    sprintf(buf, "gunzip -qc \"%s\"", filename);
+	    if (!(mdata->stream.file = popen(buf, "r")))
+		return (XpmOpenFailed);
+
+	} else {
+# ifdef STAT_ZFILE
+	    if (!(compressfile = (char *) XpmMalloc(len + 4)))
+		return (XpmNoMemory);
+
+	    sprintf(compressfile, "%s.Z", filename);
+	    if (!stat(compressfile, &status)) {
+		sprintf(buf, "uncompress -c \"%s\"", compressfile);
+		if (!(mdata->stream.file = popen(buf, "r"))) {
+		    XpmFree(compressfile);
+		    return (XpmOpenFailed);
+		}
+		mdata->type = XPMPIPE;
+	    } else {
+		sprintf(compressfile, "%s.gz", filename);
+		if (!stat(compressfile, &status)) {
+		    sprintf(buf, "gunzip -c \"%s\"", compressfile);
+		    if (!(mdata->stream.file = popen(buf, "r"))) {
+			XpmFree(compressfile);
+			return (XpmOpenFailed);
+		    }
+		    mdata->type = XPMPIPE;
+		} else {
+# endif
+#endif
+		    if (!(mdata->stream.file = fopen(filename, "r"))) {
+#if !defined(NO_ZPIPE) && defined(STAT_ZFILE)
+			XpmFree(compressfile);
+#endif
+			return (XpmOpenFailed);
+		    }
+		    mdata->type = XPMFILE;
+#ifndef NO_ZPIPE
+# ifdef STAT_ZFILE
+		}
+	    }
+	    XpmFree(compressfile);
+# endif
+	}
+#endif
+    }
+    mdata->CommentLength = 0;
+#ifdef CXPMPROG
+    mdata->lineNum = 0;
+    mdata->charNum = 0;
+#endif
+    return (XpmSuccess);
+}
+
+/*
+ * close the file related to the xpmData if any
+ */
+static void
+xpmDataClose(mdata)
+    xpmData *mdata;
+{
+    switch (mdata->type) {
+    case XPMFILE:
+	if (mdata->stream.file != (stdin))
+	    fclose(mdata->stream.file);
+	break;
+#ifndef NO_ZPIPE
+    case XPMPIPE:
+	pclose(mdata->stream.file);
+	break;
+#endif
+    }
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToP.c rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToP.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/RdFToP.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/RdFToP.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  RdFToP.c:                                                                  *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an XPM file and create the pixmap and possibly its mask              *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmReadFileToPixmap(display, d, filename, pixmap_return,
+		    shapemask_return, attributes)
+    Display *display;
+    Drawable d;
+    char *filename;
+    Pixmap *pixmap_return;
+    Pixmap *shapemask_return;
+    XpmAttributes *attributes;
+{
+    XImage *ximage, *shapeimage;
+    int ErrorStatus;
+
+    /* initialize return values */
+    if (pixmap_return)
+	*pixmap_return = 0;
+    if (shapemask_return)
+	*shapemask_return = 0;
+
+    /* create the images */
+    ErrorStatus = XpmReadFileToImage(display, filename,
+				     (pixmap_return ? &ximage : NULL),
+				     (shapemask_return ? &shapeimage : NULL),
+				     attributes);
+
+    if (ErrorStatus < 0)		/* fatal error */
+	return (ErrorStatus);
+
+    /* create the pixmaps and destroy images */
+    if (pixmap_return && ximage) {
+	xpmCreatePixmapFromImage(display, d, ximage, pixmap_return);
+	XDestroyImage(ximage);
+    }
+    if (shapemask_return && shapeimage) {
+	xpmCreatePixmapFromImage(display, d, shapeimage, shapemask_return);
+	XDestroyImage(shapeimage);
+    }
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Smakefile rxvt-2.7.2/W11/xpm-3.4k/lib/Smakefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Smakefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Smakefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,89 @@
+#
+#  Copyright (C) 1996 Lorens Younes
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#  Lorens Younes BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+#  Except as contained in this notice, the name of Lorens Younes shall not be
+#  used in advertising or otherwise to promote the sale, use or other dealings
+#  in this Software without prior written authorization from Lorens Younes.
+#
+
+#
+# XPM Makefile for SAS/C - Lorens Younes (d93-hyo@nada.kth.se)
+#
+
+CC= sc:c/sc
+OML= sc:c/oml
+RM= c:delete
+CP= c:copy
+MKDIR= c:makedir
+
+CDEBUGFLAGS= opt optsched utillib
+DEFINES= def=NO_ZPIPE def=NEED_STRCASECMP def=AMIGA
+
+DESTBINDIR= Projects:bin
+DESTLIBDIR= Projects:lib
+DESTINCLUDEDIR= Projects:include
+
+OBJS= data.o create.o misc.o rgb.o scan.o parse.o hashtab.o \
+      WrFFrI.o RdFToI.o CrIFrDat.o CrDatFrI.o \
+      CrIFrBuf.o CrBufFrI.o \
+      RdFToDat.o WrFFrDat.o \
+      Attrib.o Image.o Info.o RdFToBuf.o WrFFrBuf.o \
+      amigax.o
+
+CFLAGS= $(CDEBUGFLAGS) $(DEFINES) ansi nochkabort errrexx noicons nostkchk\
+        verbose ignore=85+100+154+161+304
+
+all: xpm.lib
+
+clean:
+	-$(RM) \#?.o \#?.lib \#?.lnk
+
+xpm.lib: $(OBJS)
+	$(OML) $@ r $(OBJS)
+
+install:
+	-$(MKDIR) $(DESTLIBDIR)
+	$(CP) xpm.lib $(DESTLIBDIR)
+	-$(MKDIR) $(DESTINCLUDEDIR)
+	$(CP) xpm.h $(DESTINCLUDEDIR)
+	$(CP) amigax.h $(DESTINCLUDEDIR)
+
+# Other dependencies.
+CrBufFrI.o:  XpmI.h xpm.h amigax.h
+CrDatFI.o:  XpmI.h xpm.h amigax.h
+CrIFrBuf.o:  XpmI.h xpm.h amigax.h
+CrIFrDat.o:  XpmI.h xpm.h amigax.h
+RdFToDat.o:  XpmI.h xpm.h amigax.h
+RdFToI.o:  XpmI.h xpm.h amigax.h
+WrFFrDat.o:  XpmI.h xpm.h amigax.h
+WrFFrI.o:  XpmI.h xpm.h amigax.h
+create.o:  XpmI.h xpm.h amigax.h
+data.o:  XpmI.h xpm.h amigax.h
+hashtab.o:  XpmI.h xpm.h amigax.h
+misc.o:  XpmI.h xpm.h amigax.h
+parse.o:  XpmI.h xpm.h amigax.h
+rgb.o:  XpmI.h xpm.h amigax.h
+scan.o:  XpmI.h xpm.h amigax.h
+Attrib.o:  XpmI.h xpm.h amigax.h
+Image.o:  XpmI.h xpm.h amigax.h
+Info.o:  XpmI.h xpm.h amigax.h
+RdFToBuf.o:  XpmI.h xpm.h amigax.h
+WrFFrBuf.o:  XpmI.h xpm.h amigax.h
+amigax.o:  XpmI.h xpm.h amigax.h
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrBuf.c rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrBuf.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrBuf.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrBuf.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* WrFFrBuf.c:                                                                 *
+*                                                                             *
+*  XPM library                                                                *
+*  Write a memory buffer to a file, provided as a convenience.                *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmWriteFileFromBuffer(filename, buffer)
+    char *filename;
+    char *buffer;
+{
+    int fcheck, len;
+    FILE *fp = fopen(filename, "w");
+
+    if (!fp)
+	return XpmOpenFailed;
+
+    len = strlen(buffer);
+    fcheck = fwrite(buffer, len, 1, fp);
+    fclose(fp);
+    if (fcheck != 1)
+	return XpmOpenFailed;
+
+    return XpmSuccess;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrDat.c rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrDat.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrDat.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrDat.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  WrFFrData.c:                                                               *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an Xpm array and write a file that corresponds to it.                *
+*                                                                             *
+*  Developed by Dan Greening dgreen@cs.ucla.edu / dgreen@sti.com              *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmWriteFileFromData(filename, data)
+    char *filename;
+    char **data;
+{
+    XpmImage image;
+    XpmInfo info;
+    int ErrorStatus;
+
+    info.valuemask = XpmReturnComments | XpmReturnExtensions;
+
+    ErrorStatus = XpmCreateXpmImageFromData(data, &image, &info);
+
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    ErrorStatus = XpmWriteFileFromXpmImage(filename, &image, &info);
+
+    XpmFreeXpmImage(&image);
+    XpmFreeXpmInfo(&info);
+
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrI.c rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrI.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrI.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrI.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  WrFFrI.c:                                                                  *
+*                                                                             *
+*  XPM library                                                                *
+*  Write an image and possibly its mask to an XPM file                        *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to AMIGA has been added by
+ * Lorens Younes (d93-hyo@nada.kth.se) 4/96
+ */
+
+#include "XpmI.h"
+#if !defined(NO_ZPIPE) && defined(WIN32)
+# define popen _popen
+# define pclose _pclose
+#endif
+
+/* MS Windows define a function called WriteFile @#%#&!!! */
+LFUNC(xpmWriteFile, int, (FILE *file, XpmImage *image, char *name,
+			  XpmInfo *info));
+
+LFUNC(WriteColors, void, (FILE *file, XpmColor *colors, unsigned int ncolors));
+
+LFUNC(WritePixels, int, (FILE *file, unsigned int width, unsigned int height,
+			 unsigned int cpp, unsigned int *pixels,
+			 XpmColor *colors));
+
+LFUNC(WriteExtensions, void, (FILE *file, XpmExtension *ext,
+			      unsigned int num));
+
+LFUNC(OpenWriteFile, int, (char *filename, xpmData *mdata));
+LFUNC(xpmDataClose, void, (xpmData *mdata));
+
+int
+XpmWriteFileFromImage(display, filename, image, shapeimage, attributes)
+    Display *display;
+    char *filename;
+    XImage *image;
+    XImage *shapeimage;
+    XpmAttributes *attributes;
+{
+    XpmImage xpmimage;
+    XpmInfo info;
+    int ErrorStatus;
+
+    /* create an XpmImage from the image */
+    ErrorStatus = XpmCreateXpmImageFromImage(display, image, shapeimage,
+					     &xpmimage, attributes);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /* write the file from the XpmImage */
+    if (attributes) {
+	xpmSetInfo(&info, attributes);
+	ErrorStatus = XpmWriteFileFromXpmImage(filename, &xpmimage, &info);
+    } else
+	ErrorStatus = XpmWriteFileFromXpmImage(filename, &xpmimage, NULL);
+
+    /* free the XpmImage */
+    XpmFreeXpmImage(&xpmimage);
+
+    return (ErrorStatus);
+}
+
+int
+XpmWriteFileFromXpmImage(filename, image, info)
+    char *filename;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    xpmData mdata;
+    char *name, *dot, *s, new_name[BUFSIZ];
+    int ErrorStatus;
+
+    /* open file to write */
+    if ((ErrorStatus = OpenWriteFile(filename, &mdata)) != XpmSuccess)
+	return (ErrorStatus);
+
+    /* figure out a name */
+    if (filename) {
+#ifdef VMS
+	name = filename;
+#else
+	if (!(name = rindex(filename, '/'))
+#ifdef AMIGA
+	    && !(name = rindex(filename, ':'))
+#endif
+     )
+	    name = filename;
+	else
+	    name++;
+#endif
+	/* let's try to make a valid C syntax name */
+	if (dot = index(name, '.')) {
+	    strcpy(new_name, name);
+	    /* change '.' to '_' */
+	    name = s = new_name;
+	    while (dot = index(s, '.')) {
+		*dot = '_';
+		s = dot;
+	    }
+	}
+	if (dot = index(name, '-')) {
+	    if (name != new_name) {
+		strcpy(new_name, name);
+		name = new_name;
+	    }
+	    /* change '-' to '_' */
+	    s = name;
+	    while (dot = index(s, '-')) {
+		*dot = '_';
+		s = dot;
+	    }
+	}
+    } else
+	name = "image_name";
+
+    /* write the XpmData from the XpmImage */
+    if (ErrorStatus == XpmSuccess)
+	ErrorStatus = xpmWriteFile(mdata.stream.file, image, name, info);
+
+    xpmDataClose(&mdata);
+
+    return (ErrorStatus);
+}
+
+static int
+xpmWriteFile(file, image, name, info)
+    FILE *file;
+    XpmImage *image;
+    char *name;
+    XpmInfo *info;
+{
+    /* calculation variables */
+    unsigned int cmts, extensions;
+    int ErrorStatus;
+
+    cmts = info && (info->valuemask & XpmComments);
+    extensions = info && (info->valuemask & XpmExtensions)
+	&& info->nextensions;
+
+    /* print the header line */
+    fprintf(file, "/* XPM */\nstatic char * %s[] = {\n", name);
+
+    /* print the hints line */
+    if (cmts && info->hints_cmt)
+	fprintf(file, "/*%s*/\n", info->hints_cmt);
+
+    fprintf(file, "\"%d %d %d %d", image->width, image->height,
+	    image->ncolors, image->cpp);
+
+    if (info && (info->valuemask & XpmHotspot))
+	fprintf(file, " %d %d", info->x_hotspot, info->y_hotspot);
+
+    if (extensions)
+	fprintf(file, " XPMEXT");
+
+    fprintf(file, "\",\n");
+
+    /* print colors */
+    if (cmts && info->colors_cmt)
+	fprintf(file, "/*%s*/\n", info->colors_cmt);
+
+    WriteColors(file, image->colorTable, image->ncolors);
+
+    /* print pixels */
+    if (cmts && info->pixels_cmt)
+	fprintf(file, "/*%s*/\n", info->pixels_cmt);
+
+    ErrorStatus = WritePixels(file, image->width, image->height, image->cpp,
+			      image->data, image->colorTable);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /* print extensions */
+    if (extensions)
+	WriteExtensions(file, info->extensions, info->nextensions);
+
+    /* close the array */
+    fprintf(file, "};\n");
+
+    return (XpmSuccess);
+}
+
+static void
+WriteColors(file, colors, ncolors)
+    FILE *file;
+    XpmColor *colors;
+    unsigned int ncolors;
+{
+    unsigned int a, key;
+    char *s;
+    char **defaults;
+
+    for (a = 0; a < ncolors; a++, colors++) {
+
+	defaults = (char **) colors;
+	fprintf(file, "\"%s", *defaults++);
+
+	for (key = 1; key <= NKEYS; key++, defaults++) {
+	    if (s = *defaults)
+		fprintf(file, "\t%s %s", xpmColorKeys[key - 1], s);
+	}
+	fprintf(file, "\",\n");
+    }
+}
+
+
+static int
+WritePixels(file, width, height, cpp, pixels, colors)
+    FILE *file;
+    unsigned int width;
+    unsigned int height;
+    unsigned int cpp;
+    unsigned int *pixels;
+    XpmColor *colors;
+{
+    char *s, *p, *buf;
+    unsigned int x, y, h;
+
+    h = height - 1;
+    p = buf = (char *) XpmMalloc(width * cpp + 3);
+    if (!buf)
+	return (XpmNoMemory);
+    *buf = '"';
+    p++;
+    for (y = 0; y < h; y++) {
+	s = p;
+	for (x = 0; x < width; x++, pixels++) {
+	    strncpy(s, colors[*pixels].string, cpp);
+	    s += cpp;
+	}
+	*s++ = '"';
+	*s = '\0';
+	fprintf(file, "%s,\n", buf);
+    }
+    /* duplicate some code to avoid a test in the loop */
+    s = p;
+    for (x = 0; x < width; x++, pixels++) {
+	strncpy(s, colors[*pixels].string, cpp);
+	s += cpp;
+    }
+    *s++ = '"';
+    *s = '\0';
+    fprintf(file, "%s", buf);
+
+    XpmFree(buf);
+    return (XpmSuccess);
+}
+
+static void
+WriteExtensions(file, ext, num)
+    FILE *file;
+    XpmExtension *ext;
+    unsigned int num;
+{
+    unsigned int x, y, n;
+    char **line;
+
+    for (x = 0; x < num; x++, ext++) {
+	fprintf(file, ",\n\"XPMEXT %s\"", ext->name);
+	n = ext->nlines;
+	for (y = 0, line = ext->lines; y < n; y++, line++)
+	    fprintf(file, ",\n\"%s\"", *line);
+    }
+    fprintf(file, ",\n\"XPMENDEXT\"");
+}
+
+/*
+ * open the given file to be written as an xpmData which is returned
+ */
+static int
+OpenWriteFile(filename, mdata)
+    char *filename;
+    xpmData *mdata;
+{
+#ifndef NO_ZPIPE
+    char buf[BUFSIZ];
+
+#endif
+
+    if (!filename) {
+	mdata->stream.file = (stdout);
+	mdata->type = XPMFILE;
+    } else {
+#ifndef NO_ZPIPE
+	int len = strlen(filename);
+	if (len > 2 && !strcmp(".Z", filename + (len - 2))) {
+	    sprintf(buf, "compress > \"%s\"", filename);
+	    if (!(mdata->stream.file = popen(buf, "w")))
+		return (XpmOpenFailed);
+
+	    mdata->type = XPMPIPE;
+	} else if (len > 3 && !strcmp(".gz", filename + (len - 3))) {
+	    sprintf(buf, "gzip -q > \"%s\"", filename);
+	    if (!(mdata->stream.file = popen(buf, "w")))
+		return (XpmOpenFailed);
+
+	    mdata->type = XPMPIPE;
+	} else {
+#endif
+	    if (!(mdata->stream.file = fopen(filename, "w")))
+		return (XpmOpenFailed);
+
+	    mdata->type = XPMFILE;
+#ifndef NO_ZPIPE
+	}
+#endif
+    }
+    return (XpmSuccess);
+}
+
+/*
+ * close the file related to the xpmData if any
+ */
+static void
+xpmDataClose(mdata)
+    xpmData *mdata;
+{
+    switch (mdata->type) {
+    case XPMFILE:
+	if (mdata->stream.file != (stdout))
+	    fclose(mdata->stream.file);
+	break;
+#ifndef NO_ZPIPE
+    case XPMPIPE:
+	pclose(mdata->stream.file);
+	break;
+#endif
+    }
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrP.c rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrP.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/WrFFrP.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/WrFFrP.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+*  WrFFrP.c:                                                                  *
+*                                                                             *
+*  XPM library                                                                *
+*  Write a pixmap and possibly its mask to an XPM file                        *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+int
+XpmWriteFileFromPixmap(display, filename, pixmap, shapemask, attributes)
+    Display *display;
+    char *filename;
+    Pixmap pixmap;
+    Pixmap shapemask;
+    XpmAttributes *attributes;
+{
+    XImage *ximage = NULL;
+    XImage *shapeimage = NULL;
+    unsigned int width = 0;
+    unsigned int height = 0;
+    int ErrorStatus;
+
+    /* get geometry */
+    if (attributes && attributes->valuemask & XpmSize) {
+	width = attributes->width;
+	height = attributes->height;
+    }
+    /* get the ximages */
+    if (pixmap)
+	xpmCreateImageFromPixmap(display, pixmap, &ximage, &width, &height);
+    if (shapemask)
+	xpmCreateImageFromPixmap(display, shapemask, &shapeimage,
+				 &width, &height);
+
+    /* write to the file */
+    ErrorStatus = XpmWriteFileFromImage(display, filename, ximage, shapeimage,
+					attributes);
+
+    /* destroy the ximages */
+    if (ximage)
+	XDestroyImage(ximage);
+    if (shapeimage)
+	XDestroyImage(shapeimage);
+
+    return (ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/X11/xpm.h rxvt-2.7.2/W11/xpm-3.4k/lib/X11/xpm.h
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/X11/xpm.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/X11/xpm.h	Mon May 14 08:23:10 2001
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* xpm.h:                                                                      *
+*                                                                             *
+*  XPM library                                                                *
+*  Include file                                                               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+/*
+ * The code related to AMIGA has been added by
+ * Lorens Younes (d93-hyo@nada.kth.se) 4/96
+ */
+
+#ifndef XPM_h
+#define XPM_h
+
+/*
+ * first some identification numbers:
+ * the version and revision numbers are determined with the following rule:
+ * SO Major number = LIB minor version number.
+ * SO Minor number = LIB sub-minor version number.
+ * e.g: Xpm version 3.2f
+ *      we forget the 3 which is the format number, 2 gives 2, and f gives 6.
+ *      thus we have XpmVersion = 2 and XpmRevision = 6
+ *      which gives  SOXPMLIBREV = 2.6
+ *
+ * Then the XpmIncludeVersion number is built from these numbers.
+ */
+#define XpmFormat 3
+#define XpmVersion 4
+#define XpmRevision 11
+#define XpmIncludeVersion ((XpmFormat * 100 + XpmVersion) * 100 + XpmRevision)
+
+#ifndef XPM_NUMBERS
+
+#ifdef FOR_MSW
+# define SYSV			/* uses memcpy string.h etc. */
+# include <malloc.h>
+# include "simx.h"		/* defines some X stuff using MSW types */
+#define NEED_STRCASECMP		/* at least for MSVC++ */
+#else /* FOR_MSW */
+# ifdef AMIGA
+#  include "amigax.h"
+# else /* not AMIGA */
+#  include <X11/Xlib.h>
+#  include <X11/Xutil.h>
+# endif /* not AMIGA */
+#endif /* FOR_MSW */
+
+/* let's define Pixel if it is not done yet */
+#if ! defined(_XtIntrinsic_h) && ! defined(PIXEL_ALREADY_TYPEDEFED)
+typedef unsigned long Pixel;	/* Index into colormap */
+# define PIXEL_ALREADY_TYPEDEFED
+#endif
+
+/* make sure we know whether function prototypes are needed or not */
+#ifndef NeedFunctionPrototypes
+# if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus)
+#  define NeedFunctionPrototypes 1
+# else
+#  define NeedFunctionPrototypes 0
+# endif
+#endif
+
+
+/* Return ErrorStatus codes:
+ * null     if full success
+ * positive if partial success
+ * negative if failure
+ */
+
+#define XpmColorError    1
+#define XpmSuccess       0
+#define XpmOpenFailed   -1
+#define XpmFileInvalid  -2
+#define XpmNoMemory     -3
+#define XpmColorFailed  -4
+
+typedef struct {
+    char *name;			/* Symbolic color name */
+    char *value;		/* Color value */
+    Pixel pixel;		/* Color pixel */
+}      XpmColorSymbol;
+
+typedef struct {
+    char *name;			/* name of the extension */
+    unsigned int nlines;	/* number of lines in this extension */
+    char **lines;		/* pointer to the extension array of strings */
+}      XpmExtension;
+
+typedef struct {
+    char *string;		/* characters string */
+    char *symbolic;		/* symbolic name */
+    char *m_color;		/* monochrom default */
+    char *g4_color;		/* 4 level grayscale default */
+    char *g_color;		/* other level grayscale default */
+    char *c_color;		/* color default */
+}      XpmColor;
+
+typedef struct {
+    unsigned int width;		/* image width */
+    unsigned int height;	/* image height */
+    unsigned int cpp;		/* number of characters per pixel */
+    unsigned int ncolors;	/* number of colors */
+    XpmColor *colorTable;	/* list of related colors */
+    unsigned int *data;		/* image data */
+}      XpmImage;
+
+typedef struct {
+    unsigned long valuemask;	/* Specifies which attributes are defined */
+    char *hints_cmt;		/* Comment of the hints section */
+    char *colors_cmt;		/* Comment of the colors section */
+    char *pixels_cmt;		/* Comment of the pixels section */
+    unsigned int x_hotspot;	/* Returns the x hotspot's coordinate */
+    unsigned int y_hotspot;	/* Returns the y hotspot's coordinate */
+    unsigned int nextensions;	/* number of extensions */
+    XpmExtension *extensions;	/* pointer to array of extensions */
+}      XpmInfo;
+
+typedef int (*XpmAllocColorFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    char*			/* colorname */,
+    XColor*			/* xcolor */,
+    void*			/* closure */
+#endif
+);
+
+typedef int (*XpmFreeColorsFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    Pixel*			/* pixels */,
+    int				/* npixels */,
+    void*			/* closure */
+#endif
+);
+
+typedef struct {
+    unsigned long valuemask;		/* Specifies which attributes are
+					   defined */
+
+    Visual *visual;			/* Specifies the visual to use */
+    Colormap colormap;			/* Specifies the colormap to use */
+    unsigned int depth;			/* Specifies the depth */
+    unsigned int width;			/* Returns the width of the created
+					   pixmap */
+    unsigned int height;		/* Returns the height of the created
+					   pixmap */
+    unsigned int x_hotspot;		/* Returns the x hotspot's
+					   coordinate */
+    unsigned int y_hotspot;		/* Returns the y hotspot's
+					   coordinate */
+    unsigned int cpp;			/* Specifies the number of char per
+					   pixel */
+    Pixel *pixels;			/* List of used color pixels */
+    unsigned int npixels;		/* Number of used pixels */
+    XpmColorSymbol *colorsymbols;	/* List of color symbols to override */
+    unsigned int numsymbols;		/* Number of symbols */
+    char *rgb_fname;			/* RGB text file name */
+    unsigned int nextensions;		/* Number of extensions */
+    XpmExtension *extensions;		/* List of extensions */
+
+    unsigned int ncolors;               /* Number of colors */
+    XpmColor *colorTable;               /* List of colors */
+/* 3.2 backward compatibility code */
+    char *hints_cmt;                    /* Comment of the hints section */
+    char *colors_cmt;                   /* Comment of the colors section */
+    char *pixels_cmt;                   /* Comment of the pixels section */
+/* end 3.2 bc */
+    unsigned int mask_pixel;            /* Color table index of transparent
+                                           color */
+
+    /* Color Allocation Directives */
+    Bool exactColors;			/* Only use exact colors for visual */
+    unsigned int closeness;		/* Allowable RGB deviation */
+    unsigned int red_closeness;		/* Allowable red deviation */
+    unsigned int green_closeness;	/* Allowable green deviation */
+    unsigned int blue_closeness;	/* Allowable blue deviation */
+    int color_key;			/* Use colors from this color set */
+
+    Pixel *alloc_pixels;		/* Returns the list of alloc'ed color
+					   pixels */
+    int nalloc_pixels;			/* Returns the number of alloc'ed
+					   color pixels */
+
+    Bool alloc_close_colors;    	/* Specify whether close colors should
+					   be allocated using XAllocColor
+					   or not */
+    int bitmap_format;			/* Specify the format of 1bit depth
+					   images: ZPixmap or XYBitmap */
+
+    /* Color functions */
+    XpmAllocColorFunc alloc_color;	/* Application color allocator */
+    XpmFreeColorsFunc free_colors;	/* Application color de-allocator */
+    void *color_closure;		/* Application private data to pass to
+					   alloc_color and free_colors */
+
+}      XpmAttributes;
+
+/* XpmAttributes value masks bits */
+#define XpmVisual	   (1L<<0)
+#define XpmColormap	   (1L<<1)
+#define XpmDepth	   (1L<<2)
+#define XpmSize		   (1L<<3)	/* width & height */
+#define XpmHotspot	   (1L<<4)	/* x_hotspot & y_hotspot */
+#define XpmCharsPerPixel   (1L<<5)
+#define XpmColorSymbols	   (1L<<6)
+#define XpmRgbFilename	   (1L<<7)
+/* 3.2 backward compatibility code */
+#define XpmInfos	   (1L<<8)
+#define XpmReturnInfos	   XpmInfos
+/* end 3.2 bc */
+#define XpmReturnPixels	   (1L<<9)
+#define XpmExtensions      (1L<<10)
+#define XpmReturnExtensions XpmExtensions
+
+#define XpmExactColors     (1L<<11)
+#define XpmCloseness	   (1L<<12)
+#define XpmRGBCloseness	   (1L<<13)
+#define XpmColorKey	   (1L<<14)
+
+#define XpmColorTable      (1L<<15)
+#define XpmReturnColorTable XpmColorTable
+
+#define XpmReturnAllocPixels (1L<<16)
+#define XpmAllocCloseColors (1L<<17)
+#define XpmBitmapFormat    (1L<<18)
+
+#define XpmAllocColor      (1L<<19)
+#define XpmFreeColors      (1L<<20)
+#define XpmColorClosure    (1L<<21)
+
+
+/* XpmInfo value masks bits */
+#define XpmComments        XpmInfos
+#define XpmReturnComments  XpmComments
+
+/* XpmAttributes mask_pixel value when there is no mask */
+#ifndef FOR_MSW
+#define XpmUndefPixel 0x80000000
+#else
+/* int is only 16 bit for MSW */
+#define XpmUndefPixel 0x8000
+#endif
+
+/*
+ * color keys for visual type, they must fit along with the number key of
+ * each related element in xpmColorKeys[] defined in XpmI.h
+ */
+#define XPM_MONO	2
+#define XPM_GREY4	3
+#define XPM_GRAY4	3
+#define XPM_GREY 	4
+#define XPM_GRAY 	4
+#define XPM_COLOR	5
+
+
+/* macros for forward declarations of functions with prototypes */
+#if NeedFunctionPrototypes
+#define FUNC(f, t, p) extern t f p
+#define LFUNC(f, t, p) static t f p
+#else
+#define FUNC(f, t, p) extern t f()
+#define LFUNC(f, t, p) static t f()
+#endif
+
+
+/*
+ * functions declarations
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* FOR_MSW, all ..Pixmap.. are excluded, only the ..XImage.. are used */
+/* Same for Amiga! */
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromData, int, (Display *display,
+					Drawable d,
+					char **data,
+					Pixmap *pixmap_return,
+					Pixmap *shapemask_return,
+					XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromPixmap, int, (Display *display,
+					char ***data_return,
+					Pixmap pixmap,
+					Pixmap shapemask,
+					XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToPixmap, int, (Display *display,
+				    Drawable d,
+				    char *filename,
+				    Pixmap *pixmap_return,
+				    Pixmap *shapemask_return,
+				    XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromPixmap, int, (Display *display,
+				       char *filename,
+				       Pixmap pixmap,
+				       Pixmap shapemask,
+				       XpmAttributes *attributes));
+#endif
+
+    FUNC(XpmCreateImageFromData, int, (Display *display,
+				       char **data,
+				       XImage **image_return,
+				       XImage **shapemask_return,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromImage, int, (Display *display,
+				       char ***data_return,
+				       XImage *image,
+				       XImage *shapeimage,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToImage, int, (Display *display,
+				   char *filename,
+				   XImage **image_return,
+				   XImage **shapeimage_return,
+				   XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromImage, int, (Display *display,
+				      char *filename,
+				      XImage *image,
+				      XImage *shapeimage,
+				      XpmAttributes *attributes));
+
+    FUNC(XpmCreateImageFromBuffer, int, (Display *display,
+					 char *buffer,
+					 XImage **image_return,
+					 XImage **shapemask_return,
+					 XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromBuffer, int, (Display *display,
+					  Drawable d,
+					  char *buffer,
+					  Pixmap *pixmap_return,
+					  Pixmap *shapemask_return,
+					  XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromImage, int, (Display *display,
+					 char **buffer_return,
+					 XImage *image,
+					 XImage *shapeimage,
+					 XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromPixmap, int, (Display *display,
+					  char **buffer_return,
+					  Pixmap pixmap,
+					  Pixmap shapemask,
+					  XpmAttributes *attributes));
+#endif
+    FUNC(XpmReadFileToBuffer, int, (char *filename, char **buffer_return));
+    FUNC(XpmWriteFileFromBuffer, int, (char *filename, char *buffer));
+
+    FUNC(XpmReadFileToData, int, (char *filename, char ***data_return));
+    FUNC(XpmWriteFileFromData, int, (char *filename, char **data));
+
+    FUNC(XpmAttributesSize, int, ());
+    FUNC(XpmFreeAttributes, void, (XpmAttributes *attributes));
+    FUNC(XpmFreeExtensions, void, (XpmExtension *extensions,
+				   int nextensions));
+
+    FUNC(XpmFreeXpmImage, void, (XpmImage *image));
+    FUNC(XpmFreeXpmInfo, void, (XpmInfo *info));
+    FUNC(XpmGetErrorString, char *, (int errcode));
+    FUNC(XpmLibraryVersion, int, ());
+
+    /* XpmImage functions */
+    FUNC(XpmReadFileToXpmImage, int, (char *filename,
+				      XpmImage *image,
+				      XpmInfo *info));
+
+    FUNC(XpmWriteFileFromXpmImage, int, (char *filename,
+					 XpmImage *image,
+					 XpmInfo *info));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromXpmImage, int, (Display *display,
+					    Drawable d,
+					    XpmImage *image,
+					    Pixmap *pixmap_return,
+					    Pixmap *shapemask_return,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateImageFromXpmImage, int, (Display *display,
+					   XpmImage *image,
+					   XImage **image_return,
+					   XImage **shapeimage_return,
+					   XpmAttributes *attributes));
+
+    FUNC(XpmCreateXpmImageFromImage, int, (Display *display,
+					   XImage *image,
+					   XImage *shapeimage,
+					   XpmImage *xpmimage,
+					   XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreateXpmImageFromPixmap, int, (Display *display,
+					    Pixmap pixmap,
+					    Pixmap shapemask,
+					    XpmImage *xpmimage,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateDataFromXpmImage, int, (char ***data_return,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromData, int, (char **data,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromBuffer, int, (char *buffer,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmCreateBufferFromXpmImage, int, (char **buffer_return,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmGetParseError, int, (char *filename,
+				 int *linenum_return,
+				 int *charnum_return));
+
+    FUNC(XpmFree, void, (void *ptr));
+
+#ifdef __cplusplus
+} /* for C++ V2.0 */
+#endif
+
+
+/* backward compatibility */
+
+/* for version 3.0c */
+#define XpmPixmapColorError  XpmColorError
+#define XpmPixmapSuccess     XpmSuccess
+#define XpmPixmapOpenFailed  XpmOpenFailed
+#define XpmPixmapFileInvalid XpmFileInvalid
+#define XpmPixmapNoMemory    XpmNoMemory
+#define XpmPixmapColorFailed XpmColorFailed
+
+#define XpmReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XpmWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+
+/* for version 3.0b */
+#define PixmapColorError  XpmColorError
+#define PixmapSuccess     XpmSuccess
+#define PixmapOpenFailed  XpmOpenFailed
+#define PixmapFileInvalid XpmFileInvalid
+#define PixmapNoMemory    XpmNoMemory
+#define PixmapColorFailed XpmColorFailed
+
+#define ColorSymbol XpmColorSymbol
+
+#define XReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+#define XCreatePixmapFromData(dpy, d, data, pix, mask, att) \
+    XpmCreatePixmapFromData(dpy, d, data, pix, mask, att)
+#define XCreateDataFromPixmap(dpy, data, pix, mask, att) \
+    XpmCreateDataFromPixmap(dpy, data, pix, mask, att)
+
+#endif /* XPM_NUMBERS */
+#endif
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Xpm-def.cpp rxvt-2.7.2/W11/xpm-3.4k/lib/Xpm-def.cpp
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/Xpm-def.cpp	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/Xpm-def.cpp	Mon May 14 08:23:10 2001
@@ -0,0 +1,37 @@
+LIBRARY Xpm
+VERSION LIBRARY_VERSION
+EXPORTS
+ XpmAttributesSize
+ XpmCreateBufferFromImage
+ XpmCreateBufferFromPixmap
+ XpmCreateBufferFromXpmImage
+ XpmCreateDataFromImage
+ XpmCreateDataFromPixmap
+ XpmCreateDataFromXpmImage
+ XpmCreateImageFromBuffer
+ XpmCreateImageFromData
+ XpmCreateImageFromXpmImage
+ XpmCreatePixmapFromBuffer
+ XpmCreatePixmapFromData
+ XpmCreatePixmapFromXpmImage
+ XpmCreateXpmImageFromBuffer
+ XpmCreateXpmImageFromData
+ XpmCreateXpmImageFromImage
+ XpmCreateXpmImageFromPixmap
+ XpmFree
+ XpmFreeAttributes
+ XpmFreeExtensions
+ XpmFreeXpmImage
+ XpmFreeXpmInfo
+ XpmGetErrorString
+ XpmLibraryVersion
+ XpmReadFileToBuffer
+ XpmReadFileToData
+ XpmReadFileToImage
+ XpmReadFileToPixmap
+ XpmReadFileToXpmImage
+ XpmWriteFileFromBuffer
+ XpmWriteFileFromData
+ XpmWriteFileFromImage
+ XpmWriteFileFromPixmap
+ XpmWriteFileFromXpmImage
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/XpmI.h rxvt-2.7.2/W11/xpm-3.4k/lib/XpmI.h
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/XpmI.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/XpmI.h	Mon May 14 08:23:10 2001
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* XpmI.h:                                                                     *
+*                                                                             *
+*  XPM library                                                                *
+*  Internal Include file                                                      *
+*                                                                             *
+*  ** Everything defined here is subject to changes any time. **              *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+#ifndef XPMI_h
+#define XPMI_h
+
+#include "xpm.h"
+
+/*
+ * lets try to solve include files
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+/* stdio.h doesn't declare popen on a Sequent DYNIX OS */
+#ifdef sequent
+extern FILE *popen();
+#endif
+
+#if defined(SYSV) || defined(SVR4) || defined(VMS) || defined(WIN32)
+#include <string.h>
+
+#ifndef index
+#define index strchr
+#endif
+
+#ifndef rindex
+#define rindex strrchr
+#endif
+
+#else  /* defined(SYSV) || defined(SVR4) || defined(VMS) */
+#include <strings.h>
+#endif
+
+
+
+#if defined(SYSV) || defined(SVR4) || defined(VMS) || defined(WIN32)
+#ifndef bcopy
+#define bcopy(source, dest, count) memcpy(dest, source, count)
+#endif
+#ifndef bzero
+#define bzero(b, len) memset(b, 0, len)
+#endif
+#endif
+
+/* the following is defined in X11R6 but not in previous versions */
+#ifdef __alpha
+#ifndef LONG64
+#define LONG64
+#endif
+#endif
+
+#ifdef VMS
+#include <unixio.h>
+#include <file.h>
+#endif
+
+/* The following should help people wanting to use their own memory allocation
+ * functions. To avoid the overhead of a function call when the standard
+ * functions are used these are all macros, even the XpmFree function which
+ * needs to be a real function for the outside world though.
+ * So if change these be sure to change the XpmFree function in misc.c
+ * accordingly.
+ */
+#define XpmFree(ptr) free(ptr)
+
+#ifndef FOR_MSW
+#define XpmMalloc(size) malloc((size))
+#define XpmRealloc(ptr, size) realloc((ptr), (size))
+#define XpmCalloc(nelem, elsize) calloc((nelem), (elsize))
+#else
+/* checks for mallocs bigger than 64K */
+#define XpmMalloc(size) boundCheckingMalloc((long)(size))/* in simx.[ch] */
+#define XpmRealloc(ptr, size) boundCheckingRealloc((ptr),(long)(size))
+#define XpmCalloc(nelem, elsize) \
+		boundCheckingCalloc((long)(nelem),(long) (elsize))
+#endif
+
+#define XPMMAXCMTLEN BUFSIZ
+typedef struct {
+    unsigned int type;
+    union {
+	FILE *file;
+	char **data;
+    }     stream;
+    char *cptr;
+    unsigned int line;
+    int CommentLength;
+    char Comment[XPMMAXCMTLEN];
+    char *Bcmt, *Ecmt, Bos, Eos;
+    int format;			/* 1 if XPM1, 0 otherwise */
+#ifdef CXPMPROG
+    int lineNum;
+    int charNum;
+#endif
+}      xpmData;
+
+#define XPMARRAY 0
+#define XPMFILE  1
+#define XPMPIPE  2
+#define XPMBUFFER 3
+
+#define EOL '\n'
+#define TAB '\t'
+#define SPC ' '
+
+typedef struct {
+    char *type;			/* key word */
+    char *Bcmt;			/* string beginning comments */
+    char *Ecmt;			/* string ending comments */
+    char Bos;			/* character beginning strings */
+    char Eos;			/* character ending strings */
+    char *Strs;			/* strings separator */
+    char *Dec;			/* data declaration string */
+    char *Boa;			/* string beginning assignment */
+    char *Eoa;			/* string ending assignment */
+}      xpmDataType;
+
+extern xpmDataType xpmDataTypes[];
+
+/*
+ * rgb values and ascii names (from rgb text file) rgb values,
+ * range of 0 -> 65535 color mnemonic of rgb value
+ */
+typedef struct {
+    int r, g, b;
+    char *name;
+}      xpmRgbName;
+
+/* Maximum number of rgb mnemonics allowed in rgb text file. */
+#define MAX_RGBNAMES 1024
+
+extern char *xpmColorKeys[];
+
+#define TRANSPARENT_COLOR "None"	/* this must be a string! */
+
+/* number of xpmColorKeys */
+#define NKEYS 5
+
+/* XPM internal routines */
+
+FUNC(xpmParseData, int, (xpmData *data, XpmImage *image, XpmInfo *info));
+FUNC(xpmParseDataAndCreate, int, (Display *display, xpmData *data,
+				  XImage **image_return,
+				  XImage **shapeimage_return,
+				  XpmImage *image, XpmInfo *info,
+				  XpmAttributes *attributes));
+
+FUNC(xpmFreeColorTable, void, (XpmColor *colorTable, int ncolors));
+
+FUNC(xpmInitAttributes, void, (XpmAttributes *attributes));
+
+FUNC(xpmInitXpmImage, void, (XpmImage *image));
+
+FUNC(xpmInitXpmInfo, void, (XpmInfo *info));
+
+FUNC(xpmSetInfoMask, void, (XpmInfo *info, XpmAttributes *attributes));
+FUNC(xpmSetInfo, void, (XpmInfo *info, XpmAttributes *attributes));
+FUNC(xpmSetAttributes, void, (XpmAttributes *attributes, XpmImage *image,
+			      XpmInfo *info));
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+FUNC(xpmCreatePixmapFromImage, void, (Display *display, Drawable d,
+				      XImage *ximage, Pixmap *pixmap_return));
+
+FUNC(xpmCreateImageFromPixmap, void, (Display *display, Pixmap pixmap,
+				      XImage **ximage_return,
+				      unsigned int *width,
+				      unsigned int *height));
+#endif
+
+/* structures and functions related to hastable code */
+
+typedef struct _xpmHashAtom {
+    char *name;
+    void *data;
+}      *xpmHashAtom;
+
+typedef struct {
+    int size;
+    int limit;
+    int used;
+    xpmHashAtom *atomTable;
+}      xpmHashTable;
+
+FUNC(xpmHashTableInit, int, (xpmHashTable *table));
+FUNC(xpmHashTableFree, void, (xpmHashTable *table));
+FUNC(xpmHashSlot, xpmHashAtom *, (xpmHashTable *table, char *s));
+FUNC(xpmHashIntern, int, (xpmHashTable *table, char *tag, void *data));
+
+#define HashAtomData(i) ((void *)i)
+#define HashColorIndex(slot) ((unsigned int)((*slot)->data))
+#define USE_HASHTABLE (cpp > 2 && ncolors > 4)
+
+/* I/O utility */
+
+FUNC(xpmNextString, int, (xpmData *mdata));
+FUNC(xpmNextUI, int, (xpmData *mdata, unsigned int *ui_return));
+FUNC(xpmGetString, int, (xpmData *mdata, char **sptr, unsigned int *l));
+
+#define xpmGetC(mdata) \
+	((!mdata->type || mdata->type == XPMBUFFER) ? \
+	 (*mdata->cptr++) : (getc(mdata->stream.file)))
+
+FUNC(xpmNextWord, unsigned int,
+     (xpmData *mdata, char *buf, unsigned int buflen));
+FUNC(xpmGetCmt, int, (xpmData *mdata, char **cmt));
+FUNC(xpmParseHeader, int, (xpmData *mdata));
+FUNC(xpmParseValues, int, (xpmData *data, unsigned int *width,
+			   unsigned int *height, unsigned int *ncolors,
+			   unsigned int *cpp, unsigned int *x_hotspot,
+			   unsigned int *y_hotspot, unsigned int *hotspot,
+			   unsigned int *extensions));
+
+FUNC(xpmParseColors, int, (xpmData *data, unsigned int ncolors,
+			   unsigned int cpp, XpmColor **colorTablePtr,
+			   xpmHashTable *hashtable));
+
+FUNC(xpmParseExtensions, int, (xpmData *data, XpmExtension **extensions,
+			       unsigned int *nextensions));
+
+/* RGB utility */
+
+FUNC(xpmReadRgbNames, int, (char *rgb_fname, xpmRgbName *rgbn));
+FUNC(xpmGetRgbName, char *, (xpmRgbName *rgbn, int rgbn_max,
+			     int red, int green, int blue));
+FUNC(xpmFreeRgbNames, void, (xpmRgbName *rgbn, int rgbn_max));
+#ifdef FOR_MSW
+FUNC(xpmGetRGBfromName,int, (char *name, int *r, int *g, int *b));
+#endif
+
+#ifndef AMIGA
+FUNC(xpm_xynormalizeimagebits, void, (register unsigned char *bp,
+				      register XImage *img));
+FUNC(xpm_znormalizeimagebits, void, (register unsigned char *bp,
+				     register XImage *img));
+
+/*
+ * Macros
+ *
+ * The XYNORMALIZE macro determines whether XY format data requires
+ * normalization and calls a routine to do so if needed. The logic in
+ * this module is designed for LSBFirst byte and bit order, so
+ * normalization is done as required to present the data in this order.
+ *
+ * The ZNORMALIZE macro performs byte and nibble order normalization if
+ * required for Z format data.
+ *
+ * The XYINDEX macro computes the index to the starting byte (char) boundary
+ * for a bitmap_unit containing a pixel with coordinates x and y for image
+ * data in XY format.
+ *
+ * The ZINDEX* macros compute the index to the starting byte (char) boundary
+ * for a pixel with coordinates x and y for image data in ZPixmap format.
+ *
+ */
+
+#define XYNORMALIZE(bp, img) \
+    if ((img->byte_order == MSBFirst) || (img->bitmap_bit_order == MSBFirst)) \
+	xpm_xynormalizeimagebits((unsigned char *)(bp), img)
+
+#define ZNORMALIZE(bp, img) \
+    if (img->byte_order == MSBFirst) \
+	xpm_znormalizeimagebits((unsigned char *)(bp), img)
+
+#define XYINDEX(x, y, img) \
+    ((y) * img->bytes_per_line) + \
+    (((x) + img->xoffset) / img->bitmap_unit) * (img->bitmap_unit >> 3)
+
+#define ZINDEX(x, y, img) ((y) * img->bytes_per_line) + \
+    (((x) * img->bits_per_pixel) >> 3)
+
+#define ZINDEX32(x, y, img) ((y) * img->bytes_per_line) + ((x) << 2)
+
+#define ZINDEX16(x, y, img) ((y) * img->bytes_per_line) + ((x) << 1)
+
+#define ZINDEX8(x, y, img) ((y) * img->bytes_per_line) + (x)
+
+#define ZINDEX1(x, y, img) ((y) * img->bytes_per_line) + ((x) >> 3)
+#endif /* not AMIGA */
+
+#ifdef __STDC__
+#define Const const
+#else
+#define Const /**/
+#endif
+
+#ifdef NEED_STRDUP
+FUNC(xpmstrdup, char *, (char *s1));
+#else
+#undef xpmstrdup
+#define xpmstrdup strdup
+#endif
+
+#ifdef NEED_STRCASECMP                   
+FUNC(xpmstrcasecmp, int, (char *s1, char *s2));
+#else
+#undef xpmstrcasecmp
+#define xpmstrcasecmp strcasecmp
+#endif
+
+FUNC(xpmatoui, unsigned int,
+     (char *p, unsigned int l, unsigned int *ui_return));
+
+#endif
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/amigax.c rxvt-2.7.2/W11/xpm-3.4k/lib/amigax.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/amigax.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/amigax.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,382 @@
+/*
+ * Copyright (C) 19896 Lorens Younes
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * Lorens Younes BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Lorens Younes shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Lorens Younes.
+ */
+
+/*****************************************************************************\
+* amigax.c:                                                                   *
+*                                                                             *
+*  XPM library                                                                *
+*  Emulates some Xlib functionality for Amiga.                                *
+*                                                                             *
+*  Developed by Lorens Younes (d93-hyo@nada.kth.se) 7/95                      *
+*  Revised 4/96                                                               *
+\*****************************************************************************/
+
+#include "XpmI.h"
+#include "amigax.h"
+
+#include <graphics/gfxbase.h>
+#include <intuition/screens.h>
+
+#include <proto/exec.h>
+
+
+static struct RastPort *
+AllocRastPort (unsigned int, unsigned int, unsigned int);
+static void
+FreeRastPort (struct RastPort *, unsigned int,unsigned int);
+
+
+static struct RastPort *
+AllocRastPort (
+    unsigned int   width,
+    unsigned int   height,
+    unsigned int   depth)
+{
+    struct RastPort  *rp;
+    
+    rp = XpmMalloc (sizeof (*rp));
+    if (rp != NULL)
+    {
+	InitRastPort (rp);
+	if (GfxBase->LibNode.lib_Version >= 39)
+	{
+	    rp->BitMap = AllocBitMap (width, height, depth, BMF_CLEAR, NULL);
+	    if (rp->BitMap == NULL)
+	    {
+		FreeRastPort (rp, width, height);
+		return NULL;
+	    }
+	}
+	else
+	{
+	    unsigned int   i;
+	    
+	    rp->BitMap = XpmMalloc (sizeof (*rp->BitMap));
+	    if (rp->BitMap == NULL)
+	    {
+		FreeRastPort (rp, width, height);
+		return NULL;
+	    }
+	    
+	    InitBitMap (rp->BitMap, depth, width, height);
+	    for (i = 0; i < depth; ++i)
+		rp->BitMap->Planes[i] = NULL;
+	    for (i = 0; i < depth; ++i)
+	    {
+		rp->BitMap->Planes[i] = (PLANEPTR)AllocRaster (width, height);
+		if (rp->BitMap->Planes[i] == NULL)
+		{
+		    FreeRastPort (rp, width, height);
+		    return NULL;
+		}
+	    }
+	}
+    }
+    
+    return rp;
+}
+
+
+static void
+FreeRastPort (
+    struct RastPort  *rp,
+    unsigned int      width,
+    unsigned int      height)
+{
+    if (rp != NULL)
+    {
+	if (rp->BitMap != NULL)
+	{
+	    WaitBlit ();
+	    if (GfxBase->LibNode.lib_Version >= 39)
+		FreeBitMap (rp->BitMap);
+	    else
+	    {
+		unsigned int   i;
+		
+		for (i = 0; i < rp->BitMap->Depth; ++i)
+		{
+		    if (rp->BitMap->Planes[i] != NULL)
+			FreeRaster (rp->BitMap->Planes[i], width, height);
+		}
+		XpmFree (rp->BitMap);
+	    }
+	}
+	XpmFree (rp);
+    }
+}
+
+
+XImage *
+AllocXImage (
+    unsigned int   width,
+    unsigned int   height,
+    unsigned int   depth)
+{
+    XImage  *img;
+    
+    img = XpmMalloc (sizeof (*img));
+    if (img != NULL)
+    {
+	img->width = width;
+	img->height = height;
+	img->rp = AllocRastPort (img->width, img->height, depth);
+	if (img->rp == NULL)
+	{
+	    FreeXImage (img);
+	    return NULL;
+	}
+    }
+    
+    return img;
+}
+
+
+int
+FreeXImage (
+    XImage  *ximage)
+{
+    if (ximage != NULL)
+    {
+	FreeRastPort (ximage->rp, ximage->width, ximage->height);
+	XpmFree (ximage);
+    }
+    
+    return Success;
+}
+
+
+int
+XPutPixel (
+    XImage         *ximage,
+    int             x,
+    int             y,
+    unsigned long   pixel)
+{
+    SetAPen (ximage->rp, pixel);
+    WritePixel (ximage->rp, x, y);
+    
+    return Success;
+}
+
+
+Status
+AllocBestPen (
+    Colormap        colormap,
+    XColor         *screen_in_out,
+    unsigned long   precision,
+    Bool            fail_if_bad)
+{
+    if (GfxBase->LibNode.lib_Version >= 39)
+    {
+	unsigned long   r, g, b;
+	
+	r = screen_in_out->red * 0x00010001;
+	g = screen_in_out->green * 0x00010001;
+	b = screen_in_out->blue * 0x00010001;
+	screen_in_out->pixel = ObtainBestPen (colormap, r, g, b,
+					      OBP_Precision, precision,
+					      OBP_FailIfBad, fail_if_bad,
+					      TAG_DONE);
+	if (screen_in_out->pixel == -1)
+	    return False;
+	
+	QueryColor (colormap, screen_in_out);
+    }
+    else
+    {
+	XColor   nearest, trial;
+	long     nearest_delta, trial_delta;
+	int      num_cells, i;
+	
+	num_cells = colormap->Count;
+	nearest.pixel = 0;
+	QueryColor (colormap, &nearest);
+	nearest_delta = ((((screen_in_out->red >> 8) - (nearest.red >> 8))
+			  * ((screen_in_out->red >> 8) - (nearest.red >> 8)))
+			 +
+			 (((screen_in_out->green >> 8) - (nearest.green >> 8))
+			  * ((screen_in_out->green >> 8) - (nearest.green >> 8)))
+			 +
+			 (((screen_in_out->blue >> 8) - (nearest.blue >> 8))
+			  * ((screen_in_out->blue >> 8) - (nearest.blue >> 8))));
+	for (i = 1; i < num_cells; i++)
+	{
+	/* precision and fail_if_bad is ignored under pre V39 */
+	    trial.pixel = i;
+	    QueryColor (colormap, &trial);
+	    trial_delta = ((((screen_in_out->red >> 8) - (trial.red >> 8))
+			    * ((screen_in_out->red >> 8) - (trial.red >> 8)))
+			   +
+			   (((screen_in_out->green >> 8) - (trial.green >> 8))
+			    * ((screen_in_out->green >> 8) - (trial.green >> 8)))
+			   +
+			   (((screen_in_out->blue >> 8) - (trial.blue >> 8))
+			    * ((screen_in_out->blue >> 8) - (trial.blue >> 8))));
+	    if (trial_delta < nearest_delta)
+	    {
+		nearest = trial;
+		nearest_delta = trial_delta;
+	    }
+	}
+	screen_in_out->pixel = nearest.pixel;
+	screen_in_out->red = nearest.red;
+	screen_in_out->green = nearest.green;
+	screen_in_out->blue = nearest.blue;
+    }
+    
+    return True;
+}
+
+
+int
+FreePens (
+    Colormap        colormap,
+    unsigned long  *pixels,
+    int             npixels)
+{
+    if (GfxBase->LibNode.lib_Version >= 39)
+    {
+	int   i;
+	
+	for (i = 0; i < npixels; i++)
+	    ReleasePen (colormap, pixels[i]);
+    }
+    
+    return Success;
+}
+
+
+Status
+ParseColor (
+    char    *spec,
+    XColor  *exact_def_return)
+{
+    int spec_length;
+    
+    if (spec == 0)
+	return False;
+    
+    spec_length = strlen(spec);
+    if (spec[0] == '#')
+    {
+	int hexlen;
+	char hexstr[10];
+	
+	hexlen = (spec_length - 1) / 3;
+	if (hexlen < 1 || hexlen > 4 || hexlen * 3 != spec_length - 1)
+	    return False;
+	
+	hexstr[hexlen] = '\0';
+	strncpy (hexstr, spec + 1, hexlen);
+	exact_def_return->red = strtoul (hexstr, NULL, 16) << (16 - 4*hexlen);
+	strncpy (hexstr, spec + 1 + hexlen, hexlen);
+	exact_def_return->green = strtoul (hexstr, NULL, 16) << (16 - 4*hexlen);
+	strncpy (hexstr, spec + 1 + 2 * hexlen, hexlen);
+	exact_def_return->blue = strtoul (hexstr, NULL, 16) << (16 - 4*hexlen);
+	
+	return True;
+    }
+    else
+    {
+	FILE  *rgbf;
+	int    items, red, green, blue;
+	char   line[512], name[512];
+	Bool   success = False;
+	
+	rgbf = fopen ("LIBS:rgb.txt", "r");
+	if (rgbf == NULL)
+	    return False;
+	
+	while (fgets(line, sizeof (line), rgbf) && !success)
+	{
+	    items = sscanf (line, "%d %d %d %[^\n]\n",
+			    &red, &green, &blue, name);
+	    if (items != 4)
+		continue;
+	    
+	    if (red < 0 || red > 0xFF
+		|| green < 0 || green > 0xFF
+		|| blue < 0 || blue > 0xFF)
+	    {
+		continue;
+	    }
+	    
+	    if (0 == xpmstrcasecmp (spec, name))
+	    {
+		exact_def_return->red = red * 0x0101;
+		exact_def_return->green = green * 0x0101;
+		exact_def_return->blue = blue * 0x0101;
+		success = True;
+	    }
+	}
+	fclose (rgbf);
+	
+	return success;
+    }
+}
+
+
+int
+QueryColor (
+    Colormap   colormap,
+    XColor    *def_in_out)
+{
+    if (GfxBase->LibNode.lib_Version >= 39)
+    {
+	unsigned long   rgb[3];
+	
+	GetRGB32 (colormap, def_in_out->pixel, 1, rgb);
+	def_in_out->red = rgb[0] >> 16;
+	def_in_out->green = rgb[1] >> 16;
+	def_in_out->blue = rgb[2] >> 16;
+    }
+    else
+    {
+	unsigned short   rgb;
+	
+	rgb = GetRGB4 (colormap, def_in_out->pixel);
+	def_in_out->red = ((rgb >> 8) & 0xF) * 0x1111;
+	def_in_out->green = ((rgb >> 4) & 0xF) * 0x1111;
+	def_in_out->blue = (rgb & 0xF) * 0x1111;
+    }
+    
+    return Success;
+}
+
+
+int
+QueryColors (
+    Colormap   colormap,
+    XColor    *defs_in_out,
+    int        ncolors)
+{
+    int   i;
+    
+    for (i = 0; i < ncolors; i++)
+	QueryColor (colormap, &defs_in_out[i]);
+    
+    return Success;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/amigax.h rxvt-2.7.2/W11/xpm-3.4k/lib/amigax.h
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/amigax.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/amigax.h	Mon May 14 08:23:10 2001
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 1996 Lorens Younes
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * Lorens Younes BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Lorens Younes shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Lorens Younes.
+ */
+
+/*****************************************************************************\
+* amigax.h:                                                                   *
+*                                                                             *
+*  XPM library                                                                *
+*  Emulates some Xlib functionality for Amiga.                                *
+*                                                                             *
+*  Developed by Lorens Younes (d93-hyo@nada.kth.se) 7/95                      *
+*  Revised 4/96                                                               *
+\*****************************************************************************/
+
+#ifndef AMIGA_X
+#define AMIGA_X
+
+
+#include <intuition/screens.h>
+
+#include <proto/exec.h>
+#include <proto/graphics.h>
+
+
+#define Success   0
+
+/* really never used */
+#define ZPixmap   2
+
+#define Bool     int
+#define Status   int
+#define True     1
+#define False    0
+
+typedef struct ColorMap  *Colormap;
+
+typedef void  *Visual;
+
+typedef struct {
+    int               width, height;
+    struct RastPort  *rp;
+}   XImage;
+
+typedef struct {
+    unsigned long    pixel;
+    unsigned short   red, green, blue;
+}   XColor;
+
+typedef struct Screen   Display;
+
+
+#define XGrabServer(dpy)     (Forbid ())
+#define XUngrabServer(dpy)   (Permit ())
+
+#define XDefaultScreen(dpy)          (0)
+#define XDefaultVisual(dpy, scr)     (NULL)
+#define XDefaultColormap(dpy, scr)   (dpy->ViewPort.ColorMap)
+#define XDefaultDepth(dpy, scr)      (dpy->RastPort.BitMap->Depth)
+
+#define XCreateImage(dpy, vi, depth, format, offset, data, width, height, pad, bpl) \
+	(AllocXImage (width, height, depth))
+#define XDestroyImage(img)   (FreeXImage (img))
+
+#define XAllocColor(dpy, cm, xc) \
+	(AllocBestPen (cm, xc, PRECISION_EXACT, True))
+#define XFreeColors(dpy, cm, pixels, npixels, planes) \
+	(FreePens (cm, pixels, npixels))
+#define XParseColor(dpy, cm, spec, exact_def_return) \
+	(ParseColor (spec, exact_def_return))
+#define XQueryColor(dpy, cm, def_in_out) \
+	(QueryColor(cm, def_in_out))
+#define XQueryColors(dpy, cm, defs_in_out, ncolors) \
+	(QueryColors(cm, defs_in_out, ncolors))
+
+
+XImage *
+AllocXImage (
+    unsigned int   width,
+    unsigned int   height,
+    unsigned int   depth);
+
+
+int
+FreeXImage (
+    XImage  *ximage);
+
+
+int
+XPutPixel (
+    XImage         *ximage,
+    int             x,
+    int             y,
+    unsigned long   pixel);
+
+
+Status
+AllocBestPen (
+    Colormap        colormap,
+    XColor         *screen_in_out,
+    unsigned long   precision,
+    Bool            fail_if_bad);
+
+
+int
+FreePens (
+    Colormap        colormap,
+    unsigned long  *pixels,
+    int             npixels);
+
+
+Status
+ParseColor (
+    char      *spec,
+    XColor    *exact_def_return);
+
+
+int
+QueryColor (
+    Colormap   colormap,
+    XColor    *def_in_out);
+
+
+int
+QueryColors (
+    Colormap   colormap,
+    XColor    *defs_in_out,
+    int        ncolors);
+
+
+#endif /* AMIGA_X */
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/create.c rxvt-2.7.2/W11/xpm-3.4k/lib/create.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/create.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/create.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,2486 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* create.c:                                                                   *
+*                                                                             *
+*  XPM library                                                                *
+*  Create an X image and possibly its related shape mask                      *
+*  from the given XpmImage.                                                   *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+/*
+ * The code related to AMIGA has been added by
+ * Lorens Younes (d93-hyo@nada.kth.se) 4/96
+ */
+
+#include "XpmI.h"
+#include <ctype.h>
+
+LFUNC(xpmVisualType, int, (Visual *visual));
+
+LFUNC(AllocColor, int, (Display *display, Colormap colormap,
+			char *colorname, XColor *xcolor, void *closure));
+LFUNC(FreeColors, int, (Display *display, Colormap colormap,
+			Pixel *pixels, int n, void *closure));
+
+#ifndef FOR_MSW
+LFUNC(SetCloseColor, int, (Display *display, Colormap colormap,
+			   Visual *visual, XColor *col,
+			   Pixel *image_pixel, Pixel *mask_pixel,
+			   Pixel *alloc_pixels, unsigned int *nalloc_pixels,
+			   XpmAttributes *attributes, XColor *cols, int ncols,
+			   XpmAllocColorFunc allocColor, void *closure));
+#else
+/* let the window system take care of close colors */
+#endif
+
+LFUNC(SetColor, int, (Display *display, Colormap colormap, Visual *visual,
+		      char *colorname, unsigned int color_index,
+		      Pixel *image_pixel, Pixel *mask_pixel,
+		      unsigned int *mask_pixel_index,
+		      Pixel *alloc_pixels, unsigned int *nalloc_pixels,
+		      Pixel *used_pixels, unsigned int *nused_pixels,
+		      XpmAttributes *attributes, XColor *cols, int ncols,
+		      XpmAllocColorFunc allocColor, void *closure));
+
+LFUNC(CreateXImage, int, (Display *display, Visual *visual,
+			  unsigned int depth, int format, unsigned int width,
+                          unsigned int height, XImage **image_return));
+
+LFUNC(CreateColors, int, (Display *display, XpmAttributes *attributes,
+                          XpmColor *colors, unsigned int ncolors,
+                          Pixel *image_pixels, Pixel *mask_pixels,
+                          unsigned int *mask_pixel_index,
+                          Pixel *alloc_pixels, unsigned int *nalloc_pixels,
+                          Pixel *used_pixels, unsigned int *nused_pixels));
+
+#ifndef FOR_MSW
+LFUNC(ParseAndPutPixels, int, (xpmData *data, unsigned int width,
+			       unsigned int height, unsigned int ncolors,
+			       unsigned int cpp, XpmColor *colorTable,
+			       xpmHashTable *hashtable,
+			       XImage *image, Pixel *image_pixels,
+			       XImage *mask, Pixel *mask_pixels));
+#else  /* FOR_MSW */
+LFUNC(ParseAndPutPixels, int, (Display *dc, xpmData *data, unsigned int width,
+			       unsigned int height, unsigned int ncolors,
+			       unsigned int cpp, XpmColor *colorTable,
+			       xpmHashTable *hashtable,
+			       XImage *image, Pixel *image_pixels,
+			       XImage *mask, Pixel *mask_pixels));
+#endif
+
+#ifndef FOR_MSW
+# ifndef AMIGA
+/* XImage pixel routines */
+LFUNC(PutImagePixels, void, (XImage *image, unsigned int width,
+			     unsigned int height, unsigned int *pixelindex,
+			     Pixel *pixels));
+
+LFUNC(PutImagePixels32, void, (XImage *image, unsigned int width,
+			       unsigned int height, unsigned int *pixelindex,
+			       Pixel *pixels));
+
+LFUNC(PutImagePixels16, void, (XImage *image, unsigned int width,
+			       unsigned int height, unsigned int *pixelindex,
+			       Pixel *pixels));
+
+LFUNC(PutImagePixels8, void, (XImage *image, unsigned int width,
+			      unsigned int height, unsigned int *pixelindex,
+			      Pixel *pixels));
+
+LFUNC(PutImagePixels1, void, (XImage *image, unsigned int width,
+			      unsigned int height, unsigned int *pixelindex,
+			      Pixel *pixels));
+
+LFUNC(PutPixel1, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel32, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel32MSB, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel32LSB, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel16MSB, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel16LSB, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel8, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel1MSB, int, (XImage *ximage, int x, int y, unsigned long pixel));
+LFUNC(PutPixel1LSB, int, (XImage *ximage, int x, int y, unsigned long pixel));
+
+# else /* AMIGA */
+LFUNC(APutImagePixels, void, (XImage *ximage, unsigned int width,
+			      unsigned int height, unsigned int *pixelindex,
+			      Pixel *pixels));
+# endif/* AMIGA */
+#else  /* FOR_MSW */
+/* FOR_MSW pixel routine */
+LFUNC(MSWPutImagePixels, void, (Display *dc, XImage *image,
+				unsigned int width, unsigned int height,
+				unsigned int *pixelindex, Pixel *pixels));
+#endif /* FOR_MSW */
+
+#ifdef NEED_STRCASECMP
+FUNC(xpmstrcasecmp, int, (char *s1, char *s2));
+
+/*
+ * in case strcasecmp is not provided by the system here is one
+ * which does the trick
+ */
+int
+xpmstrcasecmp(s1, s2)
+    register char *s1, *s2;
+{
+    register int c1, c2;
+
+    while (*s1 && *s2) {
+	c1 = tolower(*s1);
+	c2 = tolower(*s2);
+	if (c1 != c2)
+	    return (c1 - c2);
+	s1++;
+	s2++;
+    }
+    return (int) (*s1 - *s2);
+}
+
+#endif
+
+/*
+ * return the default color key related to the given visual
+ */
+static int
+xpmVisualType(visual)
+    Visual *visual;
+{
+#ifndef FOR_MSW
+# ifndef AMIGA
+    switch (visual->class) {
+    case StaticGray:
+    case GrayScale:
+	switch (visual->map_entries) {
+	case 2:
+	    return (XPM_MONO);
+	case 4:
+	    return (XPM_GRAY4);
+	default:
+	    return (XPM_GRAY);
+	}
+    default:
+	return (XPM_COLOR);
+    }
+# else
+    /* set the key explicitly in the XpmAttributes to override this */
+    return (XPM_COLOR);
+# endif
+#else
+    /* there should be a similar switch for MSW */
+    return (XPM_COLOR);
+#endif
+}
+
+
+typedef struct {
+    int cols_index;
+    long closeness;
+}      CloseColor;
+
+static int
+closeness_cmp(a, b)
+    Const void *a, *b;
+{
+    CloseColor *x = (CloseColor *) a, *y = (CloseColor *) b;
+
+    /* cast to int as qsort requires */
+    return (int) (x->closeness - y->closeness);
+}
+
+
+/* default AllocColor function:
+ *   call XParseColor if colorname is given, return negative value if failure
+ *   call XAllocColor and return 0 if failure, positive otherwise
+ */
+static int
+AllocColor(display, colormap, colorname, xcolor, closure)
+    Display *display;
+    Colormap colormap;
+    char *colorname;
+    XColor *xcolor;
+    void *closure;		/* not used */
+{
+    int status;
+    if (colorname)
+	if (!XParseColor(display, colormap, colorname, xcolor))
+	    return -1;
+    status = XAllocColor(display, colormap, xcolor);
+    return status != 0 ? 1 : 0;
+}
+
+
+#ifndef FOR_MSW
+/*
+ * set a close color in case the exact one can't be set
+ * return 0 if success, 1 otherwise.
+ */
+
+static int
+SetCloseColor(display, colormap, visual, col, image_pixel, mask_pixel,
+	      alloc_pixels, nalloc_pixels, attributes, cols, ncols,
+	      allocColor, closure)
+    Display *display;
+    Colormap colormap;
+    Visual *visual;
+    XColor *col;
+    Pixel *image_pixel, *mask_pixel;
+    Pixel *alloc_pixels;
+    unsigned int *nalloc_pixels;
+    XpmAttributes *attributes;
+    XColor *cols;
+    int ncols;
+    XpmAllocColorFunc allocColor;
+    void *closure;
+{
+
+    /*
+     * Allocation failed, so try close colors. To get here the visual must
+     * be GreyScale, PseudoColor or DirectColor (or perhaps StaticColor?
+     * What about sharing systems like QDSS?). Beware: we have to treat
+     * DirectColor differently.
+     */
+
+
+    long int red_closeness, green_closeness, blue_closeness;
+    int n;
+    Bool alloc_color;
+
+    if (attributes && (attributes->valuemask & XpmCloseness))
+	red_closeness = green_closeness = blue_closeness =
+	    attributes->closeness;
+    else {
+	red_closeness = attributes->red_closeness;
+	green_closeness = attributes->green_closeness;
+	blue_closeness = attributes->blue_closeness;
+    }
+    if (attributes && (attributes->valuemask & XpmAllocCloseColors))
+	alloc_color = attributes->alloc_close_colors;
+    else
+	alloc_color = True;
+
+    /*
+     * We sort the colormap by closeness and try to allocate the color
+     * closest to the target. If the allocation of this close color fails,
+     * which almost never happens, then one of two scenarios is possible.
+     * Either the colormap must have changed (since the last close color
+     * allocation or possibly while we were sorting the colormap), or the
+     * color is allocated as Read/Write by some other client. (Note: X
+     * _should_ allow clients to check if a particular color is Read/Write,
+     * but it doesn't! :-( ). We cannot determine which of these scenarios
+     * occurred, so we try the next closest color, and so on, until no more
+     * colors are within closeness of the target. If we knew that the
+     * colormap had changed, we could skip this sequence.
+     * 
+     * If _none_ of the colors within closeness of the target can be allocated,
+     * then we can finally be pretty sure that the colormap has actually
+     * changed. In this case we try to allocate the original color (again),
+     * then try the closecolor stuff (again)...
+     * 
+     * In theory it would be possible for an infinite loop to occur if another
+     * process kept changing the colormap every time we sorted it, so we set
+     * a maximum on the number of iterations. After this many tries, we use
+     * XGrabServer() to ensure that the colormap remains unchanged.
+     * 
+     * This approach gives particularly bad worst case performance - as many as
+     * <MaximumIterations> colormap reads and sorts may be needed, and as
+     * many as <MaximumIterations> * <ColormapSize> attempted allocations
+     * may fail. On an 8-bit system, this means as many as 3 colormap reads,
+     * 3 sorts and 768 failed allocations per execution of this code!
+     * Luckily, my experiments show that in general use in a typical 8-bit
+     * color environment only about 1 in every 10000 allocations fails to
+     * succeed in the fastest possible time. So virtually every time what
+     * actually happens is a single sort followed by a successful allocate.
+     * The very first allocation also costs a colormap read, but no further
+     * reads are usually necessary.
+     */
+
+#define ITERATIONS 2			/* more than one is almost never
+					 * necessary */
+
+    for (n = 0; n <= ITERATIONS; ++n) {
+	CloseColor *closenesses =
+	    (CloseColor *) XpmCalloc(ncols, sizeof(CloseColor));
+	int i, c;
+
+	for (i = 0; i < ncols; ++i) {	/* build & sort closenesses table */
+#define COLOR_FACTOR       3
+#define BRIGHTNESS_FACTOR  1
+
+	    closenesses[i].cols_index = i;
+	    closenesses[i].closeness =
+		COLOR_FACTOR * (abs((long) col->red - (long) cols[i].red)
+				+ abs((long) col->green - (long) cols[i].green)
+				+ abs((long) col->blue - (long) cols[i].blue))
+		+ BRIGHTNESS_FACTOR * abs(((long) col->red +
+					   (long) col->green +
+					   (long) col->blue)
+					   - ((long) cols[i].red +
+					      (long) cols[i].green +
+					      (long) cols[i].blue));
+	}
+	qsort(closenesses, ncols, sizeof(CloseColor), closeness_cmp);
+
+	i = 0;
+	c = closenesses[i].cols_index;
+	while ((long) cols[c].red >= (long) col->red - red_closeness &&
+	       (long) cols[c].red <= (long) col->red + red_closeness &&
+	       (long) cols[c].green >= (long) col->green - green_closeness &&
+	       (long) cols[c].green <= (long) col->green + green_closeness &&
+	       (long) cols[c].blue >= (long) col->blue - blue_closeness &&
+	       (long) cols[c].blue <= (long) col->blue + blue_closeness) {
+	    if (alloc_color) {
+		if ((*allocColor)(display, colormap, NULL, &cols[c], closure)){
+		    if (n == ITERATIONS)
+			XUngrabServer(display);
+		    XpmFree(closenesses);
+		    *image_pixel = cols[c].pixel;
+		    *mask_pixel = 1;
+		    alloc_pixels[(*nalloc_pixels)++] = cols[c].pixel;
+		    return (0);
+		} else {
+		    ++i;
+		    if (i == ncols)
+			break;
+		    c = closenesses[i].cols_index;
+		}
+	    } else {
+		if (n == ITERATIONS)
+		    XUngrabServer(display);
+		XpmFree(closenesses);
+		*image_pixel = cols[c].pixel;
+		*mask_pixel = 1;
+		return (0);
+	    }
+	}
+
+	/* Couldn't allocate _any_ of the close colors! */
+
+	if (n == ITERATIONS)
+	    XUngrabServer(display);
+	XpmFree(closenesses);
+
+	if (i == 0 || i == ncols)	/* no color close enough or cannot */
+	    return (1);			/* alloc any color (full of r/w's) */
+
+	if ((*allocColor)(display, colormap, NULL, col, closure)) {
+	    *image_pixel = col->pixel;
+	    *mask_pixel = 1;
+	    alloc_pixels[(*nalloc_pixels)++] = col->pixel;
+	    return (0);
+	} else {			/* colormap has probably changed, so
+					 * re-read... */
+	    if (n == ITERATIONS - 1)
+		XGrabServer(display);
+
+#if 0
+	    if (visual->class == DirectColor) {
+		/* TODO */
+	    } else
+#endif
+		XQueryColors(display, colormap, cols, ncols);
+	}
+    }
+    return (1);
+}
+
+#define USE_CLOSECOLOR attributes && \
+(((attributes->valuemask & XpmCloseness) && attributes->closeness != 0) \
+ || ((attributes->valuemask & XpmRGBCloseness) && \
+     (attributes->red_closeness != 0 \
+      || attributes->green_closeness != 0 \
+      || attributes->blue_closeness != 0)))
+
+#else
+    /* FOR_MSW part */
+    /* nothing to do here, the window system does it */
+#endif
+
+/*
+ * set the color pixel related to the given colorname,
+ * return 0 if success, 1 otherwise.
+ */
+
+static int
+SetColor(display, colormap, visual, colorname, color_index,
+	 image_pixel, mask_pixel, mask_pixel_index,
+	 alloc_pixels, nalloc_pixels, used_pixels, nused_pixels,
+	 attributes, cols, ncols, allocColor, closure)
+    Display *display;
+    Colormap colormap;
+    Visual *visual;
+    char *colorname;
+    unsigned int color_index;
+    Pixel *image_pixel, *mask_pixel;
+    unsigned int *mask_pixel_index;
+    Pixel *alloc_pixels;
+    unsigned int *nalloc_pixels;
+    Pixel *used_pixels;
+    unsigned int *nused_pixels;
+    XpmAttributes *attributes;
+    XColor *cols;
+    int ncols;
+    XpmAllocColorFunc allocColor;
+    void *closure;
+{
+    XColor xcolor;
+    int status;
+
+    if (xpmstrcasecmp(colorname, TRANSPARENT_COLOR)) {
+	status = (*allocColor)(display, colormap, colorname, &xcolor, closure);
+	if (status < 0)		/* parse color failed */
+	    return (1);
+
+	if (status == 0) {
+#ifndef FOR_MSW
+	    if (USE_CLOSECOLOR)
+		return (SetCloseColor(display, colormap, visual, &xcolor,
+				      image_pixel, mask_pixel,
+				      alloc_pixels, nalloc_pixels,
+				      attributes, cols, ncols,
+				      allocColor, closure));
+	    else
+#endif /* ndef FOR_MSW */
+		return (1);
+	} else
+	    alloc_pixels[(*nalloc_pixels)++] = xcolor.pixel;
+	*image_pixel = xcolor.pixel;
+#ifndef FOR_MSW
+	*mask_pixel = 1;
+#else
+	*mask_pixel = RGB(0,0,0);
+#endif
+	used_pixels[(*nused_pixels)++] = xcolor.pixel;
+    } else {
+	*image_pixel = 0;
+#ifndef FOR_MSW
+	*mask_pixel = 0;
+#else
+  	*mask_pixel = RGB(255,255,255);
+#endif
+	/* store the color table index */
+	*mask_pixel_index = color_index;
+    }
+    return (0);
+}
+
+
+static int
+CreateColors(display, attributes, colors, ncolors, image_pixels, mask_pixels,
+             mask_pixel_index, alloc_pixels, nalloc_pixels,
+             used_pixels, nused_pixels)
+    Display *display;
+    XpmAttributes *attributes;
+    XpmColor *colors;
+    unsigned int ncolors;
+    Pixel *image_pixels;
+    Pixel *mask_pixels;
+    unsigned int *mask_pixel_index;
+    Pixel *alloc_pixels;
+    unsigned int *nalloc_pixels;
+    Pixel *used_pixels;
+    unsigned int *nused_pixels;
+{
+    /* variables stored in the XpmAttributes structure */
+    Visual *visual;
+    Colormap colormap;
+    XpmColorSymbol *colorsymbols;
+    unsigned int numsymbols;
+    XpmAllocColorFunc allocColor;
+    void *closure;
+
+    char *colorname;
+    unsigned int color, key;
+    Bool pixel_defined;
+    XpmColorSymbol *symbol;
+    char **defaults;
+    int ErrorStatus = XpmSuccess;
+    char *s;
+    int default_index;
+
+    XColor *cols = NULL;
+    unsigned int ncols = 0;
+
+    /*
+     * retrieve information from the XpmAttributes
+     */
+    if (attributes && attributes->valuemask & XpmColorSymbols) {
+	colorsymbols = attributes->colorsymbols;
+	numsymbols = attributes->numsymbols;
+    } else
+	numsymbols = 0;
+
+    if (attributes && attributes->valuemask & XpmVisual)
+	visual = attributes->visual;
+    else
+	visual = XDefaultVisual(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmColormap))
+	colormap = attributes->colormap;
+    else
+	colormap = XDefaultColormap(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmColorKey))
+	key = attributes->color_key;
+    else
+	key = xpmVisualType(visual);
+
+    if (attributes && (attributes->valuemask & XpmAllocColor))
+	allocColor = attributes->alloc_color;
+    else
+	allocColor = AllocColor;
+    if (attributes && (attributes->valuemask & XpmColorClosure))
+	closure = attributes->color_closure;
+    else
+	closure = NULL;
+
+#ifndef FOR_MSW
+    if (USE_CLOSECOLOR) {
+	/* originally from SetCloseColor */
+#if 0
+	if (visual->class == DirectColor) {
+
+	    /*
+	     * TODO: Implement close colors for DirectColor visuals. This is
+	     * difficult situation. Chances are that we will never get here,
+	     * because any machine that supports DirectColor will probably
+	     * also support TrueColor (and probably PseudoColor). Also,
+	     * DirectColor colormaps can be very large, so looking for close
+	     * colors may be too slow.
+	     */
+	} else {
+#endif
+	    int i;
+
+#ifndef AMIGA
+	    ncols = visual->map_entries;
+#else
+	    ncols = colormap->Count;
+#endif
+	    cols = (XColor *) XpmCalloc(ncols, sizeof(XColor));
+	    for (i = 0; i < ncols; ++i)
+		cols[i].pixel = i;
+	    XQueryColors(display, colormap, cols, ncols);
+#if 0
+	}
+#endif
+    }
+#endif /* ndef FOR_MSW */
+
+    switch (key) {
+    case XPM_MONO:
+	default_index = 2;
+	break;
+    case XPM_GRAY4:
+	default_index = 3;
+	break;
+    case XPM_GRAY:
+	default_index = 4;
+	break;
+    case XPM_COLOR:
+    default:
+	default_index = 5;
+	break;
+    }
+
+    for (color = 0; color < ncolors; color++, colors++,
+					 image_pixels++, mask_pixels++) {
+	colorname = NULL;
+	pixel_defined = False;
+	defaults = (char **) colors;
+
+	/*
+	 * look for a defined symbol
+	 */
+	if (numsymbols) {
+
+	    unsigned int n;
+
+	    s = defaults[1];
+	    for (n = 0, symbol = colorsymbols; n < numsymbols; n++, symbol++) {
+		if (symbol->name && s && !strcmp(symbol->name, s))
+		    /* override name */
+		    break;
+		if (!symbol->name && symbol->value) {	/* override value */
+		    int def_index = default_index;
+
+		    while (defaults[def_index] == NULL)	/* find defined
+							 * colorname */
+			--def_index;
+		    if (def_index < 2) {/* nothing towards mono, so try
+					 * towards color */
+			def_index = default_index + 1;
+			while (def_index <= 5 && defaults[def_index] == NULL)
+			    ++def_index;
+		    }
+		    if (def_index >= 2 && defaults[def_index] != NULL &&
+			!xpmstrcasecmp(symbol->value, defaults[def_index]))
+			break;
+		}
+	    }
+	    if (n != numsymbols) {
+		if (symbol->name && symbol->value)
+		    colorname = symbol->value;
+		else
+		    pixel_defined = True;
+	    }
+	}
+	if (!pixel_defined) {		/* pixel not given as symbol value */
+
+	    unsigned int k;
+
+	    if (colorname) {		/* colorname given as symbol value */
+		if (!SetColor(display, colormap, visual, colorname, color,
+			      image_pixels, mask_pixels, mask_pixel_index,
+			      alloc_pixels, nalloc_pixels, used_pixels,
+			      nused_pixels, attributes, cols, ncols,
+			      allocColor, closure))
+		    pixel_defined = True;
+		else
+		    ErrorStatus = XpmColorError;
+	    }
+	    k = key;
+	    while (!pixel_defined && k > 1) {
+		if (defaults[k]) {
+		    if (!SetColor(display, colormap, visual, defaults[k],
+				  color, image_pixels, mask_pixels,
+				  mask_pixel_index, alloc_pixels,
+				  nalloc_pixels, used_pixels, nused_pixels,
+				  attributes, cols, ncols,
+				  allocColor, closure)) {
+			pixel_defined = True;
+			break;
+		    } else
+			ErrorStatus = XpmColorError;
+		}
+		k--;
+	    }
+	    k = key + 1;
+	    while (!pixel_defined && k < NKEYS + 1) {
+		if (defaults[k]) {
+		    if (!SetColor(display, colormap, visual, defaults[k],
+				  color, image_pixels, mask_pixels,
+				  mask_pixel_index, alloc_pixels,
+				  nalloc_pixels, used_pixels, nused_pixels,
+				  attributes, cols, ncols,
+				  allocColor, closure)) {
+			pixel_defined = True;
+			break;
+		    } else
+			ErrorStatus = XpmColorError;
+		}
+		k++;
+	    }
+	    if (!pixel_defined) {
+		if (cols)
+		    XpmFree(cols);
+		return (XpmColorFailed);
+	    }
+	} else {
+	    /* simply use the given pixel */
+	    *image_pixels = symbol->pixel;
+	    /* the following makes the mask to be built even if none
+	       is given a particular pixel */
+	    if (symbol->value
+		&& !xpmstrcasecmp(symbol->value, TRANSPARENT_COLOR)) {
+		*mask_pixels = 0;
+		*mask_pixel_index = color;
+	    } else
+		*mask_pixels = 1;
+	    used_pixels[(*nused_pixels)++] = *image_pixels;
+	}
+    }
+    if (cols)
+	XpmFree(cols);
+    return (ErrorStatus);
+}
+
+
+/* default FreeColors function, simply call XFreeColors */
+static int
+FreeColors(display, colormap, pixels, n, closure)
+    Display *display;
+    Colormap colormap;
+    Pixel *pixels;
+    int n;
+    void *closure;		/* not used */
+{
+    return XFreeColors(display, colormap, pixels, n, 0);
+}
+
+
+/* function call in case of error */
+#undef RETURN
+#define RETURN(status) \
+{ \
+      ErrorStatus = status; \
+      goto error; \
+}
+
+int
+XpmCreateImageFromXpmImage(display, image,
+			   image_return, shapeimage_return, attributes)
+    Display *display;
+    XpmImage *image;
+    XImage **image_return;
+    XImage **shapeimage_return;
+    XpmAttributes *attributes;
+{
+    /* variables stored in the XpmAttributes structure */
+    Visual *visual;
+    Colormap colormap;
+    unsigned int depth;
+    int bitmap_format;
+    XpmFreeColorsFunc freeColors;
+    void *closure;
+
+    /* variables to return */
+    XImage *ximage = NULL;
+    XImage *shapeimage = NULL;
+    unsigned int mask_pixel_index = XpmUndefPixel;
+    int ErrorStatus;
+
+    /* calculation variables */
+    Pixel *image_pixels = NULL;
+    Pixel *mask_pixels = NULL;
+    Pixel *alloc_pixels = NULL;
+    Pixel *used_pixels = NULL;
+    unsigned int nalloc_pixels = 0;
+    unsigned int nused_pixels = 0;
+
+    /* initialize return values */
+    if (image_return)
+	*image_return = NULL;
+    if (shapeimage_return)
+	*shapeimage_return = NULL;
+
+    /* retrieve information from the XpmAttributes */
+    if (attributes && (attributes->valuemask & XpmVisual))
+	visual = attributes->visual;
+    else
+	visual = XDefaultVisual(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmColormap))
+	colormap = attributes->colormap;
+    else
+	colormap = XDefaultColormap(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmDepth))
+	depth = attributes->depth;
+    else
+	depth = XDefaultDepth(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmBitmapFormat))
+	bitmap_format = attributes->bitmap_format;
+    else
+	bitmap_format = ZPixmap;
+
+    if (attributes && (attributes->valuemask & XpmFreeColors))
+	freeColors = attributes->free_colors;
+    else
+	freeColors = FreeColors;
+    if (attributes && (attributes->valuemask & XpmColorClosure))
+	closure = attributes->color_closure;
+    else
+	closure = NULL;
+
+    ErrorStatus = XpmSuccess;
+
+    /* malloc pixels index tables */
+    image_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * image->ncolors);
+    if (!image_pixels)
+	return (XpmNoMemory);
+
+    mask_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * image->ncolors);
+    if (!mask_pixels)
+	RETURN(XpmNoMemory);
+
+    /* maximum of allocated pixels will be the number of colors */
+    alloc_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * image->ncolors);
+    if (!alloc_pixels)
+	RETURN(XpmNoMemory);
+
+    /* maximum of allocated pixels will be the number of colors */
+    used_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * image->ncolors);
+    if (!used_pixels)
+	RETURN(XpmNoMemory);
+
+    /* get pixel colors, store them in index tables */
+    ErrorStatus = CreateColors(display, attributes, image->colorTable,
+			       image->ncolors, image_pixels, mask_pixels,
+			       &mask_pixel_index, alloc_pixels, &nalloc_pixels,
+			       used_pixels, &nused_pixels);
+
+    if (ErrorStatus != XpmSuccess
+	&& (ErrorStatus < 0 || (attributes
+				&& (attributes->valuemask & XpmExactColors)
+				&& attributes->exactColors)))
+	RETURN(ErrorStatus);
+
+    /* create the ximage */
+    if (image_return) {
+	ErrorStatus = CreateXImage(display, visual, depth,
+				   (depth == 1 ? bitmap_format : ZPixmap),
+				   image->width, image->height, &ximage);
+	if (ErrorStatus != XpmSuccess)
+	    RETURN(ErrorStatus);
+
+#ifndef FOR_MSW
+# ifndef AMIGA
+
+	/*
+	 * set the ximage data using optimized functions for ZPixmap
+	 */
+
+	if (ximage->bits_per_pixel == 8)
+	    PutImagePixels8(ximage, image->width, image->height,
+			    image->data, image_pixels);
+	else if (((ximage->bits_per_pixel | ximage->depth) == 1) &&
+		 (ximage->byte_order == ximage->bitmap_bit_order))
+	    PutImagePixels1(ximage, image->width, image->height,
+			    image->data, image_pixels);
+	else if (ximage->bits_per_pixel == 16)
+	    PutImagePixels16(ximage, image->width, image->height,
+			     image->data, image_pixels);
+	else if (ximage->bits_per_pixel == 32)
+	    PutImagePixels32(ximage, image->width, image->height,
+			     image->data, image_pixels);
+	else
+	    PutImagePixels(ximage, image->width, image->height,
+			   image->data, image_pixels);
+# else /* AMIGA */
+	APutImagePixels(ximage, image->width, image->height,
+			image->data, image_pixels);
+# endif
+#else  /* FOR_MSW */
+	MSWPutImagePixels(display, ximage, image->width, image->height,
+			  image->data, image_pixels);
+#endif
+    }
+    /* create the shape mask image */
+    if (mask_pixel_index != XpmUndefPixel && shapeimage_return) {
+	ErrorStatus = CreateXImage(display, visual, 1, bitmap_format,
+				   image->width, image->height, &shapeimage);
+	if (ErrorStatus != XpmSuccess)
+	    RETURN(ErrorStatus);
+
+#ifndef FOR_MSW
+# ifndef AMIGA
+	PutImagePixels1(shapeimage, image->width, image->height,
+			image->data, mask_pixels);
+# else /* AMIGA */
+	APutImagePixels(shapeimage, image->width, image->height,
+			image->data, mask_pixels);
+# endif
+#else  /* FOR_MSW */
+	MSWPutImagePixels(display, shapeimage, image->width, image->height,
+			  image->data, mask_pixels);
+#endif
+
+    }
+    XpmFree(image_pixels);
+    XpmFree(mask_pixels);
+
+    /* if requested return used pixels in the XpmAttributes structure */
+    if (attributes && (attributes->valuemask & XpmReturnPixels ||
+/* 3.2 backward compatibility code */
+	attributes->valuemask & XpmReturnInfos)) {
+/* end 3.2 bc */
+	attributes->pixels = used_pixels;
+	attributes->npixels = nused_pixels;
+	attributes->mask_pixel = mask_pixel_index;
+    } else
+	XpmFree(used_pixels);
+
+    /* if requested return alloc'ed pixels in the XpmAttributes structure */
+    if (attributes && (attributes->valuemask & XpmReturnAllocPixels)) {
+	attributes->alloc_pixels = alloc_pixels;
+	attributes->nalloc_pixels = nalloc_pixels;
+    } else
+	XpmFree(alloc_pixels);
+
+    /* return created images */
+    if (image_return)
+	*image_return = ximage;
+    if (shapeimage_return)
+	*shapeimage_return = shapeimage;
+
+    return (ErrorStatus);
+
+/* exit point in case of error, free only locally allocated variables */
+error:
+    if (ximage)
+	XDestroyImage(ximage);
+    if (shapeimage)
+	XDestroyImage(shapeimage);
+    if (image_pixels)
+	XpmFree(image_pixels);
+    if (mask_pixels)
+	XpmFree(mask_pixels);
+    if (nalloc_pixels)
+	(*freeColors)(display, colormap, alloc_pixels, nalloc_pixels, NULL);
+    if (alloc_pixels)
+	XpmFree(alloc_pixels);
+    if (used_pixels)
+	XpmFree(used_pixels);
+
+    return (ErrorStatus);
+}
+
+
+/*
+ * Create an XImage with its data
+ */
+static int
+CreateXImage(display, visual, depth, format, width, height, image_return)
+    Display *display;
+    Visual *visual;
+    unsigned int depth;
+    int format;
+    unsigned int width;
+    unsigned int height;
+    XImage **image_return;
+{
+    int bitmap_pad;
+
+    /* first get bitmap_pad */
+    if (depth > 16)
+	bitmap_pad = 32;
+    else if (depth > 8)
+	bitmap_pad = 16;
+    else
+	bitmap_pad = 8;
+
+    /* then create the XImage with data = NULL and bytes_per_line = 0 */
+    *image_return = XCreateImage(display, visual, depth, format, 0, 0,
+				 width, height, bitmap_pad, 0);
+    if (!*image_return)
+	return (XpmNoMemory);
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    /* now that bytes_per_line must have been set properly alloc data */
+    (*image_return)->data =
+	(char *) XpmMalloc((*image_return)->bytes_per_line * height);
+
+    if (!(*image_return)->data) {
+	XDestroyImage(*image_return);
+	*image_return = NULL;
+	return (XpmNoMemory);
+    }
+#else
+    /* under FOR_MSW and AMIGA XCreateImage has done it all */
+#endif
+    return (XpmSuccess);
+}
+
+#ifndef FOR_MSW
+# ifndef AMIGA
+/*
+ * The functions below are written from X11R5 MIT's code (XImUtil.c)
+ *
+ * The idea is to have faster functions than the standard XPutPixel function
+ * to build the image data. Indeed we can speed up things by suppressing tests
+ * performed for each pixel. We do the same tests but at the image level.
+ * We also assume that we use only ZPixmap images with null offsets.
+ */
+
+LFUNC(_putbits, void, (register char *src, int dstoffset,
+		       register int numbits, register char *dst));
+
+LFUNC(_XReverse_Bytes, int, (register unsigned char *bpt, register int nb));
+
+static unsigned char Const _reverse_byte[0x100] = {
+    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
+};
+
+static int
+_XReverse_Bytes(bpt, nb)
+    register unsigned char *bpt;
+    register int nb;
+{
+    do {
+	*bpt = _reverse_byte[*bpt];
+	bpt++;
+    } while (--nb > 0);
+    return 0;
+}
+
+
+void
+xpm_xynormalizeimagebits(bp, img)
+    register unsigned char *bp;
+    register XImage *img;
+{
+    register unsigned char c;
+
+    if (img->byte_order != img->bitmap_bit_order) {
+	switch (img->bitmap_unit) {
+
+	case 16:
+	    c = *bp;
+	    *bp = *(bp + 1);
+	    *(bp + 1) = c;
+	    break;
+
+	case 32:
+	    c = *(bp + 3);
+	    *(bp + 3) = *bp;
+	    *bp = c;
+	    c = *(bp + 2);
+	    *(bp + 2) = *(bp + 1);
+	    *(bp + 1) = c;
+	    break;
+	}
+    }
+    if (img->bitmap_bit_order == MSBFirst)
+	_XReverse_Bytes(bp, img->bitmap_unit >> 3);
+}
+
+void
+xpm_znormalizeimagebits(bp, img)
+    register unsigned char *bp;
+    register XImage *img;
+{
+    register unsigned char c;
+
+    switch (img->bits_per_pixel) {
+
+    case 2:
+	_XReverse_Bytes(bp, 1);
+	break;
+
+    case 4:
+	*bp = ((*bp >> 4) & 0xF) | ((*bp << 4) & ~0xF);
+	break;
+
+    case 16:
+	c = *bp;
+	*bp = *(bp + 1);
+	*(bp + 1) = c;
+	break;
+
+    case 24:
+	c = *(bp + 2);
+	*(bp + 2) = *bp;
+	*bp = c;
+	break;
+
+    case 32:
+	c = *(bp + 3);
+	*(bp + 3) = *bp;
+	*bp = c;
+	c = *(bp + 2);
+	*(bp + 2) = *(bp + 1);
+	*(bp + 1) = c;
+	break;
+    }
+}
+
+static unsigned char Const _lomask[0x09] = {
+0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
+static unsigned char Const _himask[0x09] = {
+0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00};
+
+static void
+_putbits(src, dstoffset, numbits, dst)
+    register char *src;			/* address of source bit string */
+    int dstoffset;			/* bit offset into destination;
+					 * range is 0-31 */
+    register int numbits;		/* number of bits to copy to
+					 * destination */
+    register char *dst;			/* address of destination bit string */
+{
+    register unsigned char chlo, chhi;
+    int hibits;
+
+    dst = dst + (dstoffset >> 3);
+    dstoffset = dstoffset & 7;
+    hibits = 8 - dstoffset;
+    chlo = *dst & _lomask[dstoffset];
+    for (;;) {
+	chhi = (*src << dstoffset) & _himask[dstoffset];
+	if (numbits <= hibits) {
+	    chhi = chhi & _lomask[dstoffset + numbits];
+	    *dst = (*dst & _himask[dstoffset + numbits]) | chlo | chhi;
+	    break;
+	}
+	*dst = chhi | chlo;
+	dst++;
+	numbits = numbits - hibits;
+	chlo = (unsigned char) (*src & _himask[hibits]) >> hibits;
+	src++;
+	if (numbits <= dstoffset) {
+	    chlo = chlo & _lomask[numbits];
+	    *dst = (*dst & _himask[numbits]) | chlo;
+	    break;
+	}
+	numbits = numbits - dstoffset;
+    }
+}
+
+/*
+ * Default method to write pixels into a Z image data structure.
+ * The algorithm used is:
+ *
+ *	copy the destination bitmap_unit or Zpixel to temp
+ *	normalize temp if needed
+ *	copy the pixel bits into the temp
+ *	renormalize temp if needed
+ *	copy the temp back into the destination image data
+ */
+
+static void
+PutImagePixels(image, width, height, pixelindex, pixels)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    unsigned int *pixelindex;
+    Pixel *pixels;
+{
+    register char *src;
+    register char *dst;
+    register unsigned int *iptr;
+    register int x, y, i;
+    register char *data;
+    Pixel pixel, px;
+    int nbytes, depth, ibu, ibpp;
+
+    data = image->data;
+    iptr = pixelindex;
+    depth = image->depth;
+    if (depth == 1) {
+	ibu = image->bitmap_unit;
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		pixel = pixels[*iptr];
+		for (i = 0, px = pixel; i < sizeof(unsigned long);
+		     i++, px >>= 8)
+		    ((unsigned char *) &pixel)[i] = px;
+		src = &data[XYINDEX(x, y, image)];
+		dst = (char *) &px;
+		px = 0;
+		nbytes = ibu >> 3;
+		for (i = nbytes; --i >= 0;)
+		    *dst++ = *src++;
+		XYNORMALIZE(&px, image);
+		_putbits((char *) &pixel, (x % ibu), 1, (char *) &px);
+		XYNORMALIZE(&px, image);
+		src = (char *) &px;
+		dst = &data[XYINDEX(x, y, image)];
+		for (i = nbytes; --i >= 0;)
+		    *dst++ = *src++;
+	    }
+    } else {
+	ibpp = image->bits_per_pixel;
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		pixel = pixels[*iptr];
+		if (depth == 4)
+		    pixel &= 0xf;
+		for (i = 0, px = pixel; i < sizeof(unsigned long); i++,
+		     px >>= 8)
+		    ((unsigned char *) &pixel)[i] = px;
+		src = &data[ZINDEX(x, y, image)];
+		dst = (char *) &px;
+		px = 0;
+		nbytes = (ibpp + 7) >> 3;
+		for (i = nbytes; --i >= 0;)
+		    *dst++ = *src++;
+		ZNORMALIZE(&px, image);
+		_putbits((char *) &pixel, (x * ibpp) & 7, ibpp, (char *) &px);
+		ZNORMALIZE(&px, image);
+		src = (char *) &px;
+		dst = &data[ZINDEX(x, y, image)];
+		for (i = nbytes; --i >= 0;)
+		    *dst++ = *src++;
+	    }
+    }
+}
+
+/*
+ * write pixels into a 32-bits Z image data structure
+ */
+
+#if !defined(WORD64) && !defined(LONG64)
+/* this item is static but deterministic so let it slide; doesn't
+ * hurt re-entrancy of this library. Note if it is actually const then would
+ * be OK under rules of ANSI-C but probably not C++ which may not
+ * want to allocate space for it.
+ */
+static unsigned long byteorderpixel = MSBFirst << 24;
+
+#endif
+
+/*
+   WITHOUT_SPEEDUPS is a flag to be turned on if you wish to use the original
+   3.2e code - by default you get the speeded-up version.
+*/
+
+static void
+PutImagePixels32(image, width, height, pixelindex, pixels)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    unsigned int *pixelindex;
+    Pixel *pixels;
+{
+    unsigned char *data;
+    unsigned int *iptr;
+    int y;
+    Pixel pixel;
+
+#ifdef WITHOUT_SPEEDUPS
+
+    int x;
+    unsigned char *addr;
+
+    data = (unsigned char *) image->data;
+    iptr = pixelindex;
+#if !defined(WORD64) && !defined(LONG64)
+    if (*((char *) &byteorderpixel) == image->byte_order) {
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX32(x, y, image)];
+		*((unsigned long *) addr) = pixels[*iptr];
+	    }
+    } else
+#endif
+    if (image->byte_order == MSBFirst)
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX32(x, y, image)];
+		pixel = pixels[*iptr];
+		addr[0] = pixel >> 24;
+		addr[1] = pixel >> 16;
+		addr[2] = pixel >> 8;
+		addr[3] = pixel;
+	    }
+    else
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX32(x, y, image)];
+		pixel = pixels[*iptr];
+		addr[0] = pixel;
+		addr[1] = pixel >> 8;
+		addr[2] = pixel >> 16;
+		addr[3] = pixel >> 24;
+	    }
+
+#else  /* WITHOUT_SPEEDUPS */
+
+    int bpl = image->bytes_per_line;
+    unsigned char *data_ptr, *max_data;
+
+    data = (unsigned char *) image->data;
+    iptr = pixelindex;
+#if !defined(WORD64) && !defined(LONG64)
+    if (*((char *) &byteorderpixel) == image->byte_order) {
+	for (y = 0; y < height; y++) {
+	    data_ptr = data;
+	    max_data = data_ptr + (width << 2);
+
+	    while (data_ptr < max_data) {
+		*((unsigned long *) data_ptr) = pixels[*(iptr++)];
+		data_ptr += (1 << 2);
+	    }
+	    data += bpl;
+	}
+    } else
+#endif
+    if (image->byte_order == MSBFirst)
+	for (y = 0; y < height; y++) {
+	    data_ptr = data;
+	    max_data = data_ptr + (width << 2);
+
+	    while (data_ptr < max_data) {
+		pixel = pixels[*(iptr++)];
+
+		*data_ptr++ = pixel >> 24;
+		*data_ptr++ = pixel >> 16;
+		*data_ptr++ = pixel >> 8;
+		*data_ptr++ = pixel;
+
+	    }
+	    data += bpl;
+	}
+    else
+	for (y = 0; y < height; y++) {
+	    data_ptr = data;
+	    max_data = data_ptr + (width << 2);
+
+	    while (data_ptr < max_data) {
+		pixel = pixels[*(iptr++)];
+
+		*data_ptr++ = pixel;
+		*data_ptr++ = pixel >> 8;
+		*data_ptr++ = pixel >> 16;
+		*data_ptr++ = pixel >> 24;
+	    }
+	    data += bpl;
+	}
+
+#endif /* WITHOUT_SPEEDUPS */
+}
+
+/*
+ * write pixels into a 16-bits Z image data structure
+ */
+
+static void
+PutImagePixels16(image, width, height, pixelindex, pixels)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    unsigned int *pixelindex;
+    Pixel *pixels;
+{
+    unsigned char *data;
+    unsigned int *iptr;
+    int y;
+
+#ifdef WITHOUT_SPEEDUPS
+
+    int x;
+    unsigned char *addr;
+
+    data = (unsigned char *) image->data;
+    iptr = pixelindex;
+    if (image->byte_order == MSBFirst)
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX16(x, y, image)];
+		addr[0] = pixels[*iptr] >> 8;
+		addr[1] = pixels[*iptr];
+	    }
+    else
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX16(x, y, image)];
+		addr[0] = pixels[*iptr];
+		addr[1] = pixels[*iptr] >> 8;
+	    }
+
+#else  /* WITHOUT_SPEEDUPS */
+
+    Pixel pixel;
+
+    int bpl = image->bytes_per_line;
+    unsigned char *data_ptr, *max_data;
+
+    data = (unsigned char *) image->data;
+    iptr = pixelindex;
+    if (image->byte_order == MSBFirst)
+	for (y = 0; y < height; y++) {
+	    data_ptr = data;
+	    max_data = data_ptr + (width << 1);
+
+	    while (data_ptr < max_data) {
+		pixel = pixels[*(iptr++)];
+
+		data_ptr[0] = pixel >> 8;
+		data_ptr[1] = pixel;
+
+		data_ptr += (1 << 1);
+	    }
+	    data += bpl;
+	}
+    else
+	for (y = 0; y < height; y++) {
+	    data_ptr = data;
+	    max_data = data_ptr + (width << 1);
+
+	    while (data_ptr < max_data) {
+		pixel = pixels[*(iptr++)];
+
+		data_ptr[0] = pixel;
+		data_ptr[1] = pixel >> 8;
+
+		data_ptr += (1 << 1);
+	    }
+	    data += bpl;
+	}
+
+#endif /* WITHOUT_SPEEDUPS */
+}
+
+/*
+ * write pixels into a 8-bits Z image data structure
+ */
+
+static void
+PutImagePixels8(image, width, height, pixelindex, pixels)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    unsigned int *pixelindex;
+    Pixel *pixels;
+{
+    char *data;
+    unsigned int *iptr;
+    int y;
+
+#ifdef WITHOUT_SPEEDUPS
+
+    int x;
+
+    data = image->data;
+    iptr = pixelindex;
+    for (y = 0; y < height; y++)
+	for (x = 0; x < width; x++, iptr++)
+	    data[ZINDEX8(x, y, image)] = pixels[*iptr];
+
+#else  /* WITHOUT_SPEEDUPS */
+
+    int bpl = image->bytes_per_line;
+    char *data_ptr, *max_data;
+
+    data = image->data;
+    iptr = pixelindex;
+
+    for (y = 0; y < height; y++) {
+	data_ptr = data;
+	max_data = data_ptr + width;
+
+	while (data_ptr < max_data)
+	    *(data_ptr++) = pixels[*(iptr++)];
+
+	data += bpl;
+    }
+
+#endif /* WITHOUT_SPEEDUPS */
+}
+
+/*
+ * write pixels into a 1-bit depth image data structure and **offset null**
+ */
+
+static void
+PutImagePixels1(image, width, height, pixelindex, pixels)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    unsigned int *pixelindex;
+    Pixel *pixels;
+{
+    if (image->byte_order != image->bitmap_bit_order)
+	PutImagePixels(image, width, height, pixelindex, pixels);
+    else {
+	unsigned int *iptr;
+	int y;
+	char *data;
+
+#ifdef WITHOUT_SPEEDUPS
+
+	int x;
+
+	data = image->data;
+	iptr = pixelindex;
+	if (image->bitmap_bit_order == MSBFirst)
+	    for (y = 0; y < height; y++)
+		for (x = 0; x < width; x++, iptr++) {
+		    if (pixels[*iptr] & 1)
+			data[ZINDEX1(x, y, image)] |= 0x80 >> (x & 7);
+		    else
+			data[ZINDEX1(x, y, image)] &= ~(0x80 >> (x & 7));
+		}
+	else
+	    for (y = 0; y < height; y++)
+		for (x = 0; x < width; x++, iptr++) {
+		    if (pixels[*iptr] & 1)
+			data[ZINDEX1(x, y, image)] |= 1 << (x & 7);
+		    else
+			data[ZINDEX1(x, y, image)] &= ~(1 << (x & 7));
+		}
+
+#else  /* WITHOUT_SPEEDUPS */
+
+	char value;
+	char *data_ptr, *max_data;
+	int bpl = image->bytes_per_line;
+	int diff, count;
+
+	data = image->data;
+	iptr = pixelindex;
+
+	diff = width & 7;
+	width >>= 3;
+
+	if (image->bitmap_bit_order == MSBFirst)
+	    for (y = 0; y < height; y++) {
+		data_ptr = data;
+		max_data = data_ptr + width;
+		while (data_ptr < max_data) {
+		    value = 0;
+
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+		    value = (value << 1) | (pixels[*(iptr++)] & 1);
+
+		    *(data_ptr++) = value;
+		}
+		if (diff) {
+		    value = 0;
+		    for (count = 0; count < diff; count++) {
+			if (pixels[*(iptr++)] & 1)
+			    value |= (0x80 >> count);
+		    }
+		    *(data_ptr) = value;
+		}
+		data += bpl;
+	    }
+	else
+	    for (y = 0; y < height; y++) {
+		data_ptr = data;
+		max_data = data_ptr + width;
+		while (data_ptr < max_data) {
+		    value = 0;
+		    iptr += 8;
+
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+		    value = (value << 1) | (pixels[*(--iptr)] & 1);
+
+		    iptr += 8;
+		    *(data_ptr++) = value;
+		}
+		if (diff) {
+		    value = 0;
+		    for (count = 0; count < diff; count++) {
+			if (pixels[*(iptr++)] & 1)
+			    value |= (1 << count);
+		    }
+		    *(data_ptr) = value;
+		}
+		data += bpl;
+	    }
+
+#endif /* WITHOUT_SPEEDUPS */
+    }
+}
+
+int
+XpmCreatePixmapFromXpmImage(display, d, image,
+			    pixmap_return, shapemask_return, attributes)
+    Display *display;
+    Drawable d;
+    XpmImage *image;
+    Pixmap *pixmap_return;
+    Pixmap *shapemask_return;
+    XpmAttributes *attributes;
+{
+    XImage *ximage, *shapeimage;
+    int ErrorStatus;
+
+    /* initialize return values */
+    if (pixmap_return)
+	*pixmap_return = 0;
+    if (shapemask_return)
+	*shapemask_return = 0;
+
+    /* create the ximages */
+    ErrorStatus = XpmCreateImageFromXpmImage(display, image,
+					     (pixmap_return ? &ximage : NULL),
+					     (shapemask_return ?
+					      &shapeimage : NULL),
+					     attributes);
+    if (ErrorStatus < 0)
+	return (ErrorStatus);
+
+    /* create the pixmaps and destroy images */
+    if (pixmap_return && ximage) {
+	xpmCreatePixmapFromImage(display, d, ximage, pixmap_return);
+	XDestroyImage(ximage);
+    }
+    if (shapemask_return && shapeimage) {
+	xpmCreatePixmapFromImage(display, d, shapeimage, shapemask_return);
+	XDestroyImage(shapeimage);
+    }
+    return (ErrorStatus);
+}
+
+# else /* AMIGA */
+
+static void
+APutImagePixels (
+    XImage        *image,
+    unsigned int   width,
+    unsigned int   height,
+    unsigned int  *pixelindex,
+    Pixel         *pixels)
+{
+    unsigned int   *data = pixelindex;
+    unsigned int    x, y;
+    unsigned char  *array;
+    XImage         *tmp_img;
+    BOOL            success = FALSE;
+    
+    array = XpmMalloc ((((width+15)>>4)<<4)*sizeof (*array));
+    if (array != NULL)
+    {
+	tmp_img = AllocXImage ((((width+15)>>4)<<4), 1,
+			       image->rp->BitMap->Depth);
+	if (tmp_img != NULL)
+	{
+	    for (y = 0; y < height; ++y)
+	    {
+		for (x = 0; x < width; ++x)
+		    array[x] = pixels[*(data++)];
+		WritePixelLine8 (image->rp, 0, y, width, array, tmp_img->rp);
+	    }
+	    FreeXImage (tmp_img);
+	    success = TRUE;
+	}
+	XpmFree (array);
+    }
+    
+    if (!success)
+    {
+	for (y = 0; y < height; ++y)
+	    for (x = 0; x < width; ++x)
+		XPutPixel (image, x, y, pixels[*(data++)]);
+    }
+}
+
+# endif/* AMIGA */
+#else  /* FOR_MSW part follows */
+static void
+MSWPutImagePixels(dc, image, width, height, pixelindex, pixels)
+    Display *dc;
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    unsigned int *pixelindex;
+    Pixel *pixels;
+{
+    unsigned int *data = pixelindex;
+    unsigned int x, y;
+    HBITMAP obm;
+
+    obm = SelectObject(*dc, image->bitmap);
+    for (y = 0; y < height; y++) {
+	for (x = 0; x < width; x++) {
+	    SetPixel(*dc, x, y, pixels[*(data++)]); /* data is [x+y*width] */
+	}
+    }
+    SelectObject(*dc, obm);
+}
+
+#endif /* FOR_MSW */
+
+
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+
+static int
+PutPixel1(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    register char *src;
+    register char *dst;
+    register int i;
+    register char *data;
+    Pixel px;
+    int nbytes;
+
+    for (i=0, px=pixel; i<sizeof(unsigned long); i++, px>>=8)
+	((unsigned char *)&pixel)[i] = px;
+    src = &ximage->data[XYINDEX(x, y, ximage)];
+    dst = (char *)&px;
+    px = 0;
+    nbytes = ximage->bitmap_unit >> 3;
+    for (i = nbytes; --i >= 0; ) *dst++ = *src++;
+    XYNORMALIZE(&px, ximage);
+    i = ((x + ximage->xoffset) % ximage->bitmap_unit);
+    _putbits ((char *)&pixel, i, 1, (char *)&px);
+    XYNORMALIZE(&px, ximage);
+    src = (char *) &px;
+    dst = &ximage->data[XYINDEX(x, y, ximage)];
+    for (i = nbytes; --i >= 0; )
+	*dst++ = *src++;
+
+    return 1;
+}
+
+static int
+PutPixel(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    register char *src;
+    register char *dst;
+    register int i;
+    register char *data;
+    Pixel px;
+    int nbytes, ibpp;
+
+    ibpp = ximage->bits_per_pixel;
+    if (ximage->depth == 4)
+	pixel &= 0xf;
+    for (i = 0, px = pixel; i < sizeof(unsigned long); i++, px >>= 8)
+	((unsigned char *) &pixel)[i] = px;
+    src = &ximage->data[ZINDEX(x, y, ximage)];
+    dst = (char *) &px;
+    px = 0;
+    nbytes = (ibpp + 7) >> 3;
+    for (i = nbytes; --i >= 0;)
+	*dst++ = *src++;
+    ZNORMALIZE(&px, ximage);
+    _putbits((char *) &pixel, (x * ibpp) & 7, ibpp, (char *) &px);
+    ZNORMALIZE(&px, ximage);
+    src = (char *) &px;
+    dst = &ximage->data[ZINDEX(x, y, ximage)];
+    for (i = nbytes; --i >= 0;)
+	*dst++ = *src++;
+
+    return 1;
+}
+
+static int
+PutPixel32(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    unsigned char *addr;
+
+    addr = &((unsigned char *)ximage->data) [ZINDEX32(x, y, ximage)];
+    *((unsigned long *)addr) = pixel;
+    return 1;
+}
+
+static int
+PutPixel32MSB(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    unsigned char *addr;
+
+    addr = &((unsigned char *)ximage->data) [ZINDEX32(x, y, ximage)];
+    addr[0] = pixel >> 24;
+    addr[1] = pixel >> 16;
+    addr[2] = pixel >> 8;
+    addr[3] = pixel;
+    return 1;
+}
+
+static int
+PutPixel32LSB(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    unsigned char *addr;
+
+    addr = &((unsigned char *)ximage->data) [ZINDEX32(x, y, ximage)];
+    addr[3] = pixel >> 24;
+    addr[2] = pixel >> 16;
+    addr[1] = pixel >> 8;
+    addr[0] = pixel;
+    return 1;
+}
+
+static int
+PutPixel16MSB(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    unsigned char *addr;
+    
+    addr = &((unsigned char *)ximage->data) [ZINDEX16(x, y, ximage)];
+    addr[0] = pixel >> 8;
+    addr[1] = pixel;
+    return 1;
+}
+
+static int
+PutPixel16LSB(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    unsigned char *addr;
+    
+    addr = &((unsigned char *)ximage->data) [ZINDEX16(x, y, ximage)];
+    addr[1] = pixel >> 8;
+    addr[0] = pixel;
+    return 1;
+}
+
+static int
+PutPixel8(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    ximage->data[ZINDEX8(x, y, ximage)] = pixel;
+    return 1;
+}
+
+static int
+PutPixel1MSB(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    if (pixel & 1)
+	ximage->data[ZINDEX1(x, y, ximage)] |= 0x80 >> (x & 7);
+    else
+	ximage->data[ZINDEX1(x, y, ximage)] &= ~(0x80 >> (x & 7));
+    return 1;
+}
+
+static int
+PutPixel1LSB(ximage, x, y, pixel)
+    register XImage *ximage;
+    int x;
+    int y;
+    unsigned long pixel;
+{
+    if (pixel & 1)
+	ximage->data[ZINDEX1(x, y, ximage)] |= 1 << (x & 7);
+    else
+	ximage->data[ZINDEX1(x, y, ximage)] &= ~(1 << (x & 7));
+    return 1;
+}
+
+#endif /* not FOR_MSW && not AMIGA */
+
+/*
+ * This function parses an Xpm file or data and directly create an XImage
+ */
+int
+xpmParseDataAndCreate(display, data, image_return, shapeimage_return,
+		      image, info, attributes)
+    Display *display;
+    xpmData *data;
+    XImage **image_return;
+    XImage **shapeimage_return;
+    XpmImage *image;
+    XpmInfo *info;
+    XpmAttributes *attributes;
+{
+    /* variables stored in the XpmAttributes structure */
+    Visual *visual;
+    Colormap colormap;
+    unsigned int depth;
+    int bitmap_format;
+    XpmFreeColorsFunc freeColors;
+    void *closure;
+
+    /* variables to return */
+    XImage *ximage = NULL;
+    XImage *shapeimage = NULL;
+    unsigned int mask_pixel_index = XpmUndefPixel;
+
+    /* calculation variables */
+    Pixel *image_pixels = NULL;
+    Pixel *mask_pixels = NULL;
+    Pixel *alloc_pixels = NULL;
+    Pixel *used_pixels = NULL;
+    unsigned int nalloc_pixels = 0;
+    unsigned int nused_pixels = 0;
+    unsigned int width, height, ncolors, cpp;
+    unsigned int x_hotspot, y_hotspot, hotspot = 0, extensions = 0;
+    XpmColor *colorTable = NULL;
+    char *hints_cmt = NULL;
+    char *colors_cmt = NULL;
+    char *pixels_cmt = NULL;
+
+    unsigned int cmts;
+    int ErrorStatus;
+    xpmHashTable hashtable;
+
+
+    /* initialize return values */
+    if (image_return)
+	*image_return = NULL;
+    if (shapeimage_return)
+	*shapeimage_return = NULL;
+
+
+    /* retrieve information from the XpmAttributes */
+    if (attributes && (attributes->valuemask & XpmVisual))
+	visual = attributes->visual;
+    else
+	visual = XDefaultVisual(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmColormap))
+	colormap = attributes->colormap;
+    else
+	colormap = XDefaultColormap(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmDepth))
+	depth = attributes->depth;
+    else
+	depth = XDefaultDepth(display, XDefaultScreen(display));
+
+    if (attributes && (attributes->valuemask & XpmBitmapFormat))
+	bitmap_format = attributes->bitmap_format;
+    else
+	bitmap_format = ZPixmap;
+
+    if (attributes && (attributes->valuemask & XpmFreeColors))
+	freeColors = attributes->free_colors;
+    else
+	freeColors = FreeColors;
+    if (attributes && (attributes->valuemask & XpmColorClosure))
+	closure = attributes->color_closure;
+    else
+	closure = NULL;
+
+    cmts = info && (info->valuemask & XpmReturnComments);
+
+    /*
+     * parse the header
+     */
+    ErrorStatus = xpmParseHeader(data);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /*
+     * read values
+     */
+    ErrorStatus = xpmParseValues(data, &width, &height, &ncolors, &cpp,
+				 &x_hotspot, &y_hotspot, &hotspot,
+				 &extensions);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /*
+     * store the hints comment line
+     */
+    if (cmts)
+	xpmGetCmt(data, &hints_cmt);
+
+    /*
+     * init the hastable
+     */
+    if (USE_HASHTABLE) {
+	ErrorStatus = xpmHashTableInit(&hashtable);
+	if (ErrorStatus != XpmSuccess)
+	    return (ErrorStatus);
+    }
+
+    /*
+     * read colors
+     */
+    ErrorStatus = xpmParseColors(data, ncolors, cpp, &colorTable, &hashtable);
+    if (ErrorStatus != XpmSuccess)
+	RETURN(ErrorStatus);
+
+    /*
+     * store the colors comment line
+     */
+    if (cmts)
+	xpmGetCmt(data, &colors_cmt);
+
+    /* malloc pixels index tables */
+    image_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * ncolors);
+    if (!image_pixels)
+	RETURN(XpmNoMemory);
+
+    mask_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * ncolors);
+    if (!mask_pixels)
+	RETURN(XpmNoMemory);
+
+    /* maximum of allocated pixels will be the number of colors */
+    alloc_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * ncolors);
+    if (!alloc_pixels)
+	RETURN(XpmNoMemory);
+
+    /* maximum of allocated pixels will be the number of colors */
+    used_pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * ncolors);
+    if (!used_pixels)
+	RETURN(XpmNoMemory);
+
+    /* get pixel colors, store them in index tables */
+    ErrorStatus = CreateColors(display, attributes, colorTable, ncolors,
+			       image_pixels, mask_pixels, &mask_pixel_index,
+			       alloc_pixels, &nalloc_pixels, used_pixels,
+			       &nused_pixels);
+
+    if (ErrorStatus != XpmSuccess
+	&& (ErrorStatus < 0 || (attributes
+				&& (attributes->valuemask & XpmExactColors)
+				&& attributes->exactColors)))
+	RETURN(ErrorStatus);
+
+    /* now create the ximage */
+    if (image_return) {
+	ErrorStatus = CreateXImage(display, visual, depth,
+				   (depth == 1 ? bitmap_format : ZPixmap),
+				   width, height, &ximage);
+	if (ErrorStatus != XpmSuccess)
+	    RETURN(ErrorStatus);
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+
+	/*
+	 * set the XImage pointer function, to be used with XPutPixel,
+	 * to an internal optimized function
+	 */
+
+	if (ximage->bits_per_pixel == 8)
+	    ximage->f.put_pixel = PutPixel8;
+	else if (((ximage->bits_per_pixel | ximage->depth) == 1) &&
+		 (ximage->byte_order == ximage->bitmap_bit_order))
+	    if (ximage->bitmap_bit_order == MSBFirst)
+		ximage->f.put_pixel = PutPixel1MSB;
+	    else
+		ximage->f.put_pixel = PutPixel1LSB;
+	else if (ximage->bits_per_pixel == 16)
+	    if (ximage->bitmap_bit_order == MSBFirst)
+		ximage->f.put_pixel = PutPixel16MSB;
+	    else
+		ximage->f.put_pixel = PutPixel16LSB;
+	else if (ximage->bits_per_pixel == 32)
+#if !defined(WORD64) && !defined(LONG64)
+	    if (*((char *)&byteorderpixel) == ximage->byte_order)
+		ximage->f.put_pixel = PutPixel32;
+	    else
+#endif
+		if (ximage->bitmap_bit_order == MSBFirst)
+		    ximage->f.put_pixel = PutPixel32MSB;
+		else
+		    ximage->f.put_pixel = PutPixel32LSB;
+	else if ((ximage->bits_per_pixel | ximage->depth) == 1)
+	    ximage->f.put_pixel = PutPixel1;
+	else
+	    ximage->f.put_pixel = PutPixel;
+#endif /* not FOR_MSW && not AMIGA */
+    }
+
+    /* create the shape mask image */
+    if (mask_pixel_index != XpmUndefPixel && shapeimage_return) {
+	ErrorStatus = CreateXImage(display, visual, 1, bitmap_format,
+				   width, height, &shapeimage);
+	if (ErrorStatus != XpmSuccess)
+	    RETURN(ErrorStatus);
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+	if (shapeimage->bitmap_bit_order == MSBFirst)
+	    shapeimage->f.put_pixel = PutPixel1MSB;
+	else
+	    shapeimage->f.put_pixel = PutPixel1LSB;
+#endif
+    }
+
+    /*
+     * read pixels and put them in the XImage
+     */
+    ErrorStatus = ParseAndPutPixels(
+#ifdef FOR_MSW
+				    display,
+#endif
+				    data, width, height, ncolors, cpp,
+				    colorTable, &hashtable,
+				    ximage, image_pixels,
+				    shapeimage, mask_pixels);
+    XpmFree(image_pixels);
+    image_pixels = NULL;
+    XpmFree(mask_pixels);
+    mask_pixels = NULL;
+
+    /*
+     * free the hastable
+     */
+    if (ErrorStatus != XpmSuccess)
+	RETURN(ErrorStatus)
+    else if (USE_HASHTABLE)
+	xpmHashTableFree(&hashtable);
+
+    /*
+     * store the pixels comment line
+     */
+    if (cmts)
+	xpmGetCmt(data, &pixels_cmt);
+
+    /*
+     * parse extensions
+     */
+    if (info && (info->valuemask & XpmReturnExtensions))
+	if (extensions) {
+	    ErrorStatus = xpmParseExtensions(data, &info->extensions,
+					     &info->nextensions);
+	    if (ErrorStatus != XpmSuccess)
+		RETURN(ErrorStatus);
+	} else {
+	    info->extensions = NULL;
+	    info->nextensions = 0;
+	}
+
+    /*
+     * store found informations in the XpmImage structure
+     */
+    image->width = width;
+    image->height = height;
+    image->cpp = cpp;
+    image->ncolors = ncolors;
+    image->colorTable = colorTable;
+    image->data = NULL;
+
+    if (info) {
+	if (cmts) {
+	    info->hints_cmt = hints_cmt;
+	    info->colors_cmt = colors_cmt;
+	    info->pixels_cmt = pixels_cmt;
+	}
+	if (hotspot) {
+	    info->x_hotspot = x_hotspot;
+	    info->y_hotspot = y_hotspot;
+	    info->valuemask |= XpmHotspot;
+	}
+    }
+    /* if requested return used pixels in the XpmAttributes structure */
+    if (attributes && (attributes->valuemask & XpmReturnPixels ||
+/* 3.2 backward compatibility code */
+	attributes->valuemask & XpmReturnInfos)) {
+/* end 3.2 bc */
+	attributes->pixels = used_pixels;
+	attributes->npixels = nused_pixels;
+	attributes->mask_pixel = mask_pixel_index;
+    } else
+	XpmFree(used_pixels);
+
+    /* if requested return alloc'ed pixels in the XpmAttributes structure */
+    if (attributes && (attributes->valuemask & XpmReturnAllocPixels)) {
+	attributes->alloc_pixels = alloc_pixels;
+	attributes->nalloc_pixels = nalloc_pixels;
+    } else
+	XpmFree(alloc_pixels);
+
+    /* return created images */
+    if (image_return)
+	*image_return = ximage;
+    if (shapeimage_return)
+	*shapeimage_return = shapeimage;
+
+    return (XpmSuccess);
+
+/* exit point in case of error, free only locally allocated variables */
+error:
+    if (USE_HASHTABLE)
+	xpmHashTableFree(&hashtable);
+    if (colorTable)
+	xpmFreeColorTable(colorTable, ncolors);
+    if (hints_cmt)
+	XpmFree(hints_cmt);
+    if (colors_cmt)
+	XpmFree(colors_cmt);
+    if (pixels_cmt)
+	XpmFree(pixels_cmt);
+    if (ximage)
+	XDestroyImage(ximage);
+    if (shapeimage)
+	XDestroyImage(shapeimage);
+    if (image_pixels)
+	XpmFree(image_pixels);
+    if (mask_pixels)
+	XpmFree(mask_pixels);
+    if (nalloc_pixels)
+	(*freeColors)(display, colormap, alloc_pixels, nalloc_pixels, NULL);
+    if (alloc_pixels)
+	XpmFree(alloc_pixels);
+    if (used_pixels)
+	XpmFree(used_pixels);
+
+    return (ErrorStatus);
+}
+
+static int
+ParseAndPutPixels(
+#ifdef FOR_MSW
+		  dc,
+#endif
+		  data, width, height, ncolors, cpp, colorTable, hashtable,
+		  image, image_pixels, shapeimage, shape_pixels)
+#ifdef FOR_MSW
+    Display *dc;
+#endif
+    xpmData *data;
+    unsigned int width;
+    unsigned int height;
+    unsigned int ncolors;
+    unsigned int cpp;
+    XpmColor *colorTable;
+    xpmHashTable *hashtable;
+    XImage *image;
+    Pixel *image_pixels;
+    XImage *shapeimage;
+    Pixel *shape_pixels;
+{
+    unsigned int a, x, y;
+
+    switch (cpp) {
+
+    case (1):				/* Optimize for single character
+					 * colors */
+	{
+	    unsigned short colidx[256];
+#ifdef FOR_MSW
+	    HDC shapedc;
+	    HBITMAP obm, sobm;
+
+	    if ( shapeimage ) {
+		shapedc = CreateCompatibleDC(*dc);
+		sobm = SelectObject(shapedc, shapeimage->bitmap);
+	    } else {
+	        shapedc = NULL;
+	    }
+	    obm = SelectObject(*dc, image->bitmap);
+#endif
+
+
+	    bzero((char *)colidx, 256 * sizeof(short));
+	    for (a = 0; a < ncolors; a++)
+		colidx[(unsigned char)colorTable[a].string[0]] = a + 1;
+
+	    for (y = 0; y < height; y++) {
+		xpmNextString(data);
+		for (x = 0; x < width; x++) {
+		    int c = xpmGetC(data);
+
+		    if (c > 0 && c < 256 && colidx[c] != 0) {
+#ifndef FOR_MSW
+			XPutPixel(image, x, y, image_pixels[colidx[c] - 1]);
+			if (shapeimage)
+			    XPutPixel(shapeimage, x, y,
+				      shape_pixels[colidx[c] - 1]);
+#else
+			SetPixel(*dc, x, y, image_pixels[colidx[c] - 1]);
+			if (shapedc) {
+			    SetPixel(shapedc, x, y, shape_pixels[colidx[c] - 1]);
+			}
+#endif
+		    } else
+			return (XpmFileInvalid);
+		}
+	    }
+#ifdef FOR_MSW
+	    if ( shapedc ) {
+	        SelectObject(shapedc, sobm);
+		DeleteDC(shapedc);
+	    }
+	    SelectObject(*dc, obm);
+#endif
+	}
+	break;
+
+    case (2):				/* Optimize for double character
+					 * colors */
+	{
+
+/* free all allocated pointers at all exits */
+#define FREE_CIDX {int f; for (f = 0; f < 256; f++) \
+if (cidx[f]) XpmFree(cidx[f]);}
+
+	    /* array of pointers malloced by need */
+	    unsigned short *cidx[256];
+	    int char1;
+
+	    bzero((char *)cidx, 256 * sizeof(unsigned short *)); /* init */
+	    for (a = 0; a < ncolors; a++) {
+		char1 = colorTable[a].string[0];
+		if (cidx[char1] == NULL) { /* get new memory */
+		    cidx[char1] = (unsigned short *)
+			XpmCalloc(256, sizeof(unsigned short));
+		    if (cidx[char1] == NULL) { /* new block failed */
+			FREE_CIDX;
+			return (XpmNoMemory);
+		    }
+		}
+		cidx[char1][(unsigned char)colorTable[a].string[1]] = a + 1;
+	    }
+
+	    for (y = 0; y < height; y++) {
+		xpmNextString(data);
+		for (x = 0; x < width; x++) {
+		    int cc1 = xpmGetC(data);
+		    if (cc1 > 0 && cc1 < 256) {
+			int cc2 = xpmGetC(data);
+			if (cc2 > 0 && cc2 < 256 &&
+			    cidx[cc1] && cidx[cc1][cc2] != 0) {
+#ifndef FOR_MSW
+			    XPutPixel(image, x, y,
+				      image_pixels[cidx[cc1][cc2] - 1]);
+			    if (shapeimage)
+				XPutPixel(shapeimage, x, y,
+					  shape_pixels[cidx[cc1][cc2] - 1]);
+#else
+			SelectObject(*dc, image->bitmap);
+			SetPixel(*dc, x, y, image_pixels[cidx[cc1][cc2] - 1]);
+			if (shapeimage) {
+			    SelectObject(*dc, shapeimage->bitmap);
+			    SetPixel(*dc, x, y,
+				     shape_pixels[cidx[cc1][cc2] - 1]);
+			}
+#endif
+			} else {
+			    FREE_CIDX;
+			    return (XpmFileInvalid);
+			}
+		    } else {
+			FREE_CIDX;
+			return (XpmFileInvalid);
+		    }
+		}
+	    }
+	    FREE_CIDX;
+	}
+	break;
+
+    default:				/* Non-optimized case of long color
+					 * names */
+	{
+	    char *s;
+	    char buf[BUFSIZ];
+
+	    buf[cpp] = '\0';
+	    if (USE_HASHTABLE) {
+		xpmHashAtom *slot;
+
+		for (y = 0; y < height; y++) {
+		    xpmNextString(data);
+		    for (x = 0; x < width; x++) {
+			for (a = 0, s = buf; a < cpp; a++, s++)
+			    *s = xpmGetC(data);
+			slot = xpmHashSlot(hashtable, buf);
+			if (!*slot)	/* no color matches */
+			    return (XpmFileInvalid);
+#ifndef FOR_MSW
+			XPutPixel(image, x, y,
+				  image_pixels[HashColorIndex(slot)]);
+			if (shapeimage)
+			    XPutPixel(shapeimage, x, y,
+				      shape_pixels[HashColorIndex(slot)]);
+#else
+			SelectObject(*dc, image->bitmap);
+			SetPixel(*dc, x, y,
+				 image_pixels[HashColorIndex(slot)]);
+			if (shapeimage) {
+			    SelectObject(*dc, shapeimage->bitmap);
+			    SetPixel(*dc, x, y,
+				     shape_pixels[HashColorIndex(slot)]);
+			}
+#endif
+		    }
+		}
+	    } else {
+		for (y = 0; y < height; y++) {
+		    xpmNextString(data);
+		    for (x = 0; x < width; x++) {
+			for (a = 0, s = buf; a < cpp; a++, s++)
+			    *s = xpmGetC(data);
+			for (a = 0; a < ncolors; a++)
+			    if (!strcmp(colorTable[a].string, buf))
+				break;
+			if (a == ncolors)	/* no color matches */
+			    return (XpmFileInvalid);
+#ifndef FOR_MSW
+			XPutPixel(image, x, y, image_pixels[a]);
+			if (shapeimage)
+			    XPutPixel(shapeimage, x, y, shape_pixels[a]);
+#else
+			SelectObject(*dc, image->bitmap);
+			SetPixel(*dc, x, y, image_pixels[a]);
+			if (shapeimage) {
+			    SelectObject(*dc, shapeimage->bitmap);
+			    SetPixel(*dc, x, y, shape_pixels[a]);
+			}
+#endif
+		    }
+		}
+	    }
+	}
+	break;
+    }
+    return (XpmSuccess);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/data.c rxvt-2.7.2/W11/xpm-3.4k/lib/data.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/data.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/data.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,479 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* data.c:                                                                     *
+*                                                                             *
+*  XPM library                                                                *
+*  IO utilities                                                               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#ifndef CXPMPROG
+/* Official version number */
+static char *RCS_Version = "$XpmVersion: 3.4k $";
+
+/* Internal version number */
+static char *RCS_Id = "$Id: rxvt-2.7.2-6.patch,v 1.1 2002/12/06 23:08:00 earnie Exp $";
+
+#include "XpmI.h"
+#endif
+#include <ctype.h>
+
+#ifndef CXPMPROG
+#define Getc(data, file) getc(file)
+#define Ungetc(data, c, file) ungetc(c, file)
+#endif
+
+static int
+ParseComment(data)
+    xpmData *data;
+{
+    if (data->type == XPMBUFFER) {
+	register char c;
+	register unsigned int n = 0;
+	unsigned int notend;
+	char *s, *s2;
+
+	s = data->Comment;
+	*s = data->Bcmt[0];
+
+	/* skip the string beginning comment */
+	s2 = data->Bcmt;
+	do {
+	    c = *data->cptr++;
+	    *++s = c;
+	    n++;
+	    s2++;
+	} while (c == *s2 && *s2 != '\0' && c);
+
+	if (*s2 != '\0') {
+	    /* this wasn't the beginning of a comment */
+	    data->cptr -= n;
+	    return 0;
+	}
+	/* store comment */
+	data->Comment[0] = *s;
+	s = data->Comment;
+	notend = 1;
+	n = 0;
+	while (notend) {
+	    s2 = data->Ecmt;
+	    while (*s != *s2 && c) {
+		c = *data->cptr++;
+		if (n == XPMMAXCMTLEN - 1)  { /* forget it */
+		    s = data->Comment;
+		    n = 0;
+		}
+		*++s = c;
+		n++;
+	    }
+	    data->CommentLength = n;
+	    do {
+		c = *data->cptr++;
+		if (n == XPMMAXCMTLEN - 1)  { /* forget it */
+		    s = data->Comment;
+		    n = 0;
+		}
+		*++s = c;
+		n++;
+		s2++;
+	    } while (c == *s2 && *s2 != '\0' && c);
+	    if (*s2 == '\0') {
+		/* this is the end of the comment */
+		notend = 0;
+		data->cptr--;
+	    }
+	}
+	return 0;
+    } else {
+	FILE *file = data->stream.file;
+	register int c;
+	register unsigned int n = 0, a;
+	unsigned int notend;
+	char *s, *s2;
+
+	s = data->Comment;
+	*s = data->Bcmt[0];
+
+	/* skip the string beginning comment */
+	s2 = data->Bcmt;
+	do {
+	    c = Getc(data, file);
+	    *++s = c;
+	    n++;
+	    s2++;
+	} while (c == *s2 && *s2 != '\0' && c != EOF);
+
+	if (*s2 != '\0') {
+	    /* this wasn't the beginning of a comment */
+	    /* put characters back in the order that we got them */
+	    for (a = n; a > 0; a--, s--)
+		Ungetc(data, *s, file);
+	    return 0;
+	}
+	/* store comment */
+	data->Comment[0] = *s;
+	s = data->Comment;
+	notend = 1;
+	n = 0;
+	while (notend) {
+	    s2 = data->Ecmt;
+	    while (*s != *s2 && c != EOF) {
+		c = Getc(data, file);
+		if (n == XPMMAXCMTLEN - 1)  { /* forget it */
+		    s = data->Comment;
+		    n = 0;
+		}
+		*++s = c;
+		n++;
+	    }
+	    data->CommentLength = n;
+	    do {
+		c = Getc(data, file);
+		if (n == XPMMAXCMTLEN - 1)  { /* forget it */
+		    s = data->Comment;
+		    n = 0;
+		}
+		*++s = c;
+		n++;
+		s2++;
+	    } while (c == *s2 && *s2 != '\0' && c != EOF);
+	    if (*s2 == '\0') {
+		/* this is the end of the comment */
+		notend = 0;
+		Ungetc(data, *s, file);
+	    }
+	}
+	return 0;
+    }
+}
+
+/*
+ * skip to the end of the current string and the beginning of the next one
+ */
+int
+xpmNextString(data)
+    xpmData *data;
+{
+    if (!data->type)
+	data->cptr = (data->stream.data)[++data->line];
+    else if (data->type == XPMBUFFER) {
+	register char c;
+
+	/* get to the end of the current string */
+	if (data->Eos)
+	    while ((c = *data->cptr++) && c != data->Eos);
+
+	/*
+	 * then get to the beginning of the next string looking for possible
+	 * comment
+	 */
+	if (data->Bos) {
+	    while ((c = *data->cptr++) && c != data->Bos)
+		if (data->Bcmt && c == data->Bcmt[0])
+		    ParseComment(data);
+	} else if (data->Bcmt) {	/* XPM2 natural */
+	    while ((c = *data->cptr++) == data->Bcmt[0])
+		ParseComment(data);
+	    data->cptr--;
+	}
+    } else {
+	register int c;
+	FILE *file = data->stream.file;
+
+	/* get to the end of the current string */
+	if (data->Eos)
+	    while ((c = Getc(data, file)) != data->Eos && c != EOF);
+
+	/*
+	 * then get to the beginning of the next string looking for possible
+	 * comment
+	 */
+	if (data->Bos) {
+	    while ((c = Getc(data, file)) != data->Bos && c != EOF)
+		if (data->Bcmt && c == data->Bcmt[0])
+		    ParseComment(data);
+
+	} else if (data->Bcmt) {	/* XPM2 natural */
+	    while ((c = Getc(data, file)) == data->Bcmt[0])
+		ParseComment(data);
+	    Ungetc(data, c, file);
+	}
+    }
+    return 0;
+}
+
+
+/*
+ * skip whitespace and return the following word
+ */
+unsigned int
+xpmNextWord(data, buf, buflen)
+    xpmData *data;
+    char *buf;
+    unsigned int buflen;
+{
+    register unsigned int n = 0;
+    int c;
+
+    if (!data->type || data->type == XPMBUFFER) {
+	while (isspace(c = *data->cptr) && c != data->Eos)
+	    data->cptr++;
+	do {
+	    c = *data->cptr++;
+	    *buf++ = c;
+	    n++;
+	} while (!isspace(c) && c != data->Eos && n < buflen);
+	n--;
+	data->cptr--;
+    } else {
+	FILE *file = data->stream.file;
+
+	while ((c = Getc(data, file)) != EOF && isspace(c) && c != data->Eos);
+	while (!isspace(c) && c != data->Eos && c != EOF && n < buflen) {
+	    *buf++ = c;
+	    n++;
+	    c = Getc(data, file);
+	}
+	Ungetc(data, c, file);
+    }
+    return (n);
+}
+
+/*
+ * skip whitespace and compute the following unsigned int,
+ * returns 1 if one is found and 0 if not
+ */
+int
+xpmNextUI(data, ui_return)
+    xpmData *data;
+    unsigned int *ui_return;
+{
+    char buf[BUFSIZ];
+    int l;
+
+    l = xpmNextWord(data, buf, BUFSIZ);
+    return xpmatoui(buf, l, ui_return);
+}
+
+/*
+ * return end of string - WARNING: malloc!
+ */
+int
+xpmGetString(data, sptr, l)
+    xpmData *data;
+    char **sptr;
+    unsigned int *l;
+{
+    unsigned int i, n = 0;
+    int c;
+    char *p = NULL, *q, buf[BUFSIZ];
+
+    if (!data->type || data->type == XPMBUFFER) {
+	if (data->cptr) {
+	    char *start = data->cptr;
+	    while ((c = *data->cptr) && c != data->Eos)
+		data->cptr++;
+	    n = data->cptr - start + 1;
+	    p = (char *) XpmMalloc(n);
+	    if (!p)
+		return (XpmNoMemory);
+	    strncpy(p, start, n);
+	    if (data->type)		/* XPMBUFFER */
+		p[n - 1] = '\0';
+	}
+    } else {
+	FILE *file = data->stream.file;
+
+	if ((c = Getc(data, file)) == EOF)
+	    return (XpmFileInvalid);
+
+	i = 0;
+	q = buf;
+	p = (char *) XpmMalloc(1);
+	while (c != data->Eos && c != EOF) {
+	    if (i == BUFSIZ) {
+		/* get to the end of the buffer */
+		/* malloc needed memory */
+		q = (char *) XpmRealloc(p, n + i);
+		if (!q) {
+		    XpmFree(p);
+		    return (XpmNoMemory);
+		}
+		p = q;
+		q += n;
+		/* and copy what we already have */
+		strncpy(q, buf, i);
+		n += i;
+		i = 0;
+		q = buf;
+	    }
+	    *q++ = c;
+	    i++;
+	    c = Getc(data, file);
+	}
+	if (c == EOF) {
+	    XpmFree(p);
+	    return (XpmFileInvalid);
+	}
+	if (n + i != 0) {
+	    /* malloc needed memory */
+	    q = (char *) XpmRealloc(p, n + i + 1);
+	    if (!q) {
+		XpmFree(p);
+		return (XpmNoMemory);
+	    }
+	    p = q;
+	    q += n;
+	    /* and copy the buffer */
+	    strncpy(q, buf, i);
+	    n += i;
+	    p[n++] = '\0';
+	} else {
+	    *p = '\0';
+	    n = 1;
+	}
+	Ungetc(data, c, file);
+    }
+    *sptr = p;
+    *l = n;
+    return (XpmSuccess);
+}
+
+/*
+ * get the current comment line
+ */
+int
+xpmGetCmt(data, cmt)
+    xpmData *data;
+    char **cmt;
+{
+    if (!data->type)
+	*cmt = NULL;
+    else if (data->CommentLength) {
+	*cmt = (char *) XpmMalloc(data->CommentLength + 1);
+	strncpy(*cmt, data->Comment, data->CommentLength);
+	(*cmt)[data->CommentLength] = '\0';
+	data->CommentLength = 0;
+    } else
+	*cmt = NULL;
+    return 0;
+}
+
+xpmDataType xpmDataTypes[] =
+{
+    "", "!", "\n", '\0', '\n', "", "", "", "",	/* Natural type */
+    "C", "/*", "*/", '"', '"', ",\n", "static char *", "[] = {\n", "};\n",
+    "Lisp", ";", "\n", '"', '"', "\n", "(setq ", " '(\n", "))\n",
+#ifdef VMS
+    NULL
+#else
+    NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, NULL
+#endif
+};
+
+/*
+ * parse xpm header
+ */
+int
+xpmParseHeader(data)
+    xpmData *data;
+{
+    char buf[BUFSIZ];
+    int l, n = 0;
+
+    if (data->type) {
+	data->Bos = '\0';
+	data->Eos = '\n';
+	data->Bcmt = data->Ecmt = NULL;
+	l = xpmNextWord(data, buf, BUFSIZ);
+	if (l == 7 && !strncmp("#define", buf, 7)) {
+	    /* this maybe an XPM 1 file */
+	    char *ptr;
+
+	    l = xpmNextWord(data, buf, BUFSIZ);
+	    if (!l)
+		return (XpmFileInvalid);
+	    buf[l] = '\0';
+	    ptr = rindex(buf, '_');
+	    if (!ptr || strncmp("_format", ptr, l - (ptr - buf)))
+		return XpmFileInvalid;
+	    /* this is definitely an XPM 1 file */
+	    data->format = 1;
+	    n = 1;			/* handle XPM1 as mainly XPM2 C */
+	} else {
+
+	    /*
+	     * skip the first word, get the second one, and see if this is
+	     * XPM 2 or 3
+	     */
+	    l = xpmNextWord(data, buf, BUFSIZ);
+	    if ((l == 3 && !strncmp("XPM", buf, 3)) ||
+		(l == 4 && !strncmp("XPM2", buf, 4))) {
+		if (l == 3)
+		    n = 1;		/* handle XPM as XPM2 C */
+		else {
+		    /* get the type key word */
+		    l = xpmNextWord(data, buf, BUFSIZ);
+
+		    /*
+		     * get infos about this type
+		     */
+		    while (xpmDataTypes[n].type
+			   && strncmp(xpmDataTypes[n].type, buf, l))
+			n++;
+		}
+		data->format = 0;
+	    } else
+		/* nope this is not an XPM file */
+		return XpmFileInvalid;
+	}
+	if (xpmDataTypes[n].type) {
+	    if (n == 0) {		/* natural type */
+		data->Bcmt = xpmDataTypes[n].Bcmt;
+		data->Ecmt = xpmDataTypes[n].Ecmt;
+		xpmNextString(data);	/* skip the end of the headerline */
+		data->Bos = xpmDataTypes[n].Bos;
+		data->Eos = xpmDataTypes[n].Eos;
+	    } else {
+		data->Bcmt = xpmDataTypes[n].Bcmt;
+		data->Ecmt = xpmDataTypes[n].Ecmt;
+		if (!data->format) {	/* XPM 2 or 3 */
+		    data->Bos = xpmDataTypes[n].Bos;
+		    data->Eos = '\0';
+		    /* get to the beginning of the first string */
+		    xpmNextString(data);
+		    data->Eos = xpmDataTypes[n].Eos;
+		} else			/* XPM 1 skip end of line */
+		    xpmNextString(data);
+	    }
+	} else
+	    /* we don't know about that type of XPM file... */
+	    return XpmFileInvalid;
+    }
+    return XpmSuccess;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/descrip.mms rxvt-2.7.2/W11/xpm-3.4k/lib/descrip.mms
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/descrip.mms	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/descrip.mms	Mon May 14 08:23:10 2001
@@ -0,0 +1,82 @@
+cc_defs = /define=(NEED_STRCASECMP,NEED_STRDUP,NO_ZPIPE)
+c_deb = 
+
+.ifdef __DECC__
+pref = /prefix=all
+.endif
+
+OBJS=\
+data.obj,\
+create.obj,\
+misc.obj,\
+rgb.obj,\
+scan.obj,\
+parse.obj,\
+hashtab.obj,\
+WrFFrP.obj,\
+RdFToP.obj,\
+CrPFrDat.obj,\
+CrDatFrP.obj,\
+WrFFrI.obj,\
+RdFToI,\
+CrIFrDat.obj,\
+CrDatFrI.obj,\
+CrIFrBuf.obj,\
+CrPFrBuf.obj,\
+CrBufFrI.obj,\
+CrBufFrP.obj,\
+RdFToDat.obj,\
+WrFFrDat.obj,\
+Attrib.obj,\
+CrIFrP.obj,\
+CrPFrI.obj,\
+Image.obj,\
+Info.obj,\
+RdFToBuf.obj,\
+WrFFrBuf.obj
+
+CFLAGS= $(C_DEB) $(CC_DEFS) $(PREF)
+
+all : libXpm.olb sxpm.exe
+      @ library/compress libxpm.olb 
+
+libXpm.olb : libXpm.olb($(OBJS))
+	@ write sys$output " Libxpm available"
+
+sxpm.exe : sxpm.obj libXpm.olb
+                   @ link sxpm,sxpm/opt
+clean : 
+	delete *.obj;*,libXpm.olb;*
+
+
+# Other dependencies.
+CrBufFrI.obj :  XpmI.h xpm.h
+CrBufFrP.obj :  XpmI.h xpm.h
+CrDatFI.obj :  XpmI.h xpm.h
+CrDatFP.obj :  XpmI.h xpm.h
+CrIFrBuf.obj :  XpmI.h xpm.h
+CrIFrDat.obj :  XpmI.h xpm.h
+CrPFrBuf.obj :  XpmI.h xpm.h
+CrPFrDat.obj :  XpmI.h xpm.h
+RdFToDat.obj :  XpmI.h xpm.h
+RdFToI.obj :  XpmI.h xpm.h
+RdFToP.obj :  XpmI.h xpm.h
+WrFFrDat.obj :  XpmI.h xpm.h
+WrFFrI.obj :  XpmI.h xpm.h
+WrFFrP.obj :  XpmI.h xpm.h
+create.obj :  XpmI.h xpm.h
+data.obj :  XpmI.h xpm.h
+hashtab.obj :  XpmI.h xpm.h
+misc.obj :  XpmI.h xpm.h
+parse.obj :  XpmI.h xpm.h
+rgb.obj :  XpmI.h xpm.h
+scan.obj :  XpmI.h xpm.h
+Attrib.obj :  XpmI.h xpm.h
+CrIFrP.obj :  XpmI.h xpm.h
+CrPFrI.obj :  XpmI.h xpm.h
+Image.obj :  XpmI.h xpm.h
+Info.obj :  XpmI.h xpm.h
+RdFToBuf.obj :  XpmI.h xpm.h
+WrFFrBuf.obj :  XpmI.h xpm.h
+
+sxpm.obj : [-.sxpm]sxpm.c xpm.h
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/hashtab.c rxvt-2.7.2/W11/xpm-3.4k/lib/hashtab.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/hashtab.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/hashtab.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* hashtab.c:                                                                  *
+*                                                                             *
+*  XPM library                                                                *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+*  this originaly comes from Colas Nahaboo as a part of Wool                  *
+*                                                                             *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+LFUNC(AtomMake, xpmHashAtom, (char *name, void *data));
+LFUNC(HashTableGrows, int, (xpmHashTable * table));
+
+static xpmHashAtom
+AtomMake(name, data)			/* makes an atom */
+    char *name;				/* WARNING: is just pointed to */
+    void *data;
+{
+    xpmHashAtom object = (xpmHashAtom) XpmMalloc(sizeof(struct _xpmHashAtom));
+
+    if (object) {
+	object->name = name;
+	object->data = data;
+    }
+    return object;
+}
+
+/************************\
+* 			 *
+*  hash table routines 	 *
+* 			 *
+\************************/
+
+/*
+ * Hash function definition:
+ * HASH_FUNCTION: hash function, hash = hashcode, hp = pointer on char,
+ *				 hash2 = temporary for hashcode.
+ * INITIAL_TABLE_SIZE in slots
+ * HASH_TABLE_GROWS how hash table grows.
+ */
+
+/* Mock lisp function */
+#define HASH_FUNCTION 	  hash = (hash << 5) - hash + *hp++;
+/* #define INITIAL_HASH_SIZE 2017 */
+#define INITIAL_HASH_SIZE 256		/* should be enough for colors */
+#define HASH_TABLE_GROWS  size = size * 2;
+
+/* aho-sethi-ullman's HPJ (sizes should be primes)*/
+#ifdef notdef
+#define HASH_FUNCTION	hash <<= 4; hash += *hp++; \
+    if(hash2 = hash & 0xf0000000) hash ^= (hash2 >> 24) ^ hash2;
+#define INITIAL_HASH_SIZE 4095		/* should be 2^n - 1 */
+#define HASH_TABLE_GROWS  size = size << 1 + 1;
+#endif
+
+/* GNU emacs function */
+/*
+#define HASH_FUNCTION 	  hash = (hash << 3) + (hash >> 28) + *hp++;
+#define INITIAL_HASH_SIZE 2017
+#define HASH_TABLE_GROWS  size = size * 2;
+*/
+
+/* end of hash functions */
+
+/*
+ * The hash table is used to store atoms via their NAME:
+ *
+ * NAME --hash--> ATOM |--name--> "foo"
+ *		       |--data--> any value which has to be stored
+ *
+ */
+
+/*
+ * xpmHashSlot gives the slot (pointer to xpmHashAtom) of a name
+ * (slot points to NULL if it is not defined)
+ *
+ */
+
+xpmHashAtom *
+xpmHashSlot(table, s)
+    xpmHashTable *table;
+    char *s;
+{
+    xpmHashAtom *atomTable = table->atomTable;
+    unsigned int hash;
+    xpmHashAtom *p;
+    char *hp = s;
+    char *ns;
+
+    hash = 0;
+    while (*hp) {			/* computes hash function */
+	HASH_FUNCTION
+    }
+    p = atomTable + hash % table->size;
+    while (*p) {
+	ns = (*p)->name;
+	if (ns[0] == s[0] && strcmp(ns, s) == 0)
+	    break;
+	p--;
+	if (p < atomTable)
+	    p = atomTable + table->size - 1;
+    }
+    return p;
+}
+
+static int
+HashTableGrows(table)
+    xpmHashTable *table;
+{
+    xpmHashAtom *atomTable = table->atomTable;
+    int size = table->size;
+    xpmHashAtom *t, *p;
+    int i;
+    int oldSize = size;
+
+    t = atomTable;
+    HASH_TABLE_GROWS
+	table->size = size;
+    table->limit = size / 3;
+    atomTable = (xpmHashAtom *) XpmMalloc(size * sizeof(*atomTable));
+    if (!atomTable)
+	return (XpmNoMemory);
+    table->atomTable = atomTable;
+    for (p = atomTable + size; p > atomTable;)
+	*--p = NULL;
+    for (i = 0, p = t; i < oldSize; i++, p++)
+	if (*p) {
+	    xpmHashAtom *ps = xpmHashSlot(table, (*p)->name);
+
+	    *ps = *p;
+	}
+    XpmFree(t);
+    return (XpmSuccess);
+}
+
+/*
+ * xpmHashIntern(table, name, data)
+ * an xpmHashAtom is created if name doesn't exist, with the given data.
+ */
+
+int
+xpmHashIntern(table, tag, data)
+    xpmHashTable *table;
+    char *tag;
+    void *data;
+{
+    xpmHashAtom *slot;
+
+    if (!*(slot = xpmHashSlot(table, tag))) {
+	/* undefined, make a new atom with the given data */
+	if (!(*slot = AtomMake(tag, data)))
+	    return (XpmNoMemory);
+	if (table->used >= table->limit) {
+	    int ErrorStatus;
+
+	    if ((ErrorStatus = HashTableGrows(table)) != XpmSuccess)
+		return (ErrorStatus);
+	    table->used++;
+	    return (XpmSuccess);
+	}
+	table->used++;
+    }
+    return (XpmSuccess);
+}
+
+/*
+ *  must be called before allocating any atom
+ */
+
+int
+xpmHashTableInit(table)
+    xpmHashTable *table;
+{
+    xpmHashAtom *p;
+    xpmHashAtom *atomTable;
+
+    table->size = INITIAL_HASH_SIZE;
+    table->limit = table->size / 3;
+    table->used = 0;
+    atomTable = (xpmHashAtom *) XpmMalloc(table->size * sizeof(*atomTable));
+    if (!atomTable)
+	return (XpmNoMemory);
+    for (p = atomTable + table->size; p > atomTable;)
+	*--p = NULL;
+    table->atomTable = atomTable;
+    return (XpmSuccess);
+}
+
+/*
+ *   frees a hashtable and all the stored atoms
+ */
+
+void
+xpmHashTableFree(table)
+    xpmHashTable *table;
+{
+    xpmHashAtom *p;
+    xpmHashAtom *atomTable = table->atomTable;
+
+    if (!atomTable)
+	return;
+    for (p = atomTable + table->size; p > atomTable;)
+	if (*--p)
+	    XpmFree(*p);
+    XpmFree(atomTable);
+    table->atomTable = NULL;
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/make.com rxvt-2.7.2/W11/xpm-3.4k/lib/make.com
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/make.com	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/make.com	Mon May 14 08:23:10 2001
@@ -0,0 +1,169 @@
+$!---------------make.com for xpmlib----------------------------------------
+$! make xpmlib under VMS
+$!
+$ Make = ""
+$!
+$! Where are we?
+$!
+$ here = f$directory()
+$ disk = f$trnlnm("SYS$DISK")
+$ path = "''disk'"+ "''here'" 
+$ xpath = "''path'" - "SXPM]" + "lib]"
+$ if f$trnlnm("X11").eqs."" then define x11 decw$include,'xpath
+$!
+$! Check for MMK/MMS
+$!
+$ If F$Search ("Sys$System:MMS.EXE") .nes. "" Then Make = "MMS"
+$ If F$Type (MMK) .eqs. "STRING" Then Make = "MMK"
+$!
+$! Look for the compiler used
+$!
+$ ccopt = "/define=(NEED_STRCASECMP,NEED_STRDUP,NO_ZPIPE)"
+$ if f$getsyi("HW_MODEL").ge.1024
+$ then
+$  ccopt = "/prefix=all"+ccopt
+$  comp  = "__decc__=1"
+$  if f$trnlnm("SYS").eqs."" then define sys sys$library:
+$ else
+$  if f$search("SYS$SYSTEM:DECC$COMPILER.EXE").eqs.""
+$   then
+$    comp  = "__vaxc__=1"
+$    if f$trnlnm("SYS").eqs."" then define sys sys$library:
+$   else
+$    if f$trnlnm("SYS").eqs."" then define sys decc$library_include:
+$    ccopt = "/decc/prefix=all"+ccopt
+$    comp  = "__decc__=1"
+$  endif
+$ endif
+$!
+$! Produce linker-options file according to X-Release and compiler used
+$!
+$ open/write optf sxpm.opt
+$ write optf "libxpm.olb/lib"
+$ write optf "sys$share:decw$xextlibshr.exe/share"
+$ write optf "sys$share:decw$xlibshr.exe/share"
+$ @sys$update:decw$get_image_version sys$share:decw$xlibshr.exe decw$version
+$ if f$extract(4,3,decw$version).eqs."1.1"
+$ then
+$   write optf "sys$share:decw$xtshr.exe/share"
+$ endif
+$ if f$extract(4,3,decw$version).eqs."1.2"
+$ then
+$   write optf "sys$share:decw$xtlibshrr5.exe/share"
+$ endif
+$ close optf
+$!
+$! Build the thing plain or with 'Make'
+$!
+$ write sys$output "Compiling XPMlib sources ..."
+$  if (Make .eqs. "")
+$   then
+$    'Make'/Macro = ('comp')
+$  else
+$   CALL MAKE CrBufFrI.OBJ "CC ''CCOPT' CrBufFrI" -
+                CrBufFrI.c XpmI.h xpm.h
+$   CALL MAKE CrBufFrP.OBJ "CC ''CCOPT' CrBufFrP" -
+                CrBufFrP.c XpmI.h xpm.h
+$   CALL MAKE CrDatFI.OBJ "CC ''CCOPT' CrDatFrI" -
+                CrDatFrI.c XpmI.h xpm.h
+$   CALL MAKE CrDatFP.OBJ "CC ''CCOPT' CrDatFrP" -
+                CrDatFrP.c XpmI.h xpm.h
+$   CALL MAKE CrIFrBuf.OBJ "CC ''CCOPT' CrIFrBuf" -
+                CrIFrBuf.c XpmI.h xpm.h
+$   CALL MAKE CrIFrDat.OBJ "CC ''CCOPT' CrIFrDat" -
+                CrIFrDat.c XpmI.h xpm.h
+$   CALL MAKE CrPFrBuf.OBJ "CC ''CCOPT' CrPFrBuf" -
+                CrPFrBuf.c XpmI.h xpm.h
+$   CALL MAKE CrPFrDat.OBJ "CC ''CCOPT' CrPFrDat" -
+                CrPFrDat.c XpmI.h xpm.h
+$   CALL MAKE RdFToDat.OBJ "CC ''CCOPT' RdFToDat" -
+                RdFToDat.c XpmI.h xpm.h
+$   CALL MAKE RdFToI.OBJ "CC ''CCOPT' RdFToI" -
+                RdFToI.c XpmI.h xpm.h
+$   CALL MAKE RdFToP.OBJ "CC ''CCOPT' RdFToP" -
+                RdFToP.c XpmI.h xpm.h
+$   CALL MAKE WrFFrDat.OBJ "CC ''CCOPT' WrFFrDat" -
+                WrFFrDat.c XpmI.h xpm.h
+$   CALL MAKE WrFFrI.OBJ "CC ''CCOPT' WrFFrI" -
+                WrFFrI.c XpmI.h xpm.h
+$   CALL MAKE WrFFrP.OBJ "CC ''CCOPT' WrFFrP" -
+                WrFFrP.c XpmI.h xpm.h
+$   CALL MAKE create.OBJ "CC ''CCOPT' create" -
+                create.c XpmI.h xpm.h
+$   CALL MAKE data.OBJ "CC ''CCOPT' data" -
+                data.c XpmI.h xpm.h
+$   CALL MAKE hashtab.OBJ "CC ''CCOPT' hashtab" -
+                hashtab.c XpmI.h xpm.h
+$   CALL MAKE misc.OBJ "CC ''CCOPT' misc" -
+                misc.c XpmI.h xpm.h
+$   CALL MAKE parse.OBJ "CC ''CCOPT' parse" -
+                parse.c XpmI.h xpm.h
+$   CALL MAKE rgb.OBJ "CC ''CCOPT' rgb" -
+                rgb.c XpmI.h xpm.h
+$   CALL MAKE scan.OBJ "CC ''CCOPT' scan" -
+                scan.c XpmI.h xpm.h
+$   CALL MAKE Attrib.OBJ "CC ''CCOPT' Attrib" -
+                Attrib.c XpmI.h xpm.h
+$   CALL MAKE CrIFrP.OBJ "CC ''CCOPT' CrIFrP" -
+                CrIFrP.c XpmI.h xpm.h
+$   CALL MAKE CrPFrI.OBJ "CC ''CCOPT' CrPFrI" -
+                CrPFrI.c XpmI.h xpm.h
+$   CALL MAKE Image.OBJ "CC ''CCOPT' Image" -
+                Image.c XpmI.h xpm.h
+$   CALL MAKE Info.OBJ "CC ''CCOPT' Info" -
+                Info.c XpmI.h xpm.h
+$   CALL MAKE RdFToBuf.OBJ "CC ''CCOPT' RdFToBuf" -
+                RdFToBuf.c XpmI.h xpm.h
+$   CALL MAKE WrFFrBuf.OBJ "CC ''CCOPT' WrFFrBuf" -
+                WrFFrBuf.c XpmI.h xpm.h
+$   write sys$output "Building XPMlib ..."
+$   CALL MAKE LIBXPM.OLB "lib/crea libxpm.olb *.obj" *.OBJ
+$   CALL MAKE SXPM.OBJ "CC  ''CCOPT' [-.sxpm]sxpm" -
+                [-.sxpm]sxpm.c xpm.h
+$   write sys$output "Linking SXPM ..."
+$   CALL MAKE SXPM.EXE "LINK  sxpm,sxpm.opt/OPT" sxpm.OBJ
+$  endif
+$ write sys$output "XPMlib build completed"
+$ sxpm :=="$''path'sxpm.exe"
+$ exit
+$!
+$!
+$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES
+$ V = 'F$Verify(0)
+$! P1 = What we are trying to make
+$! P2 = Command to make it
+$! P3 - P8  What it depends on
+$
+$ If F$Search(P1) .Eqs. "" Then Goto Makeit
+$ Time = F$CvTime(F$File(P1,"RDT"))
+$arg=3
+$Loop:
+$       Argument = P'arg
+$       If Argument .Eqs. "" Then Goto Exit
+$       El=0
+$Loop2:
+$       File = F$Element(El," ",Argument)
+$       If File .Eqs. " " Then Goto Endl
+$       AFile = ""
+$Loop3:
+$       OFile = AFile
+$       AFile = F$Search(File)
+$       If AFile .Eqs. "" .Or. AFile .Eqs. OFile Then Goto NextEl
+$       If F$CvTime(F$File(AFile,"RDT")) .Ges. Time Then Goto Makeit
+$       Goto Loop3
+$NextEL:
+$       El = El + 1
+$       Goto Loop2
+$EndL:
+$ arg=arg+1
+$ If arg .Le. 8 Then Goto Loop
+$ Goto Exit
+$
+$Makeit:
+$ VV=F$VERIFY(0)
+$ write sys$output P2
+$ 'P2
+$ VV='F$Verify(VV)
+$Exit:
+$ If V Then Set Verify
+$ENDSUBROUTINE
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/misc.c rxvt-2.7.2/W11/xpm-3.4k/lib/misc.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/misc.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/misc.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* misc.c:                                                                     *
+*                                                                             *
+*  XPM library                                                                *
+*  Miscellaneous utilities                                                    *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include "XpmI.h"
+
+#ifdef NEED_STRDUP
+/*
+ * in case strdup is not provided by the system here is one
+ * which does the trick
+ */
+char *
+xpmstrdup(s1)
+    char *s1;
+{
+    char *s2;
+    int l = strlen(s1) + 1;
+
+    if (s2 = (char *) XpmMalloc(l))
+	strcpy(s2, s1);
+    return s2;
+}
+
+#endif
+
+unsigned int
+xpmatoui(p, l, ui_return)
+    register char *p;
+    unsigned int l;
+    unsigned int *ui_return;
+{
+    register unsigned int n, i;
+
+    n = 0;
+    for (i = 0; i < l; i++)
+	if (*p >= '0' && *p <= '9')
+	    n = n * 10 + *p++ - '0';
+	else
+	    break;
+
+    if (i != 0 && i == l) {
+	*ui_return = n;
+	return 1;
+    } else
+	return 0;
+}
+
+/*
+ * Function returning a character string related to an error code.
+ */
+char *
+XpmGetErrorString(errcode)
+    int errcode;
+{
+    switch (errcode) {
+    case XpmColorError:
+	return ("XpmColorError");
+    case XpmSuccess:
+	return ("XpmSuccess");
+    case XpmOpenFailed:
+	return ("XpmOpenFailed");
+    case XpmFileInvalid:
+	return ("XpmFileInvalid");
+    case XpmNoMemory:
+	return ("XpmNoMemory");
+    case XpmColorFailed:
+	return ("XpmColorFailed");
+    default:
+	return ("Invalid XpmError");
+    }
+}
+
+/*
+ * The following function provides a way to figure out if the linked library is
+ * newer or older than the one with which a program has been first compiled.
+ */
+int
+XpmLibraryVersion()
+{
+    return XpmIncludeVersion;
+}
+
+
+/* The following should help people wanting to use their own functions */
+#ifdef XpmFree
+#undef XpmFree
+#endif
+
+void
+XpmFree(ptr)
+    void *ptr;
+{
+    free(ptr);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/parse.c rxvt-2.7.2/W11/xpm-3.4k/lib/parse.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/parse.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/parse.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,745 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* parse.c:                                                                    *
+*                                                                             *
+*  XPM library                                                                *
+*  Parse an XPM file or array and store the found informations                *
+*  in the given XpmImage structure.                                           *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+#include "XpmI.h"
+#include <ctype.h>
+
+LFUNC(ParsePixels, int, (xpmData *data, unsigned int width,
+			 unsigned int height, unsigned int ncolors,
+			 unsigned int cpp, XpmColor *colorTable,
+			 xpmHashTable *hashtable, unsigned int **pixels));
+
+char *xpmColorKeys[] = {
+    "s",				/* key #1: symbol */
+    "m",				/* key #2: mono visual */
+    "g4",				/* key #3: 4 grays visual */
+    "g",				/* key #4: gray visual */
+    "c",				/* key #5: color visual */
+};
+
+int
+xpmParseValues(data, width, height, ncolors, cpp,
+	    x_hotspot, y_hotspot, hotspot, extensions)
+    xpmData *data;
+    unsigned int *width, *height, *ncolors, *cpp;
+    unsigned int *x_hotspot, *y_hotspot, *hotspot;
+    unsigned int *extensions;
+{
+    unsigned int l;
+    char buf[BUFSIZ];
+
+    if (!data->format) {		/* XPM 2 or 3 */
+
+	/*
+	 * read values: width, height, ncolors, chars_per_pixel
+	 */
+	if (!(xpmNextUI(data, width) && xpmNextUI(data, height)
+	      && xpmNextUI(data, ncolors) && xpmNextUI(data, cpp)))
+	    return (XpmFileInvalid);
+
+	/*
+	 * read optional information (hotspot and/or XPMEXT) if any
+	 */
+	l = xpmNextWord(data, buf, BUFSIZ);
+	if (l) {
+	    *extensions = (l == 6 && !strncmp("XPMEXT", buf, 6));
+	    if (*extensions)
+		*hotspot = (xpmNextUI(data, x_hotspot)
+			    && xpmNextUI(data, y_hotspot));
+	    else {
+		*hotspot = (xpmatoui(buf, l, x_hotspot)
+			    && xpmNextUI(data, y_hotspot));
+		l = xpmNextWord(data, buf, BUFSIZ);
+		*extensions = (l == 6 && !strncmp("XPMEXT", buf, 6));
+	    }
+	}
+    } else {
+
+	/*
+	 * XPM 1 file read values: width, height, ncolors, chars_per_pixel
+	 */
+	int i;
+	char *ptr;
+	Bool got_one, saw_width = False, saw_height = False;
+	Bool saw_ncolors = False, saw_chars_per_pixel = False;
+
+	for (i = 0; i < 4; i++) {
+	    l = xpmNextWord(data, buf, BUFSIZ);
+	    if (l != 7 || strncmp("#define", buf, 7))
+		return (XpmFileInvalid);
+	    l = xpmNextWord(data, buf, BUFSIZ);
+	    if (!l)
+		return (XpmFileInvalid);
+	    buf[l] = '\0';
+	    ptr = buf;
+	    got_one = False;
+	    while (!got_one) {
+		ptr = index(ptr, '_');
+		if (!ptr)
+		    return (XpmFileInvalid);
+		switch (l - (ptr - buf)) {
+		case 6:
+		    if (saw_width || strncmp("_width", ptr, 6)
+			|| !xpmNextUI(data, width))
+			return (XpmFileInvalid);
+		    else
+			saw_width = True;
+		    got_one = True;
+		    break;
+		case 7:
+		    if (saw_height || strncmp("_height", ptr, 7)
+			|| !xpmNextUI(data, height))
+			return (XpmFileInvalid);
+		    else
+			saw_height = True;
+		    got_one = True;
+		    break;
+		case 8:
+		    if (saw_ncolors || strncmp("_ncolors", ptr, 8)
+			|| !xpmNextUI(data, ncolors))
+			return (XpmFileInvalid);
+		    else
+			saw_ncolors = True;
+		    got_one = True;
+		    break;
+		case 16:
+		    if (saw_chars_per_pixel
+			|| strncmp("_chars_per_pixel", ptr, 16)
+			|| !xpmNextUI(data, cpp))
+			return (XpmFileInvalid);
+		    else
+			saw_chars_per_pixel = True;
+		    got_one = True;
+		    break;
+		default:
+		    ptr++;
+		}
+	    }
+	    /* skip the end of line */
+	    xpmNextString(data);
+	}
+	if (!saw_width || !saw_height || !saw_ncolors || !saw_chars_per_pixel)
+	  return (XpmFileInvalid);
+
+	*hotspot = 0;
+	*extensions = 0;
+    }
+    return (XpmSuccess);
+}
+
+int
+xpmParseColors(data, ncolors, cpp, colorTablePtr, hashtable)
+    xpmData *data;
+    unsigned int ncolors;
+    unsigned int cpp;
+    XpmColor **colorTablePtr;
+    xpmHashTable *hashtable;
+{
+    unsigned int key, l, a, b;
+    unsigned int curkey;		/* current color key */
+    unsigned int lastwaskey;		/* key read */
+    char buf[BUFSIZ];
+    char curbuf[BUFSIZ];		/* current buffer */
+    char **sptr, *s;
+    XpmColor *color;
+    XpmColor *colorTable;
+    char **defaults;
+    int ErrorStatus;
+
+    colorTable = (XpmColor *) XpmCalloc(ncolors, sizeof(XpmColor));
+    if (!colorTable)
+	return (XpmNoMemory);
+
+    if (!data->format) {		/* XPM 2 or 3 */
+	for (a = 0, color = colorTable; a < ncolors; a++, color++) {
+	    xpmNextString(data);	/* skip the line */
+
+	    /*
+	     * read pixel value
+	     */
+	    color->string = (char *) XpmMalloc(cpp + 1);
+	    if (!color->string) {
+		xpmFreeColorTable(colorTable, ncolors);
+		return (XpmNoMemory);
+	    }
+	    for (b = 0, s = color->string; b < cpp; b++, s++)
+		*s = xpmGetC(data);
+	    *s = '\0';
+
+	    /*
+	     * store the string in the hashtable with its color index number
+	     */
+	    if (USE_HASHTABLE) {
+		ErrorStatus =
+		    xpmHashIntern(hashtable, color->string, HashAtomData(a));
+		if (ErrorStatus != XpmSuccess) {
+		    xpmFreeColorTable(colorTable, ncolors);
+		    return (ErrorStatus);
+		}
+	    }
+
+	    /*
+	     * read color keys and values
+	     */
+	    defaults = (char **) color;
+	    curkey = 0;
+	    lastwaskey = 0;
+	    *curbuf = '\0';		/* init curbuf */
+	    while (l = xpmNextWord(data, buf, BUFSIZ)) {
+		if (!lastwaskey) {
+		    for (key = 0, sptr = xpmColorKeys; key < NKEYS; key++,
+			 sptr++)
+			if ((strlen(*sptr) == l) && (!strncmp(*sptr, buf, l)))
+			    break;
+		}
+		if (!lastwaskey && key < NKEYS) {	/* open new key */
+		    if (curkey) {	/* flush string */
+			s = (char *) XpmMalloc(strlen(curbuf) + 1);
+			if (!s) {
+			    xpmFreeColorTable(colorTable, ncolors);
+			    return (XpmNoMemory);
+			}
+			defaults[curkey] = s;
+			strcpy(s, curbuf);
+		    }
+		    curkey = key + 1;	/* set new key  */
+		    *curbuf = '\0';	/* reset curbuf */
+		    lastwaskey = 1;
+		} else {
+		    if (!curkey) {	/* key without value */
+			xpmFreeColorTable(colorTable, ncolors);
+			return (XpmFileInvalid);
+		    }
+		    if (!lastwaskey)
+			strcat(curbuf, " ");	/* append space */
+		    buf[l] = '\0';
+		    strcat(curbuf, buf);/* append buf */
+		    lastwaskey = 0;
+		}
+	    }
+	    if (!curkey) {		/* key without value */
+		xpmFreeColorTable(colorTable, ncolors);
+		return (XpmFileInvalid);
+	    }
+	    s = defaults[curkey] = (char *) XpmMalloc(strlen(curbuf) + 1);
+	    if (!s) {
+		xpmFreeColorTable(colorTable, ncolors);
+		return (XpmNoMemory);
+	    }
+	    strcpy(s, curbuf);
+	}
+    } else {				/* XPM 1 */
+	/* get to the beginning of the first string */
+	data->Bos = '"';
+	data->Eos = '\0';
+	xpmNextString(data);
+	data->Eos = '"';
+	for (a = 0, color = colorTable; a < ncolors; a++, color++) {
+
+	    /*
+	     * read pixel value
+	     */
+	    color->string = (char *) XpmMalloc(cpp + 1);
+	    if (!color->string) {
+		xpmFreeColorTable(colorTable, ncolors);
+		return (XpmNoMemory);
+	    }
+	    for (b = 0, s = color->string; b < cpp; b++, s++)
+		*s = xpmGetC(data);
+	    *s = '\0';
+
+	    /*
+	     * store the string in the hashtable with its color index number
+	     */
+	    if (USE_HASHTABLE) {
+		ErrorStatus =
+		    xpmHashIntern(hashtable, color->string, HashAtomData(a));
+		if (ErrorStatus != XpmSuccess) {
+		    xpmFreeColorTable(colorTable, ncolors);
+		    return (ErrorStatus);
+		}
+	    }
+
+	    /*
+	     * read color values
+	     */
+	    xpmNextString(data);	/* get to the next string */
+	    *curbuf = '\0';		/* init curbuf */
+	    while (l = xpmNextWord(data, buf, BUFSIZ)) {
+		if (*curbuf != '\0')
+		    strcat(curbuf, " ");/* append space */
+		buf[l] = '\0';
+		strcat(curbuf, buf);	/* append buf */
+	    }
+	    s = (char *) XpmMalloc(strlen(curbuf) + 1);
+	    if (!s) {
+		xpmFreeColorTable(colorTable, ncolors);
+		return (XpmNoMemory);
+	    }
+	    strcpy(s, curbuf);
+	    color->c_color = s;
+	    *curbuf = '\0';		/* reset curbuf */
+	    if (a < ncolors - 1)
+		xpmNextString(data);	/* get to the next string */
+	}
+    }
+    *colorTablePtr = colorTable;
+    return (XpmSuccess);
+}
+
+static int
+ParsePixels(data, width, height, ncolors, cpp, colorTable, hashtable, pixels)
+    xpmData *data;
+    unsigned int width;
+    unsigned int height;
+    unsigned int ncolors;
+    unsigned int cpp;
+    XpmColor *colorTable;
+    xpmHashTable *hashtable;
+    unsigned int **pixels;
+{
+    unsigned int *iptr, *iptr2;
+    unsigned int a, x, y;
+
+#ifndef FOR_MSW
+    iptr2 = (unsigned int *) XpmMalloc(sizeof(unsigned int) * width * height);
+#else
+
+    /*
+     * special treatment to trick DOS malloc(size_t) where size_t is 16 bit!!
+     * XpmMalloc is defined to longMalloc(long) and checks the 16 bit boundary
+     */
+    iptr2 = (unsigned int *)
+	XpmMalloc((long) sizeof(unsigned int) * (long) width * (long) height);
+#endif
+    if (!iptr2)
+	return (XpmNoMemory);
+
+    iptr = iptr2;
+
+    switch (cpp) {
+
+    case (1):				/* Optimize for single character
+					 * colors */
+	{
+	    unsigned short colidx[256];
+
+	    bzero((char *)colidx, 256 * sizeof(short));
+	    for (a = 0; a < ncolors; a++)
+		colidx[(unsigned char)colorTable[a].string[0]] = a + 1;
+
+	    for (y = 0; y < height; y++) {
+		xpmNextString(data);
+		for (x = 0; x < width; x++, iptr++) {
+		    int c = xpmGetC(data);
+
+		    if (c > 0 && c < 256 && colidx[c] != 0)
+			*iptr = colidx[c] - 1;
+		    else {
+			XpmFree(iptr2);
+			return (XpmFileInvalid);
+		    }
+		}
+	    }
+	}
+	break;
+
+    case (2):				/* Optimize for double character
+					 * colors */
+	{
+
+/* free all allocated pointers at all exits */
+#define FREE_CIDX {int f; for (f = 0; f < 256; f++) \
+if (cidx[f]) XpmFree(cidx[f]);}
+
+	    /* array of pointers malloced by need */
+	    unsigned short *cidx[256];
+	    int char1;
+
+	    bzero((char *)cidx, 256 * sizeof(unsigned short *)); /* init */
+	    for (a = 0; a < ncolors; a++) {
+		char1 = colorTable[a].string[0];
+		if (cidx[char1] == NULL) { /* get new memory */
+		    cidx[char1] = (unsigned short *)
+			XpmCalloc(256, sizeof(unsigned short));
+		    if (cidx[char1] == NULL) { /* new block failed */
+			FREE_CIDX;
+			XpmFree(iptr2);
+			return (XpmNoMemory);
+		    }
+		}
+		cidx[char1][(unsigned char)colorTable[a].string[1]] = a + 1;
+	    }
+
+	    for (y = 0; y < height; y++) {
+		xpmNextString(data);
+		for (x = 0; x < width; x++, iptr++) {
+		    int cc1 = xpmGetC(data);
+		    if (cc1 > 0 && cc1 < 256) {
+			int cc2 = xpmGetC(data);
+			if (cc2 > 0 && cc2 < 256 &&
+			    cidx[cc1] && cidx[cc1][cc2] != 0)
+			    *iptr = cidx[cc1][cc2] - 1;
+			else {
+			    FREE_CIDX;
+			    XpmFree(iptr2);
+			    return (XpmFileInvalid);
+			}
+		    } else {
+			FREE_CIDX;
+			XpmFree(iptr2);
+			return (XpmFileInvalid);
+		    }
+		}
+	    }
+	    FREE_CIDX;
+	}
+	break;
+
+    default:				/* Non-optimized case of long color
+					 * names */
+	{
+	    char *s;
+	    char buf[BUFSIZ];
+
+	    buf[cpp] = '\0';
+	    if (USE_HASHTABLE) {
+		xpmHashAtom *slot;
+
+		for (y = 0; y < height; y++) {
+		    xpmNextString(data);
+		    for (x = 0; x < width; x++, iptr++) {
+			for (a = 0, s = buf; a < cpp; a++, s++)
+			    *s = xpmGetC(data);
+			slot = xpmHashSlot(hashtable, buf);
+			if (!*slot) {	/* no color matches */
+			    XpmFree(iptr2);
+			    return (XpmFileInvalid);
+			}
+			*iptr = HashColorIndex(slot);
+		    }
+		}
+	    } else {
+		for (y = 0; y < height; y++) {
+		    xpmNextString(data);
+		    for (x = 0; x < width; x++, iptr++) {
+			for (a = 0, s = buf; a < cpp; a++, s++)
+			    *s = xpmGetC(data);
+			for (a = 0; a < ncolors; a++)
+			    if (!strcmp(colorTable[a].string, buf))
+				break;
+			if (a == ncolors) {	/* no color matches */
+			    XpmFree(iptr2);
+			    return (XpmFileInvalid);
+			}
+			*iptr = a;
+		    }
+		}
+	    }
+	}
+	break;
+    }
+    *pixels = iptr2;
+    return (XpmSuccess);
+}
+
+int
+xpmParseExtensions(data, extensions, nextensions)
+    xpmData *data;
+    XpmExtension **extensions;
+    unsigned int *nextensions;
+{
+    XpmExtension *exts = NULL, *ext;
+    unsigned int num = 0;
+    unsigned int nlines, a, l, notstart, notend = 0;
+    int status;
+    char *string, *s, *s2, **sp;
+
+    xpmNextString(data);
+    exts = (XpmExtension *) XpmMalloc(sizeof(XpmExtension));
+    /* get the whole string */
+    status = xpmGetString(data, &string, &l);
+    if (status != XpmSuccess) {
+	XpmFree(exts);
+	return (status);
+    }
+    /* look for the key word XPMEXT, skip lines before this */
+    while ((notstart = strncmp("XPMEXT", string, 6))
+	   && (notend = strncmp("XPMENDEXT", string, 9))) {
+	XpmFree(string);
+	xpmNextString(data);
+	status = xpmGetString(data, &string, &l);
+	if (status != XpmSuccess) {
+	    XpmFree(exts);
+	    return (status);
+	}
+    }
+    if (!notstart)
+	notend = strncmp("XPMENDEXT", string, 9);
+    while (!notstart && notend) {
+	/* there starts an extension */
+	ext = (XpmExtension *)
+	    XpmRealloc(exts, (num + 1) * sizeof(XpmExtension));
+	if (!ext) {
+	    XpmFree(string);
+	    XpmFreeExtensions(exts, num);
+	    return (XpmNoMemory);
+	}
+	exts = ext;
+	ext += num;
+	/* skip whitespace and store its name */
+	s2 = s = string + 6;
+	while (isspace(*s2))
+	    s2++;
+	a = s2 - s;
+	ext->name = (char *) XpmMalloc(l - a - 6);
+	if (!ext->name) {
+	    XpmFree(string);
+	    ext->lines = NULL;
+	    ext->nlines = 0;
+	    XpmFreeExtensions(exts, num + 1);
+	    return (XpmNoMemory);
+	}
+	strncpy(ext->name, s + a, l - a - 6);
+	XpmFree(string);
+	/* now store the related lines */
+	xpmNextString(data);
+	status = xpmGetString(data, &string, &l);
+	if (status != XpmSuccess) {
+	    ext->lines = NULL;
+	    ext->nlines = 0;
+	    XpmFreeExtensions(exts, num + 1);
+	    return (status);
+	}
+	ext->lines = (char **) XpmMalloc(sizeof(char *));
+	nlines = 0;
+	while ((notstart = strncmp("XPMEXT", string, 6))
+	       && (notend = strncmp("XPMENDEXT", string, 9))) {
+	    sp = (char **)
+		XpmRealloc(ext->lines, (nlines + 1) * sizeof(char *));
+	    if (!sp) {
+		XpmFree(string);
+		ext->nlines = nlines;
+		XpmFreeExtensions(exts, num + 1);
+		return (XpmNoMemory);
+	    }
+	    ext->lines = sp;
+	    ext->lines[nlines] = string;
+	    nlines++;
+	    xpmNextString(data);
+	    status = xpmGetString(data, &string, &l);
+	    if (status != XpmSuccess) {
+		ext->nlines = nlines;
+		XpmFreeExtensions(exts, num + 1);
+		return (status);
+	    }
+	}
+	if (!nlines) {
+	    XpmFree(ext->lines);
+	    ext->lines = NULL;
+	}
+	ext->nlines = nlines;
+	num++;
+    }
+    if (!num) {
+	XpmFree(string);
+	XpmFree(exts);
+	exts = NULL;
+    } else if (!notend)
+	XpmFree(string);
+    *nextensions = num;
+    *extensions = exts;
+    return (XpmSuccess);
+}
+
+
+/* function call in case of error */
+#undef RETURN
+#define RETURN(status) \
+{ \
+      goto error; \
+}
+
+/*
+ * This function parses an Xpm file or data and store the found informations
+ * in an an XpmImage structure which is returned.
+ */
+int
+xpmParseData(data, image, info)
+    xpmData *data;
+    XpmImage *image;
+    XpmInfo *info;
+{
+    /* variables to return */
+    unsigned int width, height, ncolors, cpp;
+    unsigned int x_hotspot, y_hotspot, hotspot = 0, extensions = 0;
+    XpmColor *colorTable = NULL;
+    unsigned int *pixelindex = NULL;
+    char *hints_cmt = NULL;
+    char *colors_cmt = NULL;
+    char *pixels_cmt = NULL;
+
+    unsigned int cmts;
+    int ErrorStatus;
+    xpmHashTable hashtable;
+
+    cmts = info && (info->valuemask & XpmReturnComments);
+
+    /*
+     * parse the header
+     */
+    ErrorStatus = xpmParseHeader(data);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /*
+     * read values
+     */
+    ErrorStatus = xpmParseValues(data, &width, &height, &ncolors, &cpp,
+				 &x_hotspot, &y_hotspot, &hotspot,
+				 &extensions);
+    if (ErrorStatus != XpmSuccess)
+	return (ErrorStatus);
+
+    /*
+     * store the hints comment line
+     */
+    if (cmts)
+	xpmGetCmt(data, &hints_cmt);
+
+    /*
+     * init the hastable
+     */
+    if (USE_HASHTABLE) {
+	ErrorStatus = xpmHashTableInit(&hashtable);
+	if (ErrorStatus != XpmSuccess)
+	    return (ErrorStatus);
+    }
+
+    /*
+     * read colors
+     */
+    ErrorStatus = xpmParseColors(data, ncolors, cpp, &colorTable, &hashtable);
+    if (ErrorStatus != XpmSuccess) {
+	if (USE_HASHTABLE)
+	    xpmHashTableFree(&hashtable);
+	RETURN(ErrorStatus);
+    }
+
+    /*
+     * store the colors comment line
+     */
+    if (cmts)
+	xpmGetCmt(data, &colors_cmt);
+
+    /*
+     * read pixels and index them on color number
+     */
+    ErrorStatus = ParsePixels(data, width, height, ncolors, cpp, colorTable,
+			      &hashtable, &pixelindex);
+
+    /*
+     * free the hastable
+     */
+    if (USE_HASHTABLE)
+	xpmHashTableFree(&hashtable);
+
+    if (ErrorStatus != XpmSuccess)
+	RETURN(ErrorStatus);
+
+    /*
+     * store the pixels comment line
+     */
+    if (cmts)
+	xpmGetCmt(data, &pixels_cmt);
+
+    /*
+     * parse extensions
+     */
+    if (info && (info->valuemask & XpmReturnExtensions))
+	if (extensions) {
+	    ErrorStatus = xpmParseExtensions(data, &info->extensions,
+					     &info->nextensions);
+	    if (ErrorStatus != XpmSuccess)
+		RETURN(ErrorStatus);
+	} else {
+	    info->extensions = NULL;
+	    info->nextensions = 0;
+	}
+
+    /*
+     * store found informations in the XpmImage structure
+     */
+    image->width = width;
+    image->height = height;
+    image->cpp = cpp;
+    image->ncolors = ncolors;
+    image->colorTable = colorTable;
+    image->data = pixelindex;
+
+    if (info) {
+	if (cmts) {
+	    info->hints_cmt = hints_cmt;
+	    info->colors_cmt = colors_cmt;
+	    info->pixels_cmt = pixels_cmt;
+	}
+	if (hotspot) {
+	    info->x_hotspot = x_hotspot;
+	    info->y_hotspot = y_hotspot;
+	    info->valuemask |= XpmHotspot;
+	}
+    }
+    return (XpmSuccess);
+
+/* exit point in case of error, free only locally allocated variables */
+error:
+    if (colorTable)
+	xpmFreeColorTable(colorTable, ncolors);
+    if (pixelindex)
+	XpmFree(pixelindex);
+    if (hints_cmt)
+	XpmFree(hints_cmt);
+    if (colors_cmt)
+	XpmFree(colors_cmt);
+    if (pixels_cmt)
+	XpmFree(pixels_cmt);
+
+    return(ErrorStatus);
+}
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/rgb.c rxvt-2.7.2/W11/xpm-3.4k/lib/rgb.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/rgb.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/rgb.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* rgb.c:                                                                      *
+*                                                                             *
+*  XPM library                                                                *
+*  Rgb file utilities                                                         *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+/*
+ * Part of this code has been taken from the ppmtoxpm.c file written by Mark
+ * W. Snitily but has been modified for my special need
+ */
+
+#include "XpmI.h"
+#include <ctype.h>
+
+#ifndef FOR_MSW				/* normal part first, MSW part at
+					 * the end, (huge ifdef!) */
+/*
+ * Read a rgb text file.  It stores the rgb values (0->65535)
+ * and the rgb mnemonics (malloc'ed) into the "rgbn" array.  Returns the
+ * number of entries stored.
+ */
+int
+xpmReadRgbNames(rgb_fname, rgbn)
+    char *rgb_fname;
+    xpmRgbName rgbn[];
+
+{
+    FILE *rgbf;
+    int n, items, red, green, blue;
+    char line[512], name[512], *rgbname, *s1, *s2;
+    xpmRgbName *rgb;
+
+    /* Open the rgb text file.  Abort if error. */
+    if ((rgbf = fopen(rgb_fname, "r")) == NULL)
+	return 0;
+
+    /* Loop reading each line in the file. */
+    n = 0;
+    rgb = rgbn; 
+    /* Quit if rgb text file has too many entries. */
+    while (fgets(line, sizeof(line), rgbf) && n < MAX_RGBNAMES) {
+
+	/* Skip silently if line is bad. */
+	items = sscanf(line, "%d %d %d %[^\n]\n", &red, &green, &blue, name);
+	if (items != 4)
+	    continue;
+
+	/*
+	 * Make sure rgb values are within 0->255 range. Skip silently if
+	 * bad.
+	 */
+	if (red < 0 || red > 0xFF ||
+	    green < 0 || green > 0xFF ||
+	    blue < 0 || blue > 0xFF)
+	    continue;
+
+	/* Allocate memory for ascii name. If error give up here. */
+	if (!(rgbname = (char *) XpmMalloc(strlen(name) + 1)))
+	    break;
+
+	/* Copy string to ascii name and lowercase it. */
+	for (s1 = name, s2 = rgbname; *s1; s1++)
+	    *s2++ = tolower(*s1);
+	*s2 = '\0';
+
+	/* Save the rgb values and ascii name in the array. */
+	rgb->r = red * 257;		/* 65535/255 = 257 */
+	rgb->g = green * 257;
+	rgb->b = blue * 257;
+	rgb->name = rgbname;
+	rgb++;
+	n++;
+    }
+
+    fclose(rgbf);
+
+    /* Return the number of read rgb names. */
+    return n < 0 ? 0 : n;
+}
+
+/*
+ * Return the color name corresponding to the given rgb values
+ */
+char *
+xpmGetRgbName(rgbn, rgbn_max, red, green, blue)
+    xpmRgbName rgbn[];			/* rgb mnemonics from rgb text file */
+    int rgbn_max;			/* number of rgb mnemonics in table */
+    int red, green, blue;		/* rgb values */
+
+{
+    int i;
+    xpmRgbName *rgb;
+
+    /*
+     * Just perform a dumb linear search over the rgb values of the color
+     * mnemonics.  One could speed things up by sorting the rgb values and
+     * using a binary search, or building a hash table, etc...
+     */
+    for (i = 0, rgb = rgbn; i < rgbn_max; i++, rgb++)
+	if (red == rgb->r && green == rgb->g && blue == rgb->b)
+	    return rgb->name;
+
+    /* if not found return NULL */
+    return NULL;
+}
+
+/*
+ * Free the strings which have been malloc'ed in xpmReadRgbNames
+ */
+void
+xpmFreeRgbNames(rgbn, rgbn_max)
+    xpmRgbName rgbn[];
+    int rgbn_max;
+
+{
+    int i;
+    xpmRgbName *rgb;
+
+    for (i = 0, rgb = rgbn; i < rgbn_max; i++, rgb++)
+	XpmFree(rgb->name);
+}
+
+#else					/* here comes the MSW part, the
+					 * second part of the  huge ifdef */
+
+#include "rgbtab.h"			/* hard coded rgb.txt table */
+
+int
+xpmReadRgbNames(rgb_fname, rgbn)
+    char *rgb_fname;
+    xpmRgbName rgbn[];
+{
+    /*
+     * check for consistency???
+     * table has to be sorted for calls on strcasecmp
+     */
+    return (numTheRGBRecords);
+}
+
+/*
+ * MSW rgb values are made from 3 BYTEs, this is different from X XColor.red,
+ * which has something like #0303 for one color
+ */
+char *
+xpmGetRgbName(rgbn, rgbn_max, red, green, blue)
+    xpmRgbName rgbn[];			/* rgb mnemonics from rgb text file
+					 * not used */
+    int rgbn_max;			/* not used */
+    int red, green, blue;		/* rgb values */
+
+{
+    int i;
+    unsigned long rgbVal;
+
+    i = 0;
+    while (i < numTheRGBRecords) {
+	rgbVal = theRGBRecords[i].rgb;
+	if (GetRValue(rgbVal) == red &&
+	    GetGValue(rgbVal) == green &&
+	    GetBValue(rgbVal) == blue)
+	    return (theRGBRecords[i].name);
+	i++;
+    }
+    return (NULL);
+}
+
+/* used in XParseColor in simx.c */
+int
+xpmGetRGBfromName(inname, r, g, b)
+    char *inname;
+    int *r, *g, *b;
+{
+    int left, right, middle;
+    int cmp;
+    unsigned long rgbVal;
+    char *name;
+    char *grey, *p;
+
+    name = xpmstrdup(inname);
+
+    /*
+     * the table in rgbtab.c has no names with spaces, and no grey, but a
+     * lot of gray
+     */
+    /* so first extract ' ' */
+    while (p = strchr(name, ' ')) {
+	while (*(p)) {			/* till eof of string */
+	    *p = *(p + 1);		/* copy to the left */
+	    p++;
+	}
+    }
+    /* fold to lower case */
+    p = name;
+    while (*p) {
+	*p = tolower(*p);
+	p++;
+    }
+
+    /*
+     * substitute Grey with Gray, else rgbtab.h would have more than 100
+     * 'duplicate' entries
+     */
+    if (grey = strstr(name, "grey"))
+	grey[2] = 'a';
+
+    /* binary search */
+    left = 0;
+    right = numTheRGBRecords - 1;
+    do {
+	middle = (left + right) / 2;
+	cmp = xpmstrcasecmp(name, theRGBRecords[middle].name);
+	if (cmp == 0) {
+	    rgbVal = theRGBRecords[middle].rgb;
+	    *r = GetRValue(rgbVal);
+	    *g = GetGValue(rgbVal);
+	    *b = GetBValue(rgbVal);
+	    free(name);
+	    return (1);
+	} else if (cmp < 0) {
+	    right = middle - 1;
+	} else {			/* > 0 */
+	    left = middle + 1;
+	}
+    } while (left <= right);
+
+    /*
+     * I don't like to run in a ColorInvalid error and to see no pixmap at
+     * all, so simply return a red pixel. Should be wrapped in an #ifdef
+     * HeDu
+     */
+
+    *r = 255;
+    *g = 0;
+    *b = 0;				/* red error pixel */
+
+    free(name);
+    return (1);
+}
+
+void
+xpmFreeRgbNames(rgbn, rgbn_max)
+    xpmRgbName rgbn[];
+    int rgbn_max;
+
+{
+    /* nothing to do */
+}
+
+#endif					/* MSW part */
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/rgbtab.h rxvt-2.7.2/W11/xpm-3.4k/lib/rgbtab.h
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/rgbtab.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/rgbtab.h	Mon May 14 08:23:10 2001
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* rgbtab.h                                                                    *
+*                                                                             *
+* A hard coded rgb.txt. To keep it short I removed all colornames with        *
+* trailing numbers, Blue3 etc, except the GrayXX. Sorry Grey-lovers I prefer  *
+* Gray ;-). But Grey is recognized on lookups, only on save Gray will be      *
+* used, maybe you want to do some substitue there too.                        *
+*                                                                             *
+* To save memory the RGBs are coded in one long value, as done by the RGB     *
+* macro.                                                                      *
+*                                                                             *
+* Developed by HeDu 3/94 (hedu@cul-ipn.uni-kiel.de)                           *
+\*****************************************************************************/
+
+
+typedef struct {
+    char *name;
+    COLORREF rgb;			/* it's unsigned long */
+}      rgbRecord;
+
+/*
+#define myRGB(r,g,b) \
+	((unsigned long)r<<16|(unsigned long)g<<8|(unsigned long)b)
+*/
+#define myRGB(r,g,b)	RGB(r,g,b)	/* MSW has this macro */
+
+
+static rgbRecord theRGBRecords[] =
+{
+    {"AliceBlue", myRGB(240, 248, 255)},
+    {"AntiqueWhite", myRGB(250, 235, 215)},
+    {"Aquamarine", myRGB(50, 191, 193)},
+    {"Azure", myRGB(240, 255, 255)},
+    {"Beige", myRGB(245, 245, 220)},
+    {"Bisque", myRGB(255, 228, 196)},
+    {"Black", myRGB(0, 0, 0)},
+    {"BlanchedAlmond", myRGB(255, 235, 205)},
+    {"Blue", myRGB(0, 0, 255)},
+    {"BlueViolet", myRGB(138, 43, 226)},
+    {"Brown", myRGB(165, 42, 42)},
+    {"burlywood", myRGB(222, 184, 135)},
+    {"CadetBlue", myRGB(95, 146, 158)},
+    {"chartreuse", myRGB(127, 255, 0)},
+    {"chocolate", myRGB(210, 105, 30)},
+    {"Coral", myRGB(255, 114, 86)},
+    {"CornflowerBlue", myRGB(34, 34, 152)},
+    {"cornsilk", myRGB(255, 248, 220)},
+    {"Cyan", myRGB(0, 255, 255)},
+    {"DarkGoldenrod", myRGB(184, 134, 11)},
+    {"DarkGreen", myRGB(0, 86, 45)},
+    {"DarkKhaki", myRGB(189, 183, 107)},
+    {"DarkOliveGreen", myRGB(85, 86, 47)},
+    {"DarkOrange", myRGB(255, 140, 0)},
+    {"DarkOrchid", myRGB(139, 32, 139)},
+    {"DarkSalmon", myRGB(233, 150, 122)},
+    {"DarkSeaGreen", myRGB(143, 188, 143)},
+    {"DarkSlateBlue", myRGB(56, 75, 102)},
+    {"DarkSlateGray", myRGB(47, 79, 79)},
+    {"DarkTurquoise", myRGB(0, 166, 166)},
+    {"DarkViolet", myRGB(148, 0, 211)},
+    {"DeepPink", myRGB(255, 20, 147)},
+    {"DeepSkyBlue", myRGB(0, 191, 255)},
+    {"DimGray", myRGB(84, 84, 84)},
+    {"DodgerBlue", myRGB(30, 144, 255)},
+    {"Firebrick", myRGB(142, 35, 35)},
+    {"FloralWhite", myRGB(255, 250, 240)},
+    {"ForestGreen", myRGB(80, 159, 105)},
+    {"gainsboro", myRGB(220, 220, 220)},
+    {"GhostWhite", myRGB(248, 248, 255)},
+    {"Gold", myRGB(218, 170, 0)},
+    {"Goldenrod", myRGB(239, 223, 132)},
+    {"Gray", myRGB(126, 126, 126)},
+    {"Gray0", myRGB(0, 0, 0)},
+    {"Gray1", myRGB(3, 3, 3)},
+    {"Gray10", myRGB(26, 26, 26)},
+    {"Gray100", myRGB(255, 255, 255)},
+    {"Gray11", myRGB(28, 28, 28)},
+    {"Gray12", myRGB(31, 31, 31)},
+    {"Gray13", myRGB(33, 33, 33)},
+    {"Gray14", myRGB(36, 36, 36)},
+    {"Gray15", myRGB(38, 38, 38)},
+    {"Gray16", myRGB(41, 41, 41)},
+    {"Gray17", myRGB(43, 43, 43)},
+    {"Gray18", myRGB(46, 46, 46)},
+    {"Gray19", myRGB(48, 48, 48)},
+    {"Gray2", myRGB(5, 5, 5)},
+    {"Gray20", myRGB(51, 51, 51)},
+    {"Gray21", myRGB(54, 54, 54)},
+    {"Gray22", myRGB(56, 56, 56)},
+    {"Gray23", myRGB(59, 59, 59)},
+    {"Gray24", myRGB(61, 61, 61)},
+    {"Gray25", myRGB(64, 64, 64)},
+    {"Gray26", myRGB(66, 66, 66)},
+    {"Gray27", myRGB(69, 69, 69)},
+    {"Gray28", myRGB(71, 71, 71)},
+    {"Gray29", myRGB(74, 74, 74)},
+    {"Gray3", myRGB(8, 8, 8)},
+    {"Gray30", myRGB(77, 77, 77)},
+    {"Gray31", myRGB(79, 79, 79)},
+    {"Gray32", myRGB(82, 82, 82)},
+    {"Gray33", myRGB(84, 84, 84)},
+    {"Gray34", myRGB(87, 87, 87)},
+    {"Gray35", myRGB(89, 89, 89)},
+    {"Gray36", myRGB(92, 92, 92)},
+    {"Gray37", myRGB(94, 94, 94)},
+    {"Gray38", myRGB(97, 97, 97)},
+    {"Gray39", myRGB(99, 99, 99)},
+    {"Gray4", myRGB(10, 10, 10)},
+    {"Gray40", myRGB(102, 102, 102)},
+    {"Gray41", myRGB(105, 105, 105)},
+    {"Gray42", myRGB(107, 107, 107)},
+    {"Gray43", myRGB(110, 110, 110)},
+    {"Gray44", myRGB(112, 112, 112)},
+    {"Gray45", myRGB(115, 115, 115)},
+    {"Gray46", myRGB(117, 117, 117)},
+    {"Gray47", myRGB(120, 120, 120)},
+    {"Gray48", myRGB(122, 122, 122)},
+    {"Gray49", myRGB(125, 125, 125)},
+    {"Gray5", myRGB(13, 13, 13)},
+    {"Gray50", myRGB(127, 127, 127)},
+    {"Gray51", myRGB(130, 130, 130)},
+    {"Gray52", myRGB(133, 133, 133)},
+    {"Gray53", myRGB(135, 135, 135)},
+    {"Gray54", myRGB(138, 138, 138)},
+    {"Gray55", myRGB(140, 140, 140)},
+    {"Gray56", myRGB(143, 143, 143)},
+    {"Gray57", myRGB(145, 145, 145)},
+    {"Gray58", myRGB(148, 148, 148)},
+    {"Gray59", myRGB(150, 150, 150)},
+    {"Gray6", myRGB(15, 15, 15)},
+    {"Gray60", myRGB(153, 153, 153)},
+    {"Gray61", myRGB(156, 156, 156)},
+    {"Gray62", myRGB(158, 158, 158)},
+    {"Gray63", myRGB(161, 161, 161)},
+    {"Gray64", myRGB(163, 163, 163)},
+    {"Gray65", myRGB(166, 166, 166)},
+    {"Gray66", myRGB(168, 168, 168)},
+    {"Gray67", myRGB(171, 171, 171)},
+    {"Gray68", myRGB(173, 173, 173)},
+    {"Gray69", myRGB(176, 176, 176)},
+    {"Gray7", myRGB(18, 18, 18)},
+    {"Gray70", myRGB(179, 179, 179)},
+    {"Gray71", myRGB(181, 181, 181)},
+    {"Gray72", myRGB(184, 184, 184)},
+    {"Gray73", myRGB(186, 186, 186)},
+    {"Gray74", myRGB(189, 189, 189)},
+    {"Gray75", myRGB(191, 191, 191)},
+    {"Gray76", myRGB(194, 194, 194)},
+    {"Gray77", myRGB(196, 196, 196)},
+    {"Gray78", myRGB(199, 199, 199)},
+    {"Gray79", myRGB(201, 201, 201)},
+    {"Gray8", myRGB(20, 20, 20)},
+    {"Gray80", myRGB(204, 204, 204)},
+    {"Gray81", myRGB(207, 207, 207)},
+    {"Gray82", myRGB(209, 209, 209)},
+    {"Gray83", myRGB(212, 212, 212)},
+    {"Gray84", myRGB(214, 214, 214)},
+    {"Gray85", myRGB(217, 217, 217)},
+    {"Gray86", myRGB(219, 219, 219)},
+    {"Gray87", myRGB(222, 222, 222)},
+    {"Gray88", myRGB(224, 224, 224)},
+    {"Gray89", myRGB(227, 227, 227)},
+    {"Gray9", myRGB(23, 23, 23)},
+    {"Gray90", myRGB(229, 229, 229)},
+    {"Gray91", myRGB(232, 232, 232)},
+    {"Gray92", myRGB(235, 235, 235)},
+    {"Gray93", myRGB(237, 237, 237)},
+    {"Gray94", myRGB(240, 240, 240)},
+    {"Gray95", myRGB(242, 242, 242)},
+    {"Gray96", myRGB(245, 245, 245)},
+    {"Gray97", myRGB(247, 247, 247)},
+    {"Gray98", myRGB(250, 250, 250)},
+    {"Gray99", myRGB(252, 252, 252)},
+    {"Green", myRGB(0, 255, 0)},
+    {"GreenYellow", myRGB(173, 255, 47)},
+    {"honeydew", myRGB(240, 255, 240)},
+    {"HotPink", myRGB(255, 105, 180)},
+    {"IndianRed", myRGB(107, 57, 57)},
+    {"ivory", myRGB(255, 255, 240)},
+    {"Khaki", myRGB(179, 179, 126)},
+    {"lavender", myRGB(230, 230, 250)},
+    {"LavenderBlush", myRGB(255, 240, 245)},
+    {"LawnGreen", myRGB(124, 252, 0)},
+    {"LemonChiffon", myRGB(255, 250, 205)},
+    {"LightBlue", myRGB(176, 226, 255)},
+    {"LightCoral", myRGB(240, 128, 128)},
+    {"LightCyan", myRGB(224, 255, 255)},
+    {"LightGoldenrod", myRGB(238, 221, 130)},
+    {"LightGoldenrodYellow", myRGB(250, 250, 210)},
+    {"LightGray", myRGB(168, 168, 168)},
+    {"LightPink", myRGB(255, 182, 193)},
+    {"LightSalmon", myRGB(255, 160, 122)},
+    {"LightSeaGreen", myRGB(32, 178, 170)},
+    {"LightSkyBlue", myRGB(135, 206, 250)},
+    {"LightSlateBlue", myRGB(132, 112, 255)},
+    {"LightSlateGray", myRGB(119, 136, 153)},
+    {"LightSteelBlue", myRGB(124, 152, 211)},
+    {"LightYellow", myRGB(255, 255, 224)},
+    {"LimeGreen", myRGB(0, 175, 20)},
+    {"linen", myRGB(250, 240, 230)},
+    {"Magenta", myRGB(255, 0, 255)},
+    {"Maroon", myRGB(143, 0, 82)},
+    {"MediumAquamarine", myRGB(0, 147, 143)},
+    {"MediumBlue", myRGB(50, 50, 204)},
+    {"MediumForestGreen", myRGB(50, 129, 75)},
+    {"MediumGoldenrod", myRGB(209, 193, 102)},
+    {"MediumOrchid", myRGB(189, 82, 189)},
+    {"MediumPurple", myRGB(147, 112, 219)},
+    {"MediumSeaGreen", myRGB(52, 119, 102)},
+    {"MediumSlateBlue", myRGB(106, 106, 141)},
+    {"MediumSpringGreen", myRGB(35, 142, 35)},
+    {"MediumTurquoise", myRGB(0, 210, 210)},
+    {"MediumVioletRed", myRGB(213, 32, 121)},
+    {"MidnightBlue", myRGB(47, 47, 100)},
+    {"MintCream", myRGB(245, 255, 250)},
+    {"MistyRose", myRGB(255, 228, 225)},
+    {"moccasin", myRGB(255, 228, 181)},
+    {"NavajoWhite", myRGB(255, 222, 173)},
+    {"Navy", myRGB(35, 35, 117)},
+    {"NavyBlue", myRGB(35, 35, 117)},
+    {"OldLace", myRGB(253, 245, 230)},
+    {"OliveDrab", myRGB(107, 142, 35)},
+    {"Orange", myRGB(255, 135, 0)},
+    {"OrangeRed", myRGB(255, 69, 0)},
+    {"Orchid", myRGB(239, 132, 239)},
+    {"PaleGoldenrod", myRGB(238, 232, 170)},
+    {"PaleGreen", myRGB(115, 222, 120)},
+    {"PaleTurquoise", myRGB(175, 238, 238)},
+    {"PaleVioletRed", myRGB(219, 112, 147)},
+    {"PapayaWhip", myRGB(255, 239, 213)},
+    {"PeachPuff", myRGB(255, 218, 185)},
+    {"peru", myRGB(205, 133, 63)},
+    {"Pink", myRGB(255, 181, 197)},
+    {"Plum", myRGB(197, 72, 155)},
+    {"PowderBlue", myRGB(176, 224, 230)},
+    {"purple", myRGB(160, 32, 240)},
+    {"Red", myRGB(255, 0, 0)},
+    {"RosyBrown", myRGB(188, 143, 143)},
+    {"RoyalBlue", myRGB(65, 105, 225)},
+    {"SaddleBrown", myRGB(139, 69, 19)},
+    {"Salmon", myRGB(233, 150, 122)},
+    {"SandyBrown", myRGB(244, 164, 96)},
+    {"SeaGreen", myRGB(82, 149, 132)},
+    {"seashell", myRGB(255, 245, 238)},
+    {"Sienna", myRGB(150, 82, 45)},
+    {"SkyBlue", myRGB(114, 159, 255)},
+    {"SlateBlue", myRGB(126, 136, 171)},
+    {"SlateGray", myRGB(112, 128, 144)},
+    {"snow", myRGB(255, 250, 250)},
+    {"SpringGreen", myRGB(65, 172, 65)},
+    {"SteelBlue", myRGB(84, 112, 170)},
+    {"Tan", myRGB(222, 184, 135)},
+    {"Thistle", myRGB(216, 191, 216)},
+    {"tomato", myRGB(255, 99, 71)},
+    {"Transparent", myRGB(0, 0, 1)},
+    {"Turquoise", myRGB(25, 204, 223)},
+    {"Violet", myRGB(156, 62, 206)},
+    {"VioletRed", myRGB(243, 62, 150)},
+    {"Wheat", myRGB(245, 222, 179)},
+    {"White", myRGB(255, 255, 255)},
+    {"WhiteSmoke", myRGB(245, 245, 245)},
+    {"Yellow", myRGB(255, 255, 0)},
+    {"YellowGreen", myRGB(50, 216, 56)},
+    NULL
+};
+
+static int numTheRGBRecords = 234;
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/scan.c rxvt-2.7.2/W11/xpm-3.4k/lib/scan.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/scan.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/scan.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,1003 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* scan.c:                                                                     *
+*                                                                             *
+*  XPM library                                                                *
+*  Scanning utility for XPM file format                                       *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+/*
+ * The code related to AMIGA has been added by
+ * Lorens Younes (d93-hyo@nada.kth.se) 4/96
+ */
+
+#include "XpmI.h"
+
+#define MAXPRINTABLE 92			/* number of printable ascii chars
+					 * minus \ and " for string compat
+					 * and ? to avoid ANSI trigraphs. */
+
+static char *printable =
+" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjklzxcvbnmMNBVCZ\
+ASDFGHJKLPIUYTREWQ!~^/()_`'][{}|";
+
+/*
+ * printable begin with a space, so in most case, due to my algorithm, when
+ * the number of different colors is less than MAXPRINTABLE, it will give a
+ * char follow by "nothing" (a space) in the readable xpm file
+ */
+
+
+typedef struct {
+    Pixel *pixels;
+    unsigned int *pixelindex;
+    unsigned int size;
+    unsigned int ncolors;
+    unsigned int mask_pixel;		/* whether there is or not */
+}      PixelsMap;
+
+LFUNC(storePixel, int, (Pixel pixel, PixelsMap *pmap,
+			unsigned int *index_return));
+
+LFUNC(storeMaskPixel, int, (Pixel pixel, PixelsMap *pmap,
+			    unsigned int *index_return));
+
+#ifndef FOR_MSW
+# ifndef AMIGA
+LFUNC(GetImagePixels, int, (XImage *image, unsigned int width,
+			    unsigned int height, PixelsMap *pmap));
+
+LFUNC(GetImagePixels32, int, (XImage *image, unsigned int width,
+			      unsigned int height, PixelsMap *pmap));
+
+LFUNC(GetImagePixels16, int, (XImage *image, unsigned int width,
+			      unsigned int height, PixelsMap *pmap));
+
+LFUNC(GetImagePixels8, int, (XImage *image, unsigned int width,
+			     unsigned int height, PixelsMap *pmap));
+
+LFUNC(GetImagePixels1, int, (XImage *image, unsigned int width,
+			     unsigned int height, PixelsMap *pmap,
+			     int (*storeFunc) ()));
+# else /* AMIGA */
+LFUNC(AGetImagePixels, int, (XImage *image, unsigned int width,
+			     unsigned int height, PixelsMap *pmap,
+			     int (*storeFunc) ()));
+# endif/* AMIGA */
+#else  /* ndef FOR_MSW */
+LFUNC(MSWGetImagePixels, int, (Display *d, XImage *image, unsigned int width,
+			       unsigned int height, PixelsMap *pmap,
+			       int (*storeFunc) ()));
+#endif
+LFUNC(ScanTransparentColor, int, (XpmColor *color, unsigned int cpp,
+				  XpmAttributes *attributes));
+
+LFUNC(ScanOtherColors, int, (Display *display, XpmColor *colors, int ncolors,
+			     Pixel *pixels, unsigned int mask,
+			     unsigned int cpp, XpmAttributes *attributes));
+
+/*
+ * This function stores the given pixel in the given arrays which are grown
+ * if not large enough.
+ */
+static int
+storePixel(pixel, pmap, index_return)
+    Pixel pixel;
+    PixelsMap *pmap;
+    unsigned int *index_return;
+{
+    unsigned int i;
+    Pixel *p;
+    unsigned int ncolors;
+
+    if (*index_return) {		/* this is a transparent pixel! */
+	*index_return = 0;
+	return 0;
+    }
+    ncolors = pmap->ncolors;
+    p = pmap->pixels + pmap->mask_pixel;
+    for (i = pmap->mask_pixel; i < ncolors; i++, p++)
+	if (*p == pixel)
+	    break;
+    if (i == ncolors) {
+	if (ncolors >= pmap->size) {
+	    pmap->size *= 2;
+	    p = (Pixel *) XpmRealloc(pmap->pixels, sizeof(Pixel) * pmap->size);
+	    if (!p)
+		return (1);
+	    pmap->pixels = p;
+
+	}
+	(pmap->pixels)[ncolors] = pixel;
+	pmap->ncolors++;
+    }
+    *index_return = i;
+    return 0;
+}
+
+static int
+storeMaskPixel(pixel, pmap, index_return)
+    Pixel pixel;
+    PixelsMap *pmap;
+    unsigned int *index_return;
+{
+    if (!pixel) {
+	if (!pmap->ncolors) {
+	    pmap->ncolors = 1;
+	    (pmap->pixels)[0] = 0;
+	    pmap->mask_pixel = 1;
+	}
+	*index_return = 1;
+    } else
+	*index_return = 0;
+    return 0;
+}
+
+/* function call in case of error */
+#undef RETURN
+#define RETURN(status) \
+{ \
+      ErrorStatus = status; \
+      goto error; \
+}
+
+/*
+ * This function scans the given image and stores the found informations in
+ * the given XpmImage structure.
+ */
+int
+XpmCreateXpmImageFromImage(display, image, shapeimage,
+			   xpmimage, attributes)
+    Display *display;
+    XImage *image;
+    XImage *shapeimage;
+    XpmImage *xpmimage;
+    XpmAttributes *attributes;
+{
+    /* variables stored in the XpmAttributes structure */
+    unsigned int cpp;
+
+    /* variables to return */
+    PixelsMap pmap;
+    XpmColor *colorTable = NULL;
+    int ErrorStatus;
+
+    /* calculation variables */
+    unsigned int width = 0;
+    unsigned int height = 0;
+    unsigned int cppm;			/* minimum chars per pixel */
+    unsigned int c;
+
+    /* initialize pmap */
+    pmap.pixels = NULL;
+    pmap.pixelindex = NULL;
+    pmap.size = 256;			/* should be enough most of the time */
+    pmap.ncolors = 0;
+    pmap.mask_pixel = 0;
+
+    /*
+     * get geometry
+     */
+    if (image) {
+	width = image->width;
+	height = image->height;
+    } else if (shapeimage) {
+	width = shapeimage->width;
+	height = shapeimage->height;
+    }
+
+    /*
+     * retrieve information from the XpmAttributes
+     */
+    if (attributes && (attributes->valuemask & XpmCharsPerPixel
+/* 3.2 backward compatibility code */
+		       || attributes->valuemask & XpmInfos))
+/* end 3.2 bc */
+	cpp = attributes->cpp;
+    else
+	cpp = 0;
+
+    pmap.pixelindex =
+	(unsigned int *) XpmCalloc(width * height, sizeof(unsigned int));
+    if (!pmap.pixelindex)
+	RETURN(XpmNoMemory);
+
+    pmap.pixels = (Pixel *) XpmMalloc(sizeof(Pixel) * pmap.size);
+    if (!pmap.pixels)
+	RETURN(XpmNoMemory);
+
+    /*
+     * scan shape mask if any
+     */
+    if (shapeimage) {
+#ifndef FOR_MSW
+# ifndef AMIGA
+	ErrorStatus = GetImagePixels1(shapeimage, width, height, &pmap,
+				      storeMaskPixel);
+# else
+	ErrorStatus = AGetImagePixels(shapeimage, width, height, &pmap,
+				      storeMaskPixel);
+# endif
+#else
+	ErrorStatus = MSWGetImagePixels(display, shapeimage, width, height,
+					&pmap, storeMaskPixel);
+#endif
+	if (ErrorStatus != XpmSuccess)
+	    RETURN(ErrorStatus);
+    }
+
+    /*
+     * scan the image data
+     * 
+     * In case depth is 1 or bits_per_pixel is 4, 6, 8, 24 or 32 use optimized
+     * functions, otherwise use slower but sure general one.
+     * 
+     */
+
+    if (image) {
+#ifndef FOR_MSW
+# ifndef AMIGA
+	if (((image->bits_per_pixel | image->depth) == 1)  &&
+	    (image->byte_order == image->bitmap_bit_order))
+	    ErrorStatus = GetImagePixels1(image, width, height, &pmap,
+					  storePixel);
+	else if (image->format == ZPixmap) {
+	    if (image->bits_per_pixel == 8)
+		ErrorStatus = GetImagePixels8(image, width, height, &pmap);
+	    else if (image->bits_per_pixel == 16)
+		ErrorStatus = GetImagePixels16(image, width, height, &pmap);
+	    else if (image->bits_per_pixel == 32)
+		ErrorStatus = GetImagePixels32(image, width, height, &pmap);
+	} else
+	    ErrorStatus = GetImagePixels(image, width, height, &pmap);
+# else
+	ErrorStatus = AGetImagePixels(image, width, height, &pmap,
+				      storePixel);
+# endif
+#else
+	ErrorStatus = MSWGetImagePixels(display, image, width, height, &pmap,
+					storePixel);
+#endif
+	if (ErrorStatus != XpmSuccess)
+	    RETURN(ErrorStatus);
+    }
+
+    /*
+     * get rgb values and a string of char, and possibly a name for each
+     * color
+     */
+
+    colorTable = (XpmColor *) XpmCalloc(pmap.ncolors, sizeof(XpmColor));
+    if (!colorTable)
+	RETURN(XpmNoMemory);
+
+    /* compute the minimal cpp */
+    for (cppm = 1, c = MAXPRINTABLE; pmap.ncolors > c; cppm++)
+	c *= MAXPRINTABLE;
+    if (cpp < cppm)
+	cpp = cppm;
+
+    if (pmap.mask_pixel) {
+	ErrorStatus = ScanTransparentColor(colorTable, cpp, attributes);
+	if (ErrorStatus != XpmSuccess)
+	    RETURN(ErrorStatus);
+    }
+
+    ErrorStatus = ScanOtherColors(display, colorTable, pmap.ncolors,
+				  pmap.pixels, pmap.mask_pixel, cpp,
+				  attributes);
+    if (ErrorStatus != XpmSuccess)
+	RETURN(ErrorStatus);
+
+    /*
+     * store found informations in the XpmImage structure
+     */
+    xpmimage->width = width;
+    xpmimage->height = height;
+    xpmimage->cpp = cpp;
+    xpmimage->ncolors = pmap.ncolors;
+    xpmimage->colorTable = colorTable;
+    xpmimage->data = pmap.pixelindex;
+
+    XpmFree(pmap.pixels);
+    return (XpmSuccess);
+
+/* exit point in case of error, free only locally allocated variables */
+error:
+    if (pmap.pixelindex)
+	XpmFree(pmap.pixelindex);
+    if (pmap.pixels)
+	XpmFree(pmap.pixels);
+    if (colorTable)
+	xpmFreeColorTable(colorTable, pmap.ncolors);
+
+    return (ErrorStatus);
+}
+
+static int
+ScanTransparentColor(color, cpp, attributes)
+    XpmColor *color;
+    unsigned int cpp;
+    XpmAttributes *attributes;
+{
+    char *s;
+    unsigned int a, b, c;
+
+    /* first get a character string */
+    a = 0;
+    if (!(s = color->string = (char *) XpmMalloc(cpp + 1)))
+	return (XpmNoMemory);
+    *s++ = printable[c = a % MAXPRINTABLE];
+    for (b = 1; b < cpp; b++, s++)
+	*s = printable[c = ((a - c) / MAXPRINTABLE) % MAXPRINTABLE];
+    *s = '\0';
+
+    /* then retreive related info from the attributes if any */
+    if (attributes && (attributes->valuemask & XpmColorTable
+/* 3.2 backward compatibility code */
+		       || attributes->valuemask & XpmInfos)
+/* end 3.2 bc */
+	&& attributes->mask_pixel != XpmUndefPixel) {
+
+	unsigned int key;
+	char **defaults = (char **) color;
+	char **mask_defaults;
+
+/* 3.2 backward compatibility code */
+	if (attributes->valuemask & XpmColorTable)
+/* end 3.2 bc */
+	    mask_defaults = (char **) (
+		attributes->colorTable + attributes->mask_pixel);
+/* 3.2 backward compatibility code */
+	else
+	    mask_defaults = (char **)
+		((XpmColor **) attributes->colorTable)[attributes->mask_pixel];
+/* end 3.2 bc */
+	for (key = 1; key <= NKEYS; key++) {
+	    if (s = mask_defaults[key]) {
+		defaults[key] = (char *) xpmstrdup(s);
+		if (!defaults[key])
+		    return (XpmNoMemory);
+	    }
+	}
+    } else {
+	color->c_color = (char *) xpmstrdup(TRANSPARENT_COLOR);
+	if (!color->c_color)
+	    return (XpmNoMemory);
+    }
+    return (XpmSuccess);
+}
+
+static int
+ScanOtherColors(display, colors, ncolors, pixels, mask, cpp, attributes)
+    Display *display;
+    XpmColor *colors;
+    int ncolors;
+    Pixel *pixels;
+    unsigned int mask;
+    unsigned int cpp;
+    XpmAttributes *attributes;
+{
+    /* variables stored in the XpmAttributes structure */
+    Colormap colormap;
+    char *rgb_fname;
+
+#ifndef FOR_MSW
+    xpmRgbName rgbn[MAX_RGBNAMES];
+#else
+    xpmRgbName *rgbn = NULL; 
+#endif    
+    int rgbn_max = 0;
+    unsigned int i, j, c, i2;
+    XpmColor *color;
+    XColor *xcolors = NULL, *xcolor;
+    char *colorname, *s;
+    XpmColor *colorTable, **oldColorTable = NULL;
+    unsigned int ancolors = 0;
+    Pixel *apixels;
+    unsigned int mask_pixel;
+    Bool found;
+
+    /* retrieve information from the XpmAttributes */
+    if (attributes && (attributes->valuemask & XpmColormap))
+	colormap = attributes->colormap;
+    else
+	colormap = XDefaultColormap(display, XDefaultScreen(display));
+    if (attributes && (attributes->valuemask & XpmRgbFilename))
+	rgb_fname = attributes->rgb_fname;
+    else
+	rgb_fname = NULL;
+
+    /* start from the right element */
+    if (mask) {
+	colors++;
+	ncolors--;
+	pixels++;
+    }
+
+    /* first get character strings and rgb values */
+    xcolors = (XColor *) XpmMalloc(sizeof(XColor) * ncolors);
+    if (!xcolors)
+	return (XpmNoMemory);
+
+    for (i = 0, i2 = mask, color = colors, xcolor = xcolors;
+	 i < ncolors; i++, i2++, color++, xcolor++, pixels++) {
+
+	if (!(s = color->string = (char *) XpmMalloc(cpp + 1))) {
+	    XpmFree(xcolors);
+	    return (XpmNoMemory);
+	}
+	*s++ = printable[c = i2 % MAXPRINTABLE];
+	for (j = 1; j < cpp; j++, s++)
+	    *s = printable[c = ((i2 - c) / MAXPRINTABLE) % MAXPRINTABLE];
+	*s = '\0';
+
+	xcolor->pixel = *pixels;
+    }
+    XQueryColors(display, colormap, xcolors, ncolors);
+
+#ifndef FOR_MSW
+    /* read the rgb file if any was specified */
+    if (rgb_fname)
+	rgbn_max = xpmReadRgbNames(attributes->rgb_fname, rgbn);
+#else
+    /* FOR_MSW: rgb names and values are hardcoded in rgbtab.h */
+    rgbn_max = xpmReadRgbNames(NULL, NULL);
+#endif
+
+    if (attributes && attributes->valuemask & XpmColorTable) {
+	colorTable = attributes->colorTable;
+	ancolors = attributes->ncolors;
+	apixels = attributes->pixels;
+	mask_pixel = attributes->mask_pixel;
+    }
+/* 3.2 backward compatibility code */
+    else if (attributes && attributes->valuemask & XpmInfos) {
+	oldColorTable = (XpmColor **) attributes->colorTable;
+	ancolors = attributes->ncolors;
+	apixels = attributes->pixels;
+	mask_pixel = attributes->mask_pixel;
+    }
+/* end 3.2 bc */
+
+    for (i = 0, color = colors, xcolor = xcolors; i < ncolors;
+						  i++, color++, xcolor++) {
+
+	/* look for related info from the attributes if any */
+	found = False;
+	if (ancolors) {
+	    unsigned int offset = 0;
+
+	    for (j = 0; j < ancolors; j++) {
+		if (j == mask_pixel) {
+		    offset = 1;
+		    continue;
+		}
+		if (apixels[j - offset] == xcolor->pixel)
+		    break;
+	    }
+	    if (j != ancolors) {
+		unsigned int key;
+		char **defaults = (char **) color;
+		char **adefaults;
+
+/* 3.2 backward compatibility code */
+		if (oldColorTable)
+		    adefaults = (char **) oldColorTable[j];
+		else
+/* end 3.2 bc */
+		    adefaults = (char **) (colorTable + j);
+
+		found = True;
+		for (key = 1; key <= NKEYS; key++) {
+		    if (s = adefaults[key])
+			defaults[key] = (char *) xpmstrdup(s);
+		}
+	    }
+	}
+	if (!found) {
+	    /* if nothing found look for a color name */
+	    colorname = NULL;
+	    if (rgbn_max)
+		colorname = xpmGetRgbName(rgbn, rgbn_max, xcolor->red,
+					  xcolor->green, xcolor->blue);
+	    if (colorname)
+		color->c_color = (char *) xpmstrdup(colorname);
+	    else {
+		/* at last store the rgb value */
+		char buf[BUFSIZ];
+#ifndef FOR_MSW
+		sprintf(buf, "#%04X%04X%04X",
+			xcolor->red, xcolor->green, xcolor->blue);
+#else   
+		sprintf(buf, "#%02x%02x%02x",
+			xcolor->red, xcolor->green, xcolor->blue);
+#endif			
+		color->c_color = (char *) xpmstrdup(buf);
+	    }
+	    if (!color->c_color) {
+		XpmFree(xcolors);
+		xpmFreeRgbNames(rgbn, rgbn_max);
+		return (XpmNoMemory);
+	    }
+	}
+    }
+
+    XpmFree(xcolors);
+    xpmFreeRgbNames(rgbn, rgbn_max);
+    return (XpmSuccess);
+}
+
+#ifndef FOR_MSW
+# ifndef AMIGA
+/*
+ * The functions below are written from X11R5 MIT's code (XImUtil.c)
+ *
+ * The idea is to have faster functions than the standard XGetPixel function
+ * to scan the image data. Indeed we can speed up things by suppressing tests
+ * performed for each pixel. We do exactly the same tests but at the image
+ * level.
+ */
+
+static unsigned long Const low_bits_table[] = {
+    0x00000000, 0x00000001, 0x00000003, 0x00000007,
+    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
+    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
+    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
+    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
+    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
+    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
+    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
+    0xffffffff
+};
+
+/*
+ * Default method to scan pixels of an image data structure.
+ * The algorithm used is:
+ *
+ *	copy the source bitmap_unit or Zpixel into temp
+ *	normalize temp if needed
+ *	extract the pixel bits into return value
+ *
+ */
+
+static int
+GetImagePixels(image, width, height, pmap)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    PixelsMap *pmap;
+{
+    char *src;
+    char *dst;
+    unsigned int *iptr;
+    char *data;
+    int x, y, i;
+    int bits, depth, ibu, ibpp, offset;
+    unsigned long lbt;
+    Pixel pixel, px;
+
+    data = image->data;
+    iptr = pmap->pixelindex;
+    depth = image->depth;
+    lbt = low_bits_table[depth];
+    ibpp = image->bits_per_pixel;
+    offset = image->xoffset;
+
+    if ((image->bits_per_pixel | image->depth) == 1) {
+	ibu = image->bitmap_unit;
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		src = &data[XYINDEX(x, y, image)];
+		dst = (char *) &pixel;
+		pixel = 0;
+		for (i = ibu >> 3; --i >= 0;)
+		    *dst++ = *src++;
+		XYNORMALIZE(&pixel, image);
+		bits = (x + offset) % ibu;
+		pixel = ((((char *) &pixel)[bits >> 3]) >> (bits & 7)) & 1;
+		if (ibpp != depth)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    } else if (image->format == XYPixmap) {
+	int nbytes, bpl, j;
+	long plane = 0;
+	ibu = image->bitmap_unit;
+	nbytes = ibu >> 3;
+	bpl = image->bytes_per_line;
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		pixel = 0;
+		plane = 0;
+		for (i = depth; --i >= 0;) {
+		    src = &data[XYINDEX(x, y, image) + plane];
+		    dst = (char *) &px;
+		    px = 0;
+		    for (j = nbytes; --j >= 0;)
+			*dst++ = *src++;
+		    XYNORMALIZE(&px, image);
+		    bits = (x + offset) % ibu;
+		    pixel = (pixel << 1) |
+			    (((((char *) &px)[bits >> 3]) >> (bits & 7)) & 1);
+		    plane = plane + (bpl * height);
+		}
+		if (ibpp != depth)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    } else if (image->format == ZPixmap) {
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		src = &data[ZINDEX(x, y, image)];
+		dst = (char *) &px;
+		px = 0;
+		for (i = (ibpp + 7) >> 3; --i >= 0;)
+		    *dst++ = *src++;
+		ZNORMALIZE(&px, image);
+		pixel = 0;
+		for (i = sizeof(unsigned long); --i >= 0;)
+		    pixel = (pixel << 8) | ((unsigned char *) &px)[i];
+		if (ibpp == 4) {
+		    if (x & 1)
+			pixel >>= 4;
+		    else
+			pixel &= 0xf;
+		}
+		if (ibpp != depth)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    } else
+	return (XpmColorError); /* actually a bad image */
+    return (XpmSuccess);
+}
+
+/*
+ * scan pixels of a 32-bits Z image data structure
+ */
+
+#if !defined(WORD64) && !defined(LONG64)
+static unsigned long byteorderpixel = MSBFirst << 24;
+#endif
+
+static int
+GetImagePixels32(image, width, height, pmap)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    PixelsMap *pmap;
+{
+    unsigned char *addr;
+    unsigned char *data;
+    unsigned int *iptr;
+    int x, y;
+    unsigned long lbt;
+    Pixel pixel;
+    int depth;
+
+    data = (unsigned char *) image->data;
+    iptr = pmap->pixelindex;
+    depth = image->depth;
+    lbt = low_bits_table[depth];
+#if !defined(WORD64) && !defined(LONG64)
+    if (*((char *) &byteorderpixel) == image->byte_order) {
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX32(x, y, image)];
+		pixel = *((unsigned long *) addr);
+		if (depth != 32)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    } else
+#endif
+    if (image->byte_order == MSBFirst)
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX32(x, y, image)];
+		pixel = ((unsigned long) addr[0] << 24 |
+			 (unsigned long) addr[1] << 16 |
+			 (unsigned long) addr[2] << 8 |
+			 addr[3]);
+		if (depth != 32)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    else
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX32(x, y, image)];
+		pixel = (addr[0] |
+			 (unsigned long) addr[1] << 8 |
+			 (unsigned long) addr[2] << 16 |
+			 (unsigned long) addr[3] << 24);
+		if (depth != 32)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    return (XpmSuccess);
+}
+
+/*
+ * scan pixels of a 16-bits Z image data structure
+ */
+
+static int
+GetImagePixels16(image, width, height, pmap)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    PixelsMap *pmap;
+{
+    unsigned char *addr;
+    unsigned char *data;
+    unsigned int *iptr;
+    int x, y;
+    unsigned long lbt;
+    Pixel pixel;
+    int depth;
+
+    data = (unsigned char *) image->data;
+    iptr = pmap->pixelindex;
+    depth = image->depth;
+    lbt = low_bits_table[depth];
+    if (image->byte_order == MSBFirst)
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX16(x, y, image)];
+		pixel = addr[0] << 8 | addr[1];
+		if (depth != 16)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    else
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		addr = &data[ZINDEX16(x, y, image)];
+		pixel = addr[0] | addr[1] << 8;
+		if (depth != 16)
+		    pixel &= lbt;
+		if (storePixel(pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    return (XpmSuccess);
+}
+
+/*
+ * scan pixels of a 8-bits Z image data structure
+ */
+
+static int
+GetImagePixels8(image, width, height, pmap)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    PixelsMap *pmap;
+{
+    unsigned int *iptr;
+    unsigned char *data;
+    int x, y;
+    unsigned long lbt;
+    Pixel pixel;
+    int depth;
+
+    data = (unsigned char *) image->data;
+    iptr = pmap->pixelindex;
+    depth = image->depth;
+    lbt = low_bits_table[depth];
+    for (y = 0; y < height; y++)
+	for (x = 0; x < width; x++, iptr++) {
+	    pixel = data[ZINDEX8(x, y, image)];
+	    if (depth != 8)
+		pixel &= lbt;
+	    if (storePixel(pixel, pmap, iptr))
+		return (XpmNoMemory);
+	}
+    return (XpmSuccess);
+}
+
+/*
+ * scan pixels of a 1-bit depth Z image data structure
+ */
+
+static int
+GetImagePixels1(image, width, height, pmap, storeFunc)
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    PixelsMap *pmap;
+    int (*storeFunc) ();
+{
+    unsigned int *iptr;
+    int x, y;
+    char *data;
+    Pixel pixel;
+    int xoff, yoff, offset, bpl;
+
+    data = image->data;
+    iptr = pmap->pixelindex;
+    offset = image->xoffset;
+    bpl = image->bytes_per_line;
+
+    if (image->bitmap_bit_order == MSBFirst)
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		xoff = x + offset;
+		yoff = y * bpl + (xoff >> 3);
+		xoff &= 7;
+		pixel = (data[yoff] & (0x80 >> xoff)) ? 1 : 0;
+		if ((*storeFunc) (pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    else
+	for (y = 0; y < height; y++)
+	    for (x = 0; x < width; x++, iptr++) {
+		xoff = x + offset;
+		yoff = y * bpl + (xoff >> 3);
+		xoff &= 7;
+		pixel = (data[yoff] & (1 << xoff)) ? 1 : 0;
+		if ((*storeFunc) (pixel, pmap, iptr))
+		    return (XpmNoMemory);
+	    }
+    return (XpmSuccess);
+}
+
+# else /* AMIGA */
+
+#define CLEAN_UP(status) \
+{\
+    if (pixels) XpmFree (pixels);\
+    if (tmp_img) FreeXImage (tmp_img);\
+    return (status);\
+}
+
+static int
+AGetImagePixels (
+    XImage        *image,
+    unsigned int   width,
+    unsigned int   height,
+    PixelsMap     *pmap,
+    int          (*storeFunc) ())
+{
+    unsigned int   *iptr;
+    unsigned int    x, y;
+    unsigned char  *pixels;
+    XImage         *tmp_img;
+    
+    pixels = XpmMalloc ((((width+15)>>4)<<4)*sizeof (*pixels));
+    if (pixels == NULL)
+	return XpmNoMemory;
+    
+    tmp_img = AllocXImage ((((width+15)>>4)<<4), 1, image->rp->BitMap->Depth);
+    if (tmp_img == NULL)
+	CLEAN_UP (XpmNoMemory)
+    
+    iptr = pmap->pixelindex;
+    for (y = 0; y < height; ++y)
+    {
+	ReadPixelLine8 (image->rp, 0, y, width, pixels, tmp_img->rp);
+	for (x = 0; x < width; ++x, ++iptr)
+	{
+	    if ((*storeFunc) (pixels[x], pmap, iptr))
+		CLEAN_UP (XpmNoMemory)
+	}
+    }
+    
+    CLEAN_UP (XpmSuccess)
+}
+
+#undef CLEAN_UP
+
+# endif/* AMIGA */
+#else  /* ndef FOR_MSW */
+static int
+MSWGetImagePixels(display, image, width, height, pmap, storeFunc)
+    Display *display;
+    XImage *image;
+    unsigned int width;
+    unsigned int height;
+    PixelsMap *pmap;
+    int (*storeFunc) ();
+{
+    unsigned int *iptr;
+    unsigned int x, y;
+    Pixel pixel;
+
+    iptr = pmap->pixelindex;
+
+    SelectObject(*display, image->bitmap);
+    for (y = 0; y < height; y++) {
+	for (x = 0; x < width; x++, iptr++) {
+	    pixel = GetPixel(*display, x, y);
+	    if ((*storeFunc) (pixel, pmap, iptr))
+		return (XpmNoMemory);
+	}
+    }
+    return (XpmSuccess);
+}
+
+#endif
+
+#ifndef FOR_MSW
+# ifndef AMIGA
+int
+XpmCreateXpmImageFromPixmap(display, pixmap, shapemask,
+			    xpmimage, attributes)
+    Display *display;
+    Pixmap pixmap;
+    Pixmap shapemask;
+    XpmImage *xpmimage;
+    XpmAttributes *attributes;
+{
+    XImage *ximage = NULL;
+    XImage *shapeimage = NULL;
+    unsigned int width = 0;
+    unsigned int height = 0;
+    int ErrorStatus;
+
+    /* get geometry */
+    if (attributes && attributes->valuemask & XpmSize) {
+	width = attributes->width;
+	height = attributes->height;
+    }
+    /* get the ximages */
+    if (pixmap)
+	xpmCreateImageFromPixmap(display, pixmap, &ximage, &width, &height);
+    if (shapemask)
+	xpmCreateImageFromPixmap(display, shapemask, &shapeimage,
+				 &width, &height);
+
+    /* create the related XpmImage */
+    ErrorStatus = XpmCreateXpmImageFromImage(display, ximage, shapeimage,
+					     xpmimage, attributes);
+
+    /* destroy the ximages */
+    if (ximage)
+	XDestroyImage(ximage);
+    if (shapeimage)
+	XDestroyImage(shapeimage);
+
+    return (ErrorStatus);
+}
+
+# endif/* not AMIGA */
+#endif /* ndef FOR_MSW */
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/simx.c rxvt-2.7.2/W11/xpm-3.4k/lib/simx.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/simx.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/simx.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* simx.c: 0.1a                                                                *
+*                                                                             *
+* This emulates some Xlib functionality for MSW. It's not a general solution, *
+* it is close related to XPM-lib. It is only intended to satisfy what is need *
+* there. Thus allowing to read XPM files under MS windows.                    *
+*                                                                             *
+* Developed by HeDu 3/94 (hedu@cul-ipn.uni-kiel.de)                           *
+\*****************************************************************************/
+
+#ifdef FOR_MSW
+
+#include "xpm.h"
+#include "xpmi.h"			/* for XpmMalloc */
+
+/*
+ * On DOS size_t is only 2 bytes, thus malloc(size_t s) can only malloc
+ * 64K. BUT an expression data=malloc(width*height) may result in an
+ * overflow. So this function takes a long as input, and returns NULL if the
+ * request is larger than 64K, is size_t is only 2 bytes.
+ *
+ * This requires casts like XpmMalloc( (long)width*(long(height)), else it
+ * might have no effect at all.
+ */
+
+void *
+boundCheckingMalloc(long s)
+{
+    if (sizeof(size_t) == sizeof(long)) {	/* same size, just do it */
+	return (malloc((size_t) s));
+    } else {
+	if (sizeof(size_t) == 2) {
+	    if (s > 0xFFFF)
+		return (NULL);		/* to large, size_t with 2 bytes
+					 * only allows 16 bits */
+	    else
+		return (malloc((size_t) s));
+	} else {			/* it's not a long, not 2 bytes,
+					 * what is it ??? */
+	    return (malloc((size_t) s));
+	}
+    }
+}
+void *
+boundCheckingCalloc(long num, long s)
+{
+    if (sizeof(size_t) == sizeof(long)) {	/* same size, just do it */
+	return (calloc((size_t) num, (size_t) s));
+    } else {
+	if (sizeof(size_t) == 2) {
+	    if (s > 0xFFFF || num * s > 0xFFFF)
+		return (NULL);		/* to large, size_t with 2 bytes
+					 * only allows 16 bits */
+	    else
+		return (calloc((size_t) num, (size_t) s));
+	} else {			/* it's not a long, not 2 bytes,
+					 * what is it ??? */
+	    return (calloc((size_t) num, (size_t) s));
+	}
+    }
+}
+void *
+boundCheckingRealloc(void *p, long s)
+{
+    if (sizeof(size_t) == sizeof(long)) {	/* same size, just do it */
+	return (realloc(p, (size_t) s));
+    } else {
+	if (sizeof(size_t) == 2) {
+	    if (s > 0xFFFF)
+		return (NULL);		/* to large, size_t with 2 bytes
+					 * only allows 16 bits */
+	    else
+		return (realloc(p, (size_t) s));
+	} else {			/* it's not a long, not 2 bytes,
+					 * what is it ??? */
+	    return (realloc(p, (size_t) s));
+	}
+    }
+}
+
+/* static Visual theVisual = { 0 }; */
+Visual *
+XDefaultVisual(Display *display, Screen *screen)
+{
+    return (NULL);			/* struct could contain info about
+					 * MONO, GRAY, COLOR */
+}
+
+Screen *
+XDefaultScreen(Display *d)
+{
+    return (NULL);
+}
+
+/* I get only 1 plane but 8 bits per pixel,
+   so I think BITSPIXEL should be depth */
+int 
+XDefaultDepth(Display *display, Screen *screen)
+{
+    int d, b;
+
+    b = GetDeviceCaps(*display, BITSPIXEL);
+    d = GetDeviceCaps(*display, PLANES);
+    return (b);
+}
+
+Colormap *
+XDefaultColormap(Display *display, Screen *screen)
+{
+    return (NULL);
+}
+
+/* convert hex color names,
+   wrong digits (not a-f,A-F,0-9) are treated as zero */
+static int 
+hexCharToInt(c)
+{
+    int r;
+
+    if (c >= '0' && c <= '9')
+	r = c - '0';
+    else if (c >= 'a' && c <= 'f')
+	r = c - 'a' + 10;
+    else if (c >= 'A' && c <= 'F')
+	r = c - 'A' + 10;
+    else
+	r = 0;
+
+    return (r);
+}
+
+static int 
+rgbFromHex(char *hex, int *r, int *g, int *b)
+{
+    int len;
+
+    if (hex == NULL || hex[0] != '#')
+	return (0);
+
+    len = strlen(hex);
+    if (len == 3 + 1) {
+	*r = hexCharToInt(hex[1]);
+	*g = hexCharToInt(hex[2]);
+	*b = hexCharToInt(hex[3]);
+    } else if (len == 6 + 1) {
+	*r = hexCharToInt(hex[1]) * 16 + hexCharToInt(hex[2]);
+	*g = hexCharToInt(hex[3]) * 16 + hexCharToInt(hex[4]);
+	*b = hexCharToInt(hex[5]) * 16 + hexCharToInt(hex[6]);
+    } else if (len == 12 + 1) {
+	/* it's like c #32329999CCCC */
+	/* so for now only take two digits */
+	*r = hexCharToInt(hex[1]) * 16 + hexCharToInt(hex[2]);
+	*g = hexCharToInt(hex[5]) * 16 + hexCharToInt(hex[6]);
+	*b = hexCharToInt(hex[9]) * 16 + hexCharToInt(hex[10]);
+    } else
+	return (0);
+
+    return (1);
+}
+
+/* Color related functions */
+int 
+XParseColor(Display *d, Colormap *cmap, char *name, XColor *color)
+{
+    int r, g, b;			/* only 8 bit values used */
+    int okay;
+
+/* TODO: use colormap via PALETTE */
+    /* parse name either in table or #RRGGBB #RGB */
+    if (name == NULL)
+	return (0);
+
+    if (name[0] == '#') {		/* a hex string */
+	okay = rgbFromHex(name, &r, &g, &b);
+    } else {
+	okay = xpmGetRGBfromName(name, &r, &g, &b);
+    }
+
+    if (okay) {
+	color->pixel = RGB(r, g, b);
+	color->red = (BYTE) r;
+	color->green = (BYTE) g;
+	color->blue = (BYTE) b;
+	return (1);
+    } else
+	return (0);			/* --> ColorError */
+}
+
+
+int 
+XAllocColor(Display *d, Colormap cmap, XColor *color)
+{
+/* colormap not used yet so color->pixel is the real COLORREF (RBG) and not an
+   index in some colormap as in X */
+    return (1);
+}
+void 
+XQueryColors(Display *display, Colormap *colormap,
+	     XColor *xcolors, int ncolors)
+{
+/* under X this fills the rgb values to given .pixel */
+/* since there no colormap use FOR_MSW (not yet!!), rgb is plain encoded */
+    XColor *xc = xcolors;
+    int i;
+
+    for (i = 0; i < ncolors; i++, xc++) {
+	xc->red = GetRValue(xc->pixel);
+	xc->green = GetGValue(xc->pixel);
+	xc->blue = GetBValue(xc->pixel);
+    }
+    return;
+}
+int 
+XFreeColors(Display *d, Colormap cmap,
+	    unsigned long pixels[], int npixels, unsigned long planes)
+{
+    /* no colormap yet */
+    return (0);				/* correct ??? */
+}
+
+/* XImage functions */
+XImage *
+XCreateImage(Display *d, Visual *v,
+	     int depth, int format,
+	     int x, int y, int width, int height,
+	     int pad, int foo)
+{
+    XImage *img = (XImage *) XpmMalloc(sizeof(XImage));
+
+    if (img) {
+	/*JW: This is what it should be, but the picture comes out
+	      just black!?  It appears to be doing monochrome reduction,
+	      but I've got no clue why.  Using CreateBitmap() is supposed
+	      to be slower, but otherwise ok
+	  if ( depth == GetDeviceCaps(*d, BITSPIXEL) ) {
+	    img->bitmap = CreateCompatibleBitmap(*d, width, height);
+        } else*/ {
+	    img->bitmap = CreateBitmap(width, height, 1 /* plane */ ,
+				       depth /* bits per pixel */ , NULL);
+	}
+	img->width = width;
+	img->height = height;
+	img->depth = depth;
+    }
+    return (img);
+
+}
+
+void 
+XImageFree(XImage *img)
+{
+    if (img) {
+	XpmFree(img);
+    }
+}
+void 
+XDestroyImage(XImage *img)
+{
+    if (img) {
+	DeleteObject(img->bitmap);	/* check return ??? */
+	XImageFree(img);
+    }
+}
+
+#endif
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/simx.h rxvt-2.7.2/W11/xpm-3.4k/lib/simx.h
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/simx.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/simx.h	Mon May 14 08:23:10 2001
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* simx.h: 0.1a                                                                *
+*                                                                             *
+* This emulates some Xlib functionality for MSW. It's not a general solution, *
+* it is close related to XPM-lib. It is only intended to satisfy what is need *
+* there. Thus allowing to read XPM files under MS windows.                    *
+*                                                                             *
+* Developed by HeDu 3/94 (hedu@cul-ipn.uni-kiel.de)                           *
+\*****************************************************************************/
+
+
+#ifndef _SIMX_H
+#define _SIMX_H
+
+#ifdef FOR_MSW
+
+#include "windows.h"			/* MS windows GDI types */
+
+/*
+ * minimal portability layer between ansi and KR C
+ */
+/* this comes from xpm.h, and is here again, to avoid complicated
+    includes, since this is included from xpm.h */
+/* these defines get undefed at the end of this file */
+#if __STDC__ || defined(__cplusplus) || defined(c_plusplus)
+ /* ANSI || C++ */
+#define FUNC(f, t, p) extern t f p
+#define LFUNC(f, t, p) static t f p
+#else /* k&R */
+#define FUNC(f, t, p) extern t f()
+#define LFUNC(f, t, p) static t f()
+#endif
+
+
+FUNC(boundCheckingMalloc, void *, (long s));
+FUNC(boundCheckingCalloc, void *, (long num, long s));
+FUNC(boundCheckingRealloc, void *, (void *p, long s));
+
+/* define MSW types for X window types,
+   I don't know much about MSW, but the following defines do the job */
+
+typedef HDC Display;			/* this should be similar */
+typedef void *Screen;			/* not used */
+typedef void *Visual;			/* not used yet, is for GRAY, COLOR,
+					 * MONO */
+
+typedef void *Colormap;			/* should be COLORPALETTE, not done
+					 * yet */
+
+typedef COLORREF Pixel;
+
+#define PIXEL_ALREADY_TYPEDEFED		/* to let xpm.h know about it */
+
+typedef struct {
+    Pixel pixel;
+    BYTE red, green, blue;
+}      XColor;
+
+typedef struct {
+    HBITMAP bitmap;
+    unsigned int width;
+    unsigned int height;
+    unsigned int depth;
+}      XImage;
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+/* some replacements for X... functions */
+
+/* XDefaultXXX */
+    FUNC(XDefaultVisual, Visual *, (Display *display, Screen *screen));
+    FUNC(XDefaultScreen, Screen *, (Display *d));
+    FUNC(XDefaultColormap, Colormap *, (Display *display, Screen *screen));
+    FUNC(XDefaultDepth, int, (Display *d, Screen *s));
+
+/* color related */
+    FUNC(XParseColor, int, (Display *, Colormap *, char *, XColor *));
+    FUNC(XAllocColor, int, (Display *, Colormap *, XColor *));
+    FUNC(XQueryColors, void, (Display *display, Colormap *colormap,
+			      XColor *xcolors, int ncolors));
+    FUNC(XFreeColors, int, (Display *d, Colormap cmap,
+			    unsigned long pixels[],
+			    int npixels, unsigned long planes));
+/* XImage */
+    FUNC(XCreateImage, XImage *, (Display *, Visual *, int depth, int format,
+				  int x, int y, int width, int height,
+				  int pad, int foo));
+
+/* free and destroy bitmap */
+    FUNC(XDestroyImage, void /* ? */ , (XImage *));
+/* free only, bitmap remains */
+    FUNC(XImageFree, void, (XImage *));
+#if defined(__cplusplus) || defined(c_plusplus)
+} /* end of extern "C" */
+#endif /* cplusplus */
+
+#define ZPixmap 1			/* not really used */
+#define XYBitmap 1			/* not really used */
+
+#ifndef True
+#define True 1
+#define False 0
+#endif
+#ifndef Bool
+typedef BOOL Bool;		/* take MSW bool */
+#endif
+/* make these local here, simx.c gets the same from xpm.h */
+#undef LFUNC
+#undef FUNC
+
+#endif /* def FOR_MSW */
+
+#endif /* _SIMX_H */
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/lib/xpm.h rxvt-2.7.2/W11/xpm-3.4k/lib/xpm.h
--- rxvt-2.7.2-orig/W11/xpm-3.4k/lib/xpm.h	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/lib/xpm.h	Mon May 14 08:23:10 2001
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* xpm.h:                                                                      *
+*                                                                             *
+*  XPM library                                                                *
+*  Include file                                                               *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+/*
+ * The code related to FOR_MSW has been added by
+ * HeDu (hedu@cul-ipn.uni-kiel.de) 4/94
+ */
+
+/*
+ * The code related to AMIGA has been added by
+ * Lorens Younes (d93-hyo@nada.kth.se) 4/96
+ */
+
+#ifndef XPM_h
+#define XPM_h
+
+/*
+ * first some identification numbers:
+ * the version and revision numbers are determined with the following rule:
+ * SO Major number = LIB minor version number.
+ * SO Minor number = LIB sub-minor version number.
+ * e.g: Xpm version 3.2f
+ *      we forget the 3 which is the format number, 2 gives 2, and f gives 6.
+ *      thus we have XpmVersion = 2 and XpmRevision = 6
+ *      which gives  SOXPMLIBREV = 2.6
+ *
+ * Then the XpmIncludeVersion number is built from these numbers.
+ */
+#define XpmFormat 3
+#define XpmVersion 4
+#define XpmRevision 11
+#define XpmIncludeVersion ((XpmFormat * 100 + XpmVersion) * 100 + XpmRevision)
+
+#ifndef XPM_NUMBERS
+
+#ifdef FOR_MSW
+# define SYSV			/* uses memcpy string.h etc. */
+# include <malloc.h>
+# include "simx.h"		/* defines some X stuff using MSW types */
+#define NEED_STRCASECMP		/* at least for MSVC++ */
+#else /* FOR_MSW */
+# ifdef AMIGA
+#  include "amigax.h"
+# else /* not AMIGA */
+#  include <X11/Xlib.h>
+#  include <X11/Xutil.h>
+# endif /* not AMIGA */
+#endif /* FOR_MSW */
+
+/* let's define Pixel if it is not done yet */
+#if ! defined(_XtIntrinsic_h) && ! defined(PIXEL_ALREADY_TYPEDEFED)
+typedef unsigned long Pixel;	/* Index into colormap */
+# define PIXEL_ALREADY_TYPEDEFED
+#endif
+
+/* make sure we know whether function prototypes are needed or not */
+#ifndef NeedFunctionPrototypes
+# if defined(__STDC__) || defined(__cplusplus) || defined(c_plusplus)
+#  define NeedFunctionPrototypes 1
+# else
+#  define NeedFunctionPrototypes 0
+# endif
+#endif
+
+
+/* Return ErrorStatus codes:
+ * null     if full success
+ * positive if partial success
+ * negative if failure
+ */
+
+#define XpmColorError    1
+#define XpmSuccess       0
+#define XpmOpenFailed   -1
+#define XpmFileInvalid  -2
+#define XpmNoMemory     -3
+#define XpmColorFailed  -4
+
+typedef struct {
+    char *name;			/* Symbolic color name */
+    char *value;		/* Color value */
+    Pixel pixel;		/* Color pixel */
+}      XpmColorSymbol;
+
+typedef struct {
+    char *name;			/* name of the extension */
+    unsigned int nlines;	/* number of lines in this extension */
+    char **lines;		/* pointer to the extension array of strings */
+}      XpmExtension;
+
+typedef struct {
+    char *string;		/* characters string */
+    char *symbolic;		/* symbolic name */
+    char *m_color;		/* monochrom default */
+    char *g4_color;		/* 4 level grayscale default */
+    char *g_color;		/* other level grayscale default */
+    char *c_color;		/* color default */
+}      XpmColor;
+
+typedef struct {
+    unsigned int width;		/* image width */
+    unsigned int height;	/* image height */
+    unsigned int cpp;		/* number of characters per pixel */
+    unsigned int ncolors;	/* number of colors */
+    XpmColor *colorTable;	/* list of related colors */
+    unsigned int *data;		/* image data */
+}      XpmImage;
+
+typedef struct {
+    unsigned long valuemask;	/* Specifies which attributes are defined */
+    char *hints_cmt;		/* Comment of the hints section */
+    char *colors_cmt;		/* Comment of the colors section */
+    char *pixels_cmt;		/* Comment of the pixels section */
+    unsigned int x_hotspot;	/* Returns the x hotspot's coordinate */
+    unsigned int y_hotspot;	/* Returns the y hotspot's coordinate */
+    unsigned int nextensions;	/* number of extensions */
+    XpmExtension *extensions;	/* pointer to array of extensions */
+}      XpmInfo;
+
+typedef int (*XpmAllocColorFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    char*			/* colorname */,
+    XColor*			/* xcolor */,
+    void*			/* closure */
+#endif
+);
+
+typedef int (*XpmFreeColorsFunc)(
+#if NeedFunctionPrototypes
+    Display*			/* display */,
+    Colormap			/* colormap */,
+    Pixel*			/* pixels */,
+    int				/* npixels */,
+    void*			/* closure */
+#endif
+);
+
+typedef struct {
+    unsigned long valuemask;		/* Specifies which attributes are
+					   defined */
+
+    Visual *visual;			/* Specifies the visual to use */
+    Colormap colormap;			/* Specifies the colormap to use */
+    unsigned int depth;			/* Specifies the depth */
+    unsigned int width;			/* Returns the width of the created
+					   pixmap */
+    unsigned int height;		/* Returns the height of the created
+					   pixmap */
+    unsigned int x_hotspot;		/* Returns the x hotspot's
+					   coordinate */
+    unsigned int y_hotspot;		/* Returns the y hotspot's
+					   coordinate */
+    unsigned int cpp;			/* Specifies the number of char per
+					   pixel */
+    Pixel *pixels;			/* List of used color pixels */
+    unsigned int npixels;		/* Number of used pixels */
+    XpmColorSymbol *colorsymbols;	/* List of color symbols to override */
+    unsigned int numsymbols;		/* Number of symbols */
+    char *rgb_fname;			/* RGB text file name */
+    unsigned int nextensions;		/* Number of extensions */
+    XpmExtension *extensions;		/* List of extensions */
+
+    unsigned int ncolors;               /* Number of colors */
+    XpmColor *colorTable;               /* List of colors */
+/* 3.2 backward compatibility code */
+    char *hints_cmt;                    /* Comment of the hints section */
+    char *colors_cmt;                   /* Comment of the colors section */
+    char *pixels_cmt;                   /* Comment of the pixels section */
+/* end 3.2 bc */
+    unsigned int mask_pixel;            /* Color table index of transparent
+                                           color */
+
+    /* Color Allocation Directives */
+    Bool exactColors;			/* Only use exact colors for visual */
+    unsigned int closeness;		/* Allowable RGB deviation */
+    unsigned int red_closeness;		/* Allowable red deviation */
+    unsigned int green_closeness;	/* Allowable green deviation */
+    unsigned int blue_closeness;	/* Allowable blue deviation */
+    int color_key;			/* Use colors from this color set */
+
+    Pixel *alloc_pixels;		/* Returns the list of alloc'ed color
+					   pixels */
+    int nalloc_pixels;			/* Returns the number of alloc'ed
+					   color pixels */
+
+    Bool alloc_close_colors;    	/* Specify whether close colors should
+					   be allocated using XAllocColor
+					   or not */
+    int bitmap_format;			/* Specify the format of 1bit depth
+					   images: ZPixmap or XYBitmap */
+
+    /* Color functions */
+    XpmAllocColorFunc alloc_color;	/* Application color allocator */
+    XpmFreeColorsFunc free_colors;	/* Application color de-allocator */
+    void *color_closure;		/* Application private data to pass to
+					   alloc_color and free_colors */
+
+}      XpmAttributes;
+
+/* XpmAttributes value masks bits */
+#define XpmVisual	   (1L<<0)
+#define XpmColormap	   (1L<<1)
+#define XpmDepth	   (1L<<2)
+#define XpmSize		   (1L<<3)	/* width & height */
+#define XpmHotspot	   (1L<<4)	/* x_hotspot & y_hotspot */
+#define XpmCharsPerPixel   (1L<<5)
+#define XpmColorSymbols	   (1L<<6)
+#define XpmRgbFilename	   (1L<<7)
+/* 3.2 backward compatibility code */
+#define XpmInfos	   (1L<<8)
+#define XpmReturnInfos	   XpmInfos
+/* end 3.2 bc */
+#define XpmReturnPixels	   (1L<<9)
+#define XpmExtensions      (1L<<10)
+#define XpmReturnExtensions XpmExtensions
+
+#define XpmExactColors     (1L<<11)
+#define XpmCloseness	   (1L<<12)
+#define XpmRGBCloseness	   (1L<<13)
+#define XpmColorKey	   (1L<<14)
+
+#define XpmColorTable      (1L<<15)
+#define XpmReturnColorTable XpmColorTable
+
+#define XpmReturnAllocPixels (1L<<16)
+#define XpmAllocCloseColors (1L<<17)
+#define XpmBitmapFormat    (1L<<18)
+
+#define XpmAllocColor      (1L<<19)
+#define XpmFreeColors      (1L<<20)
+#define XpmColorClosure    (1L<<21)
+
+
+/* XpmInfo value masks bits */
+#define XpmComments        XpmInfos
+#define XpmReturnComments  XpmComments
+
+/* XpmAttributes mask_pixel value when there is no mask */
+#ifndef FOR_MSW
+#define XpmUndefPixel 0x80000000
+#else
+/* int is only 16 bit for MSW */
+#define XpmUndefPixel 0x8000
+#endif
+
+/*
+ * color keys for visual type, they must fit along with the number key of
+ * each related element in xpmColorKeys[] defined in XpmI.h
+ */
+#define XPM_MONO	2
+#define XPM_GREY4	3
+#define XPM_GRAY4	3
+#define XPM_GREY 	4
+#define XPM_GRAY 	4
+#define XPM_COLOR	5
+
+
+/* macros for forward declarations of functions with prototypes */
+#if NeedFunctionPrototypes
+#define FUNC(f, t, p) extern t f p
+#define LFUNC(f, t, p) static t f p
+#else
+#define FUNC(f, t, p) extern t f()
+#define LFUNC(f, t, p) static t f()
+#endif
+
+
+/*
+ * functions declarations
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* FOR_MSW, all ..Pixmap.. are excluded, only the ..XImage.. are used */
+/* Same for Amiga! */
+
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromData, int, (Display *display,
+					Drawable d,
+					char **data,
+					Pixmap *pixmap_return,
+					Pixmap *shapemask_return,
+					XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromPixmap, int, (Display *display,
+					char ***data_return,
+					Pixmap pixmap,
+					Pixmap shapemask,
+					XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToPixmap, int, (Display *display,
+				    Drawable d,
+				    char *filename,
+				    Pixmap *pixmap_return,
+				    Pixmap *shapemask_return,
+				    XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromPixmap, int, (Display *display,
+				       char *filename,
+				       Pixmap pixmap,
+				       Pixmap shapemask,
+				       XpmAttributes *attributes));
+#endif
+
+    FUNC(XpmCreateImageFromData, int, (Display *display,
+				       char **data,
+				       XImage **image_return,
+				       XImage **shapemask_return,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmCreateDataFromImage, int, (Display *display,
+				       char ***data_return,
+				       XImage *image,
+				       XImage *shapeimage,
+				       XpmAttributes *attributes));
+
+    FUNC(XpmReadFileToImage, int, (Display *display,
+				   char *filename,
+				   XImage **image_return,
+				   XImage **shapeimage_return,
+				   XpmAttributes *attributes));
+
+    FUNC(XpmWriteFileFromImage, int, (Display *display,
+				      char *filename,
+				      XImage *image,
+				      XImage *shapeimage,
+				      XpmAttributes *attributes));
+
+    FUNC(XpmCreateImageFromBuffer, int, (Display *display,
+					 char *buffer,
+					 XImage **image_return,
+					 XImage **shapemask_return,
+					 XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromBuffer, int, (Display *display,
+					  Drawable d,
+					  char *buffer,
+					  Pixmap *pixmap_return,
+					  Pixmap *shapemask_return,
+					  XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromImage, int, (Display *display,
+					 char **buffer_return,
+					 XImage *image,
+					 XImage *shapeimage,
+					 XpmAttributes *attributes));
+
+    FUNC(XpmCreateBufferFromPixmap, int, (Display *display,
+					  char **buffer_return,
+					  Pixmap pixmap,
+					  Pixmap shapemask,
+					  XpmAttributes *attributes));
+#endif
+    FUNC(XpmReadFileToBuffer, int, (char *filename, char **buffer_return));
+    FUNC(XpmWriteFileFromBuffer, int, (char *filename, char *buffer));
+
+    FUNC(XpmReadFileToData, int, (char *filename, char ***data_return));
+    FUNC(XpmWriteFileFromData, int, (char *filename, char **data));
+
+    FUNC(XpmAttributesSize, int, ());
+    FUNC(XpmFreeAttributes, void, (XpmAttributes *attributes));
+    FUNC(XpmFreeExtensions, void, (XpmExtension *extensions,
+				   int nextensions));
+
+    FUNC(XpmFreeXpmImage, void, (XpmImage *image));
+    FUNC(XpmFreeXpmInfo, void, (XpmInfo *info));
+    FUNC(XpmGetErrorString, char *, (int errcode));
+    FUNC(XpmLibraryVersion, int, ());
+
+    /* XpmImage functions */
+    FUNC(XpmReadFileToXpmImage, int, (char *filename,
+				      XpmImage *image,
+				      XpmInfo *info));
+
+    FUNC(XpmWriteFileFromXpmImage, int, (char *filename,
+					 XpmImage *image,
+					 XpmInfo *info));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreatePixmapFromXpmImage, int, (Display *display,
+					    Drawable d,
+					    XpmImage *image,
+					    Pixmap *pixmap_return,
+					    Pixmap *shapemask_return,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateImageFromXpmImage, int, (Display *display,
+					   XpmImage *image,
+					   XImage **image_return,
+					   XImage **shapeimage_return,
+					   XpmAttributes *attributes));
+
+    FUNC(XpmCreateXpmImageFromImage, int, (Display *display,
+					   XImage *image,
+					   XImage *shapeimage,
+					   XpmImage *xpmimage,
+					   XpmAttributes *attributes));
+#if !defined(FOR_MSW) && !defined(AMIGA)
+    FUNC(XpmCreateXpmImageFromPixmap, int, (Display *display,
+					    Pixmap pixmap,
+					    Pixmap shapemask,
+					    XpmImage *xpmimage,
+					    XpmAttributes *attributes));
+#endif
+    FUNC(XpmCreateDataFromXpmImage, int, (char ***data_return,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromData, int, (char **data,
+					  XpmImage *image,
+					  XpmInfo *info));
+
+    FUNC(XpmCreateXpmImageFromBuffer, int, (char *buffer,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmCreateBufferFromXpmImage, int, (char **buffer_return,
+					    XpmImage *image,
+					    XpmInfo *info));
+
+    FUNC(XpmGetParseError, int, (char *filename,
+				 int *linenum_return,
+				 int *charnum_return));
+
+    FUNC(XpmFree, void, (void *ptr));
+
+#ifdef __cplusplus
+} /* for C++ V2.0 */
+#endif
+
+
+/* backward compatibility */
+
+/* for version 3.0c */
+#define XpmPixmapColorError  XpmColorError
+#define XpmPixmapSuccess     XpmSuccess
+#define XpmPixmapOpenFailed  XpmOpenFailed
+#define XpmPixmapFileInvalid XpmFileInvalid
+#define XpmPixmapNoMemory    XpmNoMemory
+#define XpmPixmapColorFailed XpmColorFailed
+
+#define XpmReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XpmWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+
+/* for version 3.0b */
+#define PixmapColorError  XpmColorError
+#define PixmapSuccess     XpmSuccess
+#define PixmapOpenFailed  XpmOpenFailed
+#define PixmapFileInvalid XpmFileInvalid
+#define PixmapNoMemory    XpmNoMemory
+#define PixmapColorFailed XpmColorFailed
+
+#define ColorSymbol XpmColorSymbol
+
+#define XReadPixmapFile(dpy, d, file, pix, mask, att) \
+    XpmReadFileToPixmap(dpy, d, file, pix, mask, att)
+#define XWritePixmapFile(dpy, file, pix, mask, att) \
+    XpmWriteFileFromPixmap(dpy, file, pix, mask, att)
+#define XCreatePixmapFromData(dpy, d, data, pix, mask, att) \
+    XpmCreatePixmapFromData(dpy, d, data, pix, mask, att)
+#define XCreateDataFromPixmap(dpy, data, pix, mask, att) \
+    XpmCreateDataFromPixmap(dpy, data, pix, mask, att)
+
+#endif /* XPM_NUMBERS */
+#endif
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/namecvt rxvt-2.7.2/W11/xpm-3.4k/namecvt
--- rxvt-2.7.2-orig/W11/xpm-3.4k/namecvt	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/namecvt	Mon May 14 08:23:10 2001
@@ -0,0 +1,60 @@
+#!/bin/sh
+#
+# create two scripts to convert the filenames of the XPM distribution
+# run this in the xpm toplevel directory
+# after that you have the following two scripts
+# cvtux2dos will copy the files into fordos/
+# cvtdos2ux will copy from fromdos/ to new/
+#
+# Written by HeDu 5/94 (hedu@cul-ipn.uni-kiel.de)
+#
+
+echo "Making cvtux2dos and cvtdos2ux..."
+
+cp /dev/null cvtux2dos
+echo "#!/bin/sh" > cvtux2dos
+echo "echo Making dos hierarchy..." >> cvtux2dos
+echo "mkdir fordos" >> cvtux2dos
+echo "mkdir fordos/lib" >> cvtux2dos
+echo "mkdir fordos/doc" >> cvtux2dos
+
+cp /dev/null cvtdos2ux
+echo "#!/bin/sh" > cvtdos2ux
+echo "echo Making unix hierarchy..." >> cvtdos2ux
+echo "mkdir new" >> cvtdos2ux
+echo "mkdir new/lib" >> cvtdos2ux
+echo "mkdir new/doc" >> cvtdos2ux
+
+for i in CHANGES FAQ FILES README README.MSW \
+	lib/CrBufFrI.c lib/CrBufFrP.c lib/CrDatFrI.c \
+	lib/CrDatFrP.c lib/CrIFrBuf.c lib/CrIFrDat.c \
+	lib/CrPFrBuf.c lib/CrPFrDat.c lib/RdFToDat.c \
+	lib/RdFToI.c lib/RdFToP.c lib/WrFFrDat.c \
+	lib/WrFFrI.c lib/WrFFrP.c \
+	lib/create.c lib/data.c lib/misc.c lib/parse.c \
+	lib/rgb.c lib/rgbtab.h lib/scan.c lib/hashtab.c \
+	lib/simx.h lib/simx.c lib/xpm.h lib/XpmI.h \
+	lib/Attrib.c lib/Image.c lib/Info.c \
+	lib/CrIFrP.c lib/CrPFrI.c lib/RdFToBuf.c lib/WrFFrBuf.c \
+	namecvt
+do
+	# fold to lower case
+	# so they are fine for DOS, sigh
+ 	new=`echo $i | tr '[A-Z]' '[a-z]'`
+	echo "cp $i fordos/$new" >> cvtux2dos
+	echo "cp fromdos/$new new/$i" >> cvtdos2ux
+done
+
+# special ones
+echo "cp COPYRIGHT fordos/copyrigh.t" >> cvtux2dos
+echo "cp fromdos/copyrigh.t new/COPYRIGHT" >> cvtdos2ux
+echo "cp doc/xpm.PS.gz fordos/doc/xpm_ps.gz" >> cvtux2dos
+echo "cp fromdos/doc/xpm_ps.gz new/doc/xpm.PS.gz" >> cvtdos2ux
+#
+echo "echo done." >> cvtux2dos
+echo "echo done." >> cvtdos2ux
+
+chmod +x cvtux2dos
+chmod +x cvtdos2ux
+
+echo "done."
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Imakefile rxvt-2.7.2/W11/xpm-3.4k/sxpm/Imakefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Imakefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/Imakefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,98 @@
+XCOMM
+XCOMM
+XCOMM Copyright (C) 1989-95 GROUPE BULL
+XCOMM
+XCOMM Permission is hereby granted, free of charge, to any person obtaining a
+XCOMM copy of this software and associated documentation files
+XCOMM (the "Software"), to deal in the Software without restriction, including
+XCOMM without limitation the rights to use, copy, modify, merge, publish,
+XCOMM distribute, sublicense, and/or sell copies of the Software, and to permit
+XCOMM persons to whom the Software is furnished to do so, subject to the
+XCOMM following conditions:
+XCOMM The above copyright notice and this permission notice shall be included
+XCOMM in all copies or substantial portions of the Software.
+XCOMM
+XCOMM THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+XCOMM OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+XCOMM MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+XCOMM IN NO EVENT SHALL GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+XCOMM LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+XCOMM FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+XCOMM DEALINGS IN THE SOFTWARE.
+XCOMM
+XCOMM Except as contained in this notice, the name of GROUPE BULL shall not be
+XCOMM used in advertising or otherwise to promote the sale, use or other
+XCOMM dealings in this Software without prior written authorization from
+XCOMM GROUPE BULL.
+XCOMM
+
+XCOMM
+XCOMM XPM Imakefile - Arnaud LE HORS
+XCOMM
+
+XCOMM default locations
+#ifndef XpmLibDir
+#define XpmLibDir $(USRLIBDIR)
+#endif
+#ifndef XpmBinDir
+#define XpmBinDir $(BINDIR)
+#endif
+#ifndef XpmManDir
+#define XpmManDir $(MANDIR)
+#endif
+#ifndef XpmIncDir
+#define XpmIncDir $(BUILDINCTOP)
+#endif
+
+      XPMLIBDIR = XpmLibDir
+      XPMBINDIR = XpmBinDir
+      XPMMANDIR = XpmManDir
+      XPMINCDIR = XpmIncDir
+
+         XPMLIB = -lXpm
+       INCLUDES = -I$(BUILDINCDIR) -I$(XPMINCDIR)
+        DEPLIBS = $(DEPXTOOLLIB) $(DEPXLIB)
+
+#ifdef Win32Architecture
+LOCAL_LIBRARIES = ../lib/Xpm.lib $(XTOOLLIB) $(XLIB)
+#else
+LOCAL_LIBRARIES = -L../lib -L$(XPMLIBDIR) $(XPMLIB) $(XTOOLLIB) $(XLIB)
+#endif
+
+XCOMM try hard to set things so we'll find the shared lib once installed
+LD_RUN_PATH = $(USRLIBDIR):$(XPMLIBDIR)
+USRLIBDIRPATH = $(USRLIBDIR):$(XPMLIBDIR)
+
+#if ProjectX < 603
+# ifdef HPArchitecture
+EXTRA_LOAD_FLAGS = -Wl,+s,+b,$(USRLIBDIRPATH)
+# endif
+# if defined(SunArchitecture) && defined(SVR4Architecture)
+EXTRA_LOAD_FLAGS = -R$(USRLIBDIRPATH)
+# endif
+# if defined(AlphaArchitecture) || defined (SGIArchitecture)
+EXTRA_LOAD_FLAGS = -Wl,-rpath,$(USRLIBDIRPATH)
+# endif
+#endif
+
+#ifdef OsNameDefines
+OS_NAME_DEFINES = OsNameDefines
+#endif
+
+          SRCS = sxpm.c
+          OBJS = sxpm.o
+
+#if (ProjectX < 6)
+AllTarget(sxpm)
+#else
+AllTarget(ProgramTargetName(sxpm))
+#endif
+NormalProgramTarget(sxpm,$(OBJS),$(DEPLIB),$(LOCAL_LIBRARIES),)
+InstallProgram(sxpm,$(XPMBINDIR))
+InstallManPage(sxpm,$(XPMMANDIR))
+DependTarget()
+LintTarget()
+
+clean::	
+	$(RM) sxpmout.xpm
+
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Makefile rxvt-2.7.2/W11/xpm-3.4k/sxpm/Makefile
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Makefile	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/Makefile	Mon May 14 08:23:10 2001
@@ -0,0 +1,623 @@
+# Makefile generated by imake - do not edit!
+# $TOG: imake.c /main/104 1998/03/24 12:45:15 kaleb $
+
+# ----------------------------------------------------------------------
+# Makefile generated from "Imake.tmpl" and <Imakefile>
+# $TOG: Imake.tmpl /main/249 1997/10/13 15:28:56 kaleb $
+#
+
+all::
+
+.SUFFIXES: .i
+
+# $TOG: Imake.cf /main/30 1998/04/28 13:55:25 barstow $
+
+# -----------------------------------------------------------------------
+# site-specific configuration parameters that need to come before
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ----------------------------------------------------------------------
+# platform-specific configuration parameters - edit cygwin.cf to change
+
+# platform:  $XConsortium: cygwin.cf sos 1996/02/08 18:59:31 gildea $
+#
+# changes since b18 cygwin32 release
+#	- avoided tons of "not in XXX directory" messages;
+#	- dlls are built stripped;
+#	- search for cpp in a default location;
+#	- fixed problem with missed netinet/tcp.h;
+#	- xterm compiles and works;
+#	- more libs are built as a dlls;
+#	- all dlls have different base addresses;
+
+# $XConsortium: cygwin.rules /main/12 1996/01/03 14:51:18 kaleb $
+
+BASE_COUNTER=/tmp/DLL_BASE_COUNTER
+
+# ----------------------------------------------------------------------
+# site-specific configuration parameters that go after
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ---------------------------------------------------------------------
+# Imake rules for building libraries, programs, scripts, and data files
+# rules:  $TOG: Imake.rules /main/227 1998/02/02 12:07:57 kaleb $
+
+          PATHSEP = /
+            SHELL = /bin/sh
+
+              TOP = ..
+      CURRENT_DIR = sxpm
+
+            IMAKE = imake
+           DEPEND = makedepend
+        MKDIRHIER = mkdir -p
+    EXPORTLISTGEN =
+        CONFIGSRC = $(TOP)/config
+         IMAKESRC = $(CONFIGSRC)/imake
+        DEPENDSRC = $(CONFIGSRC)/makedepend
+
+          INCROOT = /usr/X11R6.4/include
+        USRLIBDIR = /usr/X11R6.4/lib
+         SHLIBDIR = /usr/X11R6.4/lib
+       LINTLIBDIR = $(USRLIBDIR)/lint
+          MANPATH = /usr/X11R6.4/man
+    MANSOURCEPATH = $(MANPATH)/man
+           MANDIR = $(MANSOURCEPATH)1
+        LIBMANDIR = $(MANSOURCEPATH)3
+       FILEMANDIR = $(MANSOURCEPATH)5
+       MISCMANDIR = $(MANSOURCEPATH)$(MISCMANSUFFIX)
+
+               AR = ar clq
+  BOOTSTRAPCFLAGS =
+               CC = gcc
+               AS = as
+
+.SUFFIXES: .cc
+
+              CXX = g++
+          CXXFILT = c++filt
+           CXXLIB =
+    CXXDEBUGFLAGS = -O2 -s -mpentium
+CXXDEPENDINCLUDES =
+ CXXEXTRA_DEFINES =
+CXXEXTRA_INCLUDES =
+   CXXSTD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(CXXPROJECT_DEFINES)
+       CXXOPTIONS =
+      CXXINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(CXXEXTRA_INCLUDES)
+       CXXDEFINES = $(CXXINCLUDES) $(CXXSTD_DEFINES) $(THREADS_CXXDEFINES) $(CXXEXTRA_DEFINES) $(DEFINES)
+         CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
+
+         COMPRESS = compress
+          GZIPCMD = gzip
+              CPP = gcc -E - $(STD_CPP_DEFINES)
+    PREPROCESSCMD = gcc -E $(STD_CPP_DEFINES)
+          INSTALL = install
+     INSTALLFLAGS = -c
+               LD = ld
+              LEX = flex -l
+           LEXLIB = -lfl
+             YACC = byacc
+           CCYACC = byacc
+             LINT = lint
+      LINTLIBFLAG = -C
+         LINTOPTS = -axz
+               LN = ln -s
+             MAKE = make
+               MV = mv
+               CP = cp
+
+           RANLIB = ranlib
+  RANLIBINSTFLAGS =
+
+               RM = rm -f
+        MANSUFFIX = 1x
+     LIBMANSUFFIX = 3x
+    FILEMANSUFFIX = 5x
+    MISCMANSUFFIX = 7
+
+            TROFF = psroff
+            NROFF = nroff
+         MSMACROS = -ms
+        MANMACROS = -man
+              TBL = tbl
+              EQN = eqn
+             NEQN = neqn
+              COL = col
+
+            DVIPS = dvips
+            LATEX = latex
+
+     STD_INCLUDES =
+  STD_CPP_DEFINES = -traditional -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+      STD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+ EXTRA_LOAD_FLAGS =
+  EXTRA_LDOPTIONS =
+  EXTRA_LIBRARIES =
+             TAGS = ctags
+
+    SHAREDCODEDEF =
+         SHLIBDEF =
+
+     SHLIBLDFLAGS =
+
+    PROTO_DEFINES = -DFUNCPROTO=15 -DNARROWPROTO
+
+     INSTPGMFLAGS = -s
+
+     INSTBINFLAGS = -m 0755
+     INSTUIDFLAGS = -s -m 4711
+     INSTLIBFLAGS = -m 0644
+     INSTINCFLAGS = -m 0444
+     INSTMANFLAGS = -m 0444
+     INSTDATFLAGS = -m 0444
+    INSTKMEMFLAGS = -s -m 4711
+
+      PROJECTROOT = /usr/X11R6.4
+
+      CDEBUGFLAGS = -O2 -s -mpentium
+        CCOPTIONS =
+
+      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
+       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(THREADS_DEFINES) $(DEFINES)
+           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(THREADS_CFLAGS) $(ALLDEFINES)
+        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES) $(DEPEND_DEFINES)
+         LDPRELIB = -L$(USRLIBDIR)
+        LDPOSTLIB =
+        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)  $(EXTRA_LDOPTIONS) $(THREADS_LDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+     CXXLDOPTIONS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(EXTRA_LDOPTIONS) $(THREADS_CXXLDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+
+           LDLIBS = $(LDPOSTLIBS) $(THREADS_LIBS) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
+
+           CCLINK = $(CC)
+
+          CXXLINK = $(CXX)
+
+     LDSTRIPFLAGS = -x
+   LDCOMBINEFLAGS = -r
+      DEPENDFLAGS =
+
+        MACROFILE = cygwin.cf
+           RM_CMD = $(RM)
+
+    IMAKE_DEFINES =
+
+         IRULESRC = $(CONFIGDIR)
+        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
+
+     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/X11.tmpl 			$(IRULESRC)/site.def $(IRULESRC)/$(MACROFILE) 			 $(EXTRA_ICONFIGFILES)
+
+# $TOG: X11.rules /main/4 1997/04/30 15:23:24 kaleb $
+
+# ----------------------------------------------------------------------
+# X Window System Build Parameters and Rules
+# $TOG: X11.tmpl /main/308 1998/06/16 15:14:24 msr $
+
+# -----------------------------------------------------------------------
+# X Window System make variables; these need to be coordinated with rules
+
+             XTOP = $(TOP)
+           BINDIR = /usr/X11R6.4/bin
+     BUILDINCROOT = $(TOP)/exports
+      BUILDINCDIR = $(BUILDINCROOT)/include
+      BUILDINCTOP = ../..
+      BUILDLIBDIR = $(TOP)/exports/lib
+      BUILDLIBTOP = ../..
+      BUILDBINDIR = $(TOP)/exports/bin
+      BUILDBINTOP = ../..
+    XBUILDINCROOT = $(XTOP)/exports
+     XBUILDINCDIR = $(XBUILDINCROOT)/include/X11
+     XBUILDINCTOP = ../../..
+     XBUILDBINDIR = $(XBUILDINCROOT)/bin
+           INCDIR = $(INCROOT)
+           ADMDIR = /usr/adm
+           LIBDIR = $(USRLIBDIR)/X11
+   TOP_X_INCLUDES = -I$(XPROJECTROOT)/include
+
+           VARDIR = /var/X11
+
+          FONTDIR = $(LIBDIR)/fonts
+         XINITDIR = $(LIBDIR)/xinit
+           XDMDIR = $(LIBDIR)/xdm
+           TWMDIR = $(LIBDIR)/twm
+           XSMDIR = $(LIBDIR)/xsm
+           NLSDIR = $(LIBDIR)/nls
+       XLOCALEDIR = $(LIBDIR)/locale
+        PEXAPIDIR = $(LIBDIR)/PEX
+      LBXPROXYDIR = $(LIBDIR)/lbxproxy
+  PROXYMANAGERDIR = $(LIBDIR)/proxymngr
+        XPRINTDIR = $(LIBDIR)/xserver
+      XAPPLOADDIR = $(LIBDIR)/app-defaults
+       FONTCFLAGS = -t
+
+     INSTAPPFLAGS = $(INSTDATFLAGS)
+
+              RGB = $(BINDIR)/rgb
+            FONTC = $(BINDIR)/bdftopcf
+        MKFONTDIR = $(BINDIR)/mkfontdir
+
+       DOCUTILSRC = $(XTOP)/doc/util
+       XDOCMACROS = $(DOCUTILSRC)/macros.t
+       XIDXMACROS = $(DOCUTILSRC)/indexmacros.t
+       PROGRAMSRC = $(TOP)/programs
+           LIBSRC = $(XTOP)/lib
+          FONTSRC = $(XTOP)/fonts
+       INCLUDESRC = $(BUILDINCROOT)/include
+      XINCLUDESRC = $(INCLUDESRC)/X11
+        SERVERSRC = $(XTOP)/programs/Xserver
+       CONTRIBSRC = $(XTOP)/../contrib
+   UNSUPPORTEDSRC = $(XTOP)/unsupported
+           DOCSRC = $(XTOP)/doc
+           RGBSRC = $(XTOP)/programs/rgb
+      BDFTOPCFSRC = $(PROGRAMSRC)/bdftopcf
+     MKFONTDIRSRC = $(PROGRAMSRC)/mkfontdir
+    FONTSERVERSRC = $(PROGRAMSRC)/xfs
+       FONTINCSRC = $(XTOP)/include/fonts
+        EXTINCSRC = $(XTOP)/include/extensions
+     TRANSCOMMSRC = $(LIBSRC)/xtrans
+   TRANS_INCLUDES = -I$(TRANSCOMMSRC)
+
+   CLIENTENVSETUP =
+
+# $XConsortium: WinLib.tmpl,v 1.1 94/01/08 18:32:51 rws Exp $
+
+          XLIBSRC = $(LIBSRC)/X11
+
+SOXLIBREV = 6.1
+DEPXONLYLIB =
+XONLYLIB =  -lX11
+
+LINTXONLY = $(LINTLIBDIR)/llib-lX11.ln
+
+         XLIBONLY = $(XONLYLIB)
+
+      XEXTLIBSRC = $(LIBSRC)/Xext
+
+SOXEXTREV = 6.4
+DEPEXTENSIONLIB =
+EXTENSIONLIB =  -lXext
+
+LINTEXTENSION = $(LINTLIBDIR)/llib-lXext.ln
+
+LINTEXTENSIONLIB = $(LINTEXTENSION)
+          DEPXLIB = $(DEPEXTENSIONLIB) $(DEPXONLYLIB)
+             XLIB = $(EXTENSIONLIB) $(XONLYLIB)
+         LINTXLIB = $(LINTXONLYLIB)
+
+         XAUTHSRC = $(LIBSRC)/Xau
+
+DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
+XAUTHLIB =  -lXau
+
+LINTXAUTH = $(LINTLIBDIR)/llib-lXau.ln
+
+      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
+
+DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
+XDMCPLIB =  -lXdmcp
+
+LINTXDMCP = $(LINTLIBDIR)/llib-lXdmcp.ln
+
+           XMUSRC = $(LIBSRC)/Xmu
+
+DEPXMULIB = $(USRLIBDIR)/libXmu.a
+XMULIB =  -lXmu
+
+LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
+
+       OLDXLIBSRC = $(LIBSRC)/oldX
+
+SOOLDXREV = 6.0
+DEPOLDXLIB =
+OLDXLIB =  -loldX
+
+LINTOLDX = $(LINTLIBDIR)/llib-loldX.ln
+
+         XPLIBSRC = $(LIBSRC)/Xp
+
+SOXPREV = 6.2
+DEPXPLIB =
+XPLIB =  -lXp
+
+LINTXP = $(LINTLIBDIR)/llib-lXp.ln
+
+       TOOLKITSRC = $(LIBSRC)/Xt
+
+DEPXTOOLONLYLIB = $(USRLIBDIR)/libXt.a
+XTOOLONLYLIB =  -lXt
+
+LINTXTOOLONLY = $(LINTLIBDIR)/llib-lXt.ln
+
+      DEPXTOOLLIB = $(DEPXTOOLONLYLIB) $(DEPSMLIB) $(DEPICELIB)
+         XTOOLLIB = $(XTOOLONLYLIB) $(SMLIB) $(ICELIB)
+     LINTXTOOLLIB = $(LINTXTOOLONLYLIB)
+
+       XALIBSRC = $(LIBSRC)/Xa
+
+SOXAREV = 1.0
+DEPXALIB =
+XALIB =  -lXa
+
+LINTXA = $(LINTLIBDIR)/llib-lXa.ln
+
+       AWIDGETSRC = $(LIBSRC)/Xaw
+
+DEPXAWLIB = $(USRLIBDIR)/libXaw.a
+XAWLIB =  -lXaw
+
+LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
+
+         XILIBSRC = $(LIBSRC)/Xi
+
+SOXINPUTREV = 6.0
+DEPXILIB =
+XILIB =  -lXi
+
+LINTXI = $(LINTLIBDIR)/llib-lXi.ln
+
+      XTESTLIBSRC = $(LIBSRC)/Xtst
+
+SOXTESTREV = 6.1
+DEPXTESTLIB =
+XTESTLIB =  -lXtst
+
+LINTXTEST = $(LINTLIBDIR)/llib-lXtst.ln
+
+        PEXLIBSRC = $(LIBSRC)/PEX5
+
+SOPEXREV = 6.0
+DEPPEXLIB =
+PEXLIB =  -lPEX5
+
+LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
+
+        XIELIBSRC = $(LIBSRC)/XIE
+
+SOXIEREV = 6.0
+DEPXIELIB =
+XIELIB =  -lXIE
+
+LINTXIE = $(LINTLIBDIR)/llib-lXIE.ln
+
+      PHIGSLIBSRC = $(LIBSRC)/PHIGS
+
+DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
+PHIGSLIB =  -lphigs
+
+LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
+
+DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
+XBSDLIB =  -lXbsd
+
+LINTXBSD = $(LINTLIBDIR)/llib-lXbsd.ln
+
+           ICESRC = $(LIBSRC)/ICE
+
+SOICEREV = 6.3
+DEPICELIB =
+ICELIB =  -lICE
+
+LINTICE = $(LINTLIBDIR)/llib-lICE.ln
+
+            SMSRC = $(LIBSRC)/SM
+
+SOSMREV = 6.0
+DEPSMLIB =
+SMLIB =  -lSM
+
+LINTSM = $(LINTLIBDIR)/llib-lSM.ln
+
+           XKEYSRC = $(LIBSRC)/Xkey
+
+SOXKEYREV = 6.0
+DEPXKEYLIB =
+XKEYLIB =  -lXkey
+
+LINTXKEY = $(LINTLIBDIR)/llib-lXkey.ln
+
+         FSLIBSRC = $(LIBSRC)/FS
+
+DEPFSLIB = $(USRLIBDIR)/libFS.a
+FSLIB =  -lFS
+
+LINTFS = $(LINTLIBDIR)/llib-lFS.ln
+
+         FONTLIBSRC = $(LIBSRC)/font
+
+DEPFONTLIB = $(USRLIBDIR)/libfont.a
+FONTLIB =  -lfont
+
+LINTFONT = $(LINTLIBDIR)/llib-lfont.ln
+
+    XKBFILELIBSRC = $(LIBSRC)/xkbfile
+
+DEPXKBFILELIB = $(USRLIBDIR)/libxkbfile.a
+XKBFILELIB =  -lxkbfile
+
+LINTXKBFILE = $(LINTLIBDIR)/llib-lxkbfile.ln
+
+     XKBCOMPCMD = $(BINDIR)/xkbcomp
+
+          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
+
+         DEPLIBS1 = $(DEPLIBS)
+         DEPLIBS2 = $(DEPLIBS)
+         DEPLIBS3 = $(DEPLIBS)
+         DEPLIBS4 = $(DEPLIBS)
+         DEPLIBS5 = $(DEPLIBS)
+         DEPLIBS6 = $(DEPLIBS)
+         DEPLIBS7 = $(DEPLIBS)
+         DEPLIBS8 = $(DEPLIBS)
+         DEPLIBS9 = $(DEPLIBS)
+         DEPLIBS10 = $(DEPLIBS)
+
+XMULIBONLY = -lXmu
+XMULIB = $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+
+        CONFIGDIR = $(LIBDIR)/config
+
+    USRLIBDIRPATH = $(USRLIBDIR)
+        LDPRELIBS = -L$(USRLIBDIR)
+       LDPOSTLIBS =
+     TOP_INCLUDES = -I$(INCROOT) $(TOP_X_INCLUDES)
+  PROJECT_DEFINES =
+
+CXXPROJECT_DEFINES =
+
+# ----------------------------------------------------------------------
+# start of Imakefile
+
+#
+#
+# Copyright (C) 1989-95 GROUPE BULL
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files
+# (the "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to permit
+# persons to whom the Software is furnished to do so, subject to the
+# following conditions:
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN 0 EVENT SHALL GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+# DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of GROUPE BULL shall not be
+# used in advertising or otherwise to promote the sale, use or other
+# dealings in this Software without prior written authorization from
+# GROUPE BULL.
+#
+
+#
+# XPM Imakefile - Arnaud LE HORS
+#
+
+# default locations
+
+      XPMLIBDIR = $(USRLIBDIR)
+      XPMBINDIR = $(BINDIR)
+      XPMMANDIR = $(MANDIR)
+      XPMINCDIR = $(BUILDINCTOP)
+
+         XPMLIB = -lXpm
+       INCLUDES = -I$(BUILDINCDIR) -I$(XPMINCDIR)
+        DEPLIBS = $(DEPXTOOLLIB) $(DEPXLIB)
+
+LOCAL_LIBRARIES = -L../lib -L$(XPMLIBDIR) $(XPMLIB) $(XTOOLLIB) $(XLIB)
+
+# try hard to set things so we'll find the shared lib once installed
+LD_RUN_PATH = $(USRLIBDIR):$(XPMLIBDIR)
+USRLIBDIRPATH = $(USRLIBDIR):$(XPMLIBDIR)
+
+OS_NAME_DEFINES =
+
+          SRCS = sxpm.c
+          OBJS = sxpm.o
+
+all:: sxpm.exe
+
+all:: sxpm.exe
+sxpm.exe: $(OBJS) $(DEPLIB)
+	$(RM) $@
+	$(CCLINK) -o $@ $(LDOPTIONS) $(OBJS) $(LOCAL_LIBRARIES) $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
+
+clean::
+	$(RM) sxpm.exe
+
+install:: sxpm.exe
+	@if [ -d $(DESTDIR)$(XPMBINDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMBINDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTPGMFLAGS)  sxpm.exe $(DESTDIR)$(XPMBINDIR)/sxpm.exe
+
+install.man:: sxpm.man
+	@if [ -d $(DESTDIR)$(XPMMANDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMMANDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTMANFLAGS) sxpm.man $(DESTDIR)$(XPMMANDIR)/sxpm.$(MANSUFFIX)
+
+depend::
+	$(DEPEND) $(DEPENDFLAGS) -- $(ALLDEFINES) $(DEPEND_DEFINES) -- $(SRCS)
+
+lint:
+	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
+lint1:
+	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
+
+clean::
+	$(RM) sxpmout.xpm
+
+# ----------------------------------------------------------------------
+# common rules for all Makefiles - do not edit
+
+.c.i:
+	$(RM) $@
+	 $(CC) -E $(CFLAGS) $(_NOOP_) $*.c > $@
+
+emptyrule::
+
+clean::
+	$(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut  "#"*
+
+Makefile::
+	-@if [ -f Makefile ]; then set -x; \
+	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
+	else exit 0; fi
+	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
+
+tags::
+	$(TAGS) -w *.[ch]
+	$(TAGS) -xw *.[ch] > TAGS
+
+man_keywords::
+
+# ----------------------------------------------------------------------
+# empty rules for directories that do not have SUBDIRS - do not edit
+
+install::
+	@echo "install in $(CURRENT_DIR) done"
+
+install.man::
+	@echo "install.man in $(CURRENT_DIR) done"
+
+install.linkkit::
+	@echo "install.linkkit in $(CURRENT_DIR) done"
+
+Makefiles::
+
+includes::
+
+depend::
+
+# ----------------------------------------------------------------------
+# dependencies generated by makedepend
+
+# DO NOT DELETE
+
+sxpm.o: /usr/X11R6.4/include/X11/StringDefs.h
+sxpm.o: /usr/X11R6.4/include/X11/Intrinsic.h /usr/X11R6.4/include/X11/Xlib.h
+sxpm.o: /usr/X11R6.4/include/X11/X.h /usr/X11R6.4/include/X11/Xfuncproto.h
+sxpm.o: /usr/X11R6.4/include/X11/Xosdefs.h /usr/X11R6.4/include/X11/Xutil.h
+sxpm.o: /usr/X11R6.4/include/X11/Xresource.h /usr/X11R6.4/include/X11/Core.h
+sxpm.o: /usr/X11R6.4/include/X11/Composite.h
+sxpm.o: /usr/X11R6.4/include/X11/Constraint.h
+sxpm.o: /usr/X11R6.4/include/X11/Object.h /usr/X11R6.4/include/X11/RectObj.h
+sxpm.o: /usr/X11R6.4/include/X11/IntrinsicP.h
+sxpm.o: /usr/X11R6.4/include/X11/CoreP.h
+sxpm.o: /usr/X11R6.4/include/X11/CompositeP.h
+sxpm.o: /usr/X11R6.4/include/X11/ConstrainP.h
+sxpm.o: /usr/X11R6.4/include/X11/ObjectP.h
+sxpm.o: /usr/X11R6.4/include/X11/RectObjP.h /usr/X11R6.4/include/X11/Shell.h
+sxpm.o: /usr/X11R6.4/include/X11/SM/SMlib.h /usr/X11R6.4/include/X11/SM/SM.h
+sxpm.o: /usr/X11R6.4/include/X11/ICE/ICElib.h
+sxpm.o: /usr/X11R6.4/include/X11/ICE/ICE.h
+sxpm.o: /usr/X11R6.4/include/X11/extensions/shape.h
+sxpm.o: ../exports/include/X11/xpm.h
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Makefile.bak rxvt-2.7.2/W11/xpm-3.4k/sxpm/Makefile.bak
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Makefile.bak	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/Makefile.bak	Mon May 14 08:23:10 2001
@@ -0,0 +1,602 @@
+# Makefile generated by imake - do not edit!
+# $TOG: imake.c /main/104 1998/03/24 12:45:15 kaleb $
+
+# ----------------------------------------------------------------------
+# Makefile generated from "Imake.tmpl" and <Imakefile>
+# $TOG: Imake.tmpl /main/249 1997/10/13 15:28:56 kaleb $
+#
+
+all::
+
+.SUFFIXES: .i
+
+# $TOG: Imake.cf /main/30 1998/04/28 13:55:25 barstow $
+
+# -----------------------------------------------------------------------
+# site-specific configuration parameters that need to come before
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ----------------------------------------------------------------------
+# platform-specific configuration parameters - edit cygwin.cf to change
+
+# platform:  $XConsortium: cygwin.cf sos 1996/02/08 18:59:31 gildea $
+#
+# changes since b18 cygwin32 release
+#	- avoided tons of "not in XXX directory" messages;
+#	- dlls are built stripped;
+#	- search for cpp in a default location;
+#	- fixed problem with missed netinet/tcp.h;
+#	- xterm compiles and works;
+#	- more libs are built as a dlls;
+#	- all dlls have different base addresses;
+
+# $XConsortium: cygwin.rules /main/12 1996/01/03 14:51:18 kaleb $
+
+BASE_COUNTER=/tmp/DLL_BASE_COUNTER
+
+# ----------------------------------------------------------------------
+# site-specific configuration parameters that go after
+# the platform-specific parameters - edit site.def to change
+
+# site:  $TOG: site.sample /main/r64_final/1 1998/02/05 16:28:49 kaleb $
+
+# ---------------------------------------------------------------------
+# Imake rules for building libraries, programs, scripts, and data files
+# rules:  $TOG: Imake.rules /main/227 1998/02/02 12:07:57 kaleb $
+
+          PATHSEP = /
+            SHELL = /bin/sh
+
+              TOP = ..
+      CURRENT_DIR = sxpm
+
+            IMAKE = imake
+           DEPEND = makedepend
+        MKDIRHIER = mkdir -p
+    EXPORTLISTGEN =
+        CONFIGSRC = $(TOP)/config
+         IMAKESRC = $(CONFIGSRC)/imake
+        DEPENDSRC = $(CONFIGSRC)/makedepend
+
+          INCROOT = /usr/X11R6.4/include
+        USRLIBDIR = /usr/X11R6.4/lib
+         SHLIBDIR = /usr/X11R6.4/lib
+       LINTLIBDIR = $(USRLIBDIR)/lint
+          MANPATH = /usr/X11R6.4/man
+    MANSOURCEPATH = $(MANPATH)/man
+           MANDIR = $(MANSOURCEPATH)1
+        LIBMANDIR = $(MANSOURCEPATH)3
+       FILEMANDIR = $(MANSOURCEPATH)5
+       MISCMANDIR = $(MANSOURCEPATH)$(MISCMANSUFFIX)
+
+               AR = ar clq
+  BOOTSTRAPCFLAGS =
+               CC = gcc
+               AS = as
+
+.SUFFIXES: .cc
+
+              CXX = g++
+          CXXFILT = c++filt
+           CXXLIB =
+    CXXDEBUGFLAGS = -O2 -s -mpentium
+CXXDEPENDINCLUDES =
+ CXXEXTRA_DEFINES =
+CXXEXTRA_INCLUDES =
+   CXXSTD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(CXXPROJECT_DEFINES)
+       CXXOPTIONS =
+      CXXINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(CXXEXTRA_INCLUDES)
+       CXXDEFINES = $(CXXINCLUDES) $(CXXSTD_DEFINES) $(THREADS_CXXDEFINES) $(CXXEXTRA_DEFINES) $(DEFINES)
+         CXXFLAGS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(THREADS_CXXFLAGS) $(CXXDEFINES)
+
+         COMPRESS = compress
+          GZIPCMD = gzip
+              CPP = gcc -E - $(STD_CPP_DEFINES)
+    PREPROCESSCMD = gcc -E $(STD_CPP_DEFINES)
+          INSTALL = install
+     INSTALLFLAGS = -c
+               LD = ld
+              LEX = flex -l
+           LEXLIB = -lfl
+             YACC = byacc
+           CCYACC = byacc
+             LINT = lint
+      LINTLIBFLAG = -C
+         LINTOPTS = -axz
+               LN = ln -s
+             MAKE = make
+               MV = mv
+               CP = cp
+
+           RANLIB = ranlib
+  RANLIBINSTFLAGS =
+
+               RM = rm -f
+        MANSUFFIX = 1x
+     LIBMANSUFFIX = 3x
+    FILEMANSUFFIX = 5x
+    MISCMANSUFFIX = 7
+
+            TROFF = psroff
+            NROFF = nroff
+         MSMACROS = -ms
+        MANMACROS = -man
+              TBL = tbl
+              EQN = eqn
+             NEQN = neqn
+              COL = col
+
+            DVIPS = dvips
+            LATEX = latex
+
+     STD_INCLUDES =
+  STD_CPP_DEFINES = -traditional -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+      STD_DEFINES = -D__i386__ -DX_LOCALE -D_MT -DNO_TCP_H $(PROJECT_DEFINES)
+ EXTRA_LOAD_FLAGS =
+  EXTRA_LDOPTIONS =
+  EXTRA_LIBRARIES =
+             TAGS = ctags
+
+    SHAREDCODEDEF =
+         SHLIBDEF =
+
+     SHLIBLDFLAGS =
+
+    PROTO_DEFINES = -DFUNCPROTO=15 -DNARROWPROTO
+
+     INSTPGMFLAGS = -s
+
+     INSTBINFLAGS = -m 0755
+     INSTUIDFLAGS = -s -m 4711
+     INSTLIBFLAGS = -m 0644
+     INSTINCFLAGS = -m 0444
+     INSTMANFLAGS = -m 0444
+     INSTDATFLAGS = -m 0444
+    INSTKMEMFLAGS = -s -m 4711
+
+      PROJECTROOT = /usr/X11R6.4
+
+      CDEBUGFLAGS = -O2 -s -mpentium
+        CCOPTIONS =
+
+      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
+       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(THREADS_DEFINES) $(DEFINES)
+           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(THREADS_CFLAGS) $(ALLDEFINES)
+        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES) $(DEPEND_DEFINES)
+         LDPRELIB = -L$(USRLIBDIR)
+        LDPOSTLIB =
+        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)  $(EXTRA_LDOPTIONS) $(THREADS_LDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+     CXXLDOPTIONS = $(CXXDEBUGFLAGS) $(CXXOPTIONS) $(EXTRA_LDOPTIONS) $(THREADS_CXXLDFLAGS) $(LOCAL_LDFLAGS) $(LDPRELIBS)
+
+           LDLIBS = $(LDPOSTLIBS) $(THREADS_LIBS) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
+
+           CCLINK = $(CC)
+
+          CXXLINK = $(CXX)
+
+     LDSTRIPFLAGS = -x
+   LDCOMBINEFLAGS = -r
+      DEPENDFLAGS =
+
+        MACROFILE = cygwin.cf
+           RM_CMD = $(RM)
+
+    IMAKE_DEFINES =
+
+         IRULESRC = $(CONFIGDIR)
+        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
+
+     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/X11.tmpl 			$(IRULESRC)/site.def $(IRULESRC)/$(MACROFILE) 			 $(EXTRA_ICONFIGFILES)
+
+# $TOG: X11.rules /main/4 1997/04/30 15:23:24 kaleb $
+
+# ----------------------------------------------------------------------
+# X Window System Build Parameters and Rules
+# $TOG: X11.tmpl /main/308 1998/06/16 15:14:24 msr $
+
+# -----------------------------------------------------------------------
+# X Window System make variables; these need to be coordinated with rules
+
+             XTOP = $(TOP)
+           BINDIR = /usr/X11R6.4/bin
+     BUILDINCROOT = $(TOP)/exports
+      BUILDINCDIR = $(BUILDINCROOT)/include
+      BUILDINCTOP = ../..
+      BUILDLIBDIR = $(TOP)/exports/lib
+      BUILDLIBTOP = ../..
+      BUILDBINDIR = $(TOP)/exports/bin
+      BUILDBINTOP = ../..
+    XBUILDINCROOT = $(XTOP)/exports
+     XBUILDINCDIR = $(XBUILDINCROOT)/include/X11
+     XBUILDINCTOP = ../../..
+     XBUILDBINDIR = $(XBUILDINCROOT)/bin
+           INCDIR = $(INCROOT)
+           ADMDIR = /usr/adm
+           LIBDIR = $(USRLIBDIR)/X11
+   TOP_X_INCLUDES = -I$(XPROJECTROOT)/include
+
+           VARDIR = /var/X11
+
+          FONTDIR = $(LIBDIR)/fonts
+         XINITDIR = $(LIBDIR)/xinit
+           XDMDIR = $(LIBDIR)/xdm
+           TWMDIR = $(LIBDIR)/twm
+           XSMDIR = $(LIBDIR)/xsm
+           NLSDIR = $(LIBDIR)/nls
+       XLOCALEDIR = $(LIBDIR)/locale
+        PEXAPIDIR = $(LIBDIR)/PEX
+      LBXPROXYDIR = $(LIBDIR)/lbxproxy
+  PROXYMANAGERDIR = $(LIBDIR)/proxymngr
+        XPRINTDIR = $(LIBDIR)/xserver
+      XAPPLOADDIR = $(LIBDIR)/app-defaults
+       FONTCFLAGS = -t
+
+     INSTAPPFLAGS = $(INSTDATFLAGS)
+
+              RGB = $(BINDIR)/rgb
+            FONTC = $(BINDIR)/bdftopcf
+        MKFONTDIR = $(BINDIR)/mkfontdir
+
+       DOCUTILSRC = $(XTOP)/doc/util
+       XDOCMACROS = $(DOCUTILSRC)/macros.t
+       XIDXMACROS = $(DOCUTILSRC)/indexmacros.t
+       PROGRAMSRC = $(TOP)/programs
+           LIBSRC = $(XTOP)/lib
+          FONTSRC = $(XTOP)/fonts
+       INCLUDESRC = $(BUILDINCROOT)/include
+      XINCLUDESRC = $(INCLUDESRC)/X11
+        SERVERSRC = $(XTOP)/programs/Xserver
+       CONTRIBSRC = $(XTOP)/../contrib
+   UNSUPPORTEDSRC = $(XTOP)/unsupported
+           DOCSRC = $(XTOP)/doc
+           RGBSRC = $(XTOP)/programs/rgb
+      BDFTOPCFSRC = $(PROGRAMSRC)/bdftopcf
+     MKFONTDIRSRC = $(PROGRAMSRC)/mkfontdir
+    FONTSERVERSRC = $(PROGRAMSRC)/xfs
+       FONTINCSRC = $(XTOP)/include/fonts
+        EXTINCSRC = $(XTOP)/include/extensions
+     TRANSCOMMSRC = $(LIBSRC)/xtrans
+   TRANS_INCLUDES = -I$(TRANSCOMMSRC)
+
+   CLIENTENVSETUP =
+
+# $XConsortium: WinLib.tmpl,v 1.1 94/01/08 18:32:51 rws Exp $
+
+          XLIBSRC = $(LIBSRC)/X11
+
+SOXLIBREV = 6.1
+DEPXONLYLIB =
+XONLYLIB =  -lX11
+
+LINTXONLY = $(LINTLIBDIR)/llib-lX11.ln
+
+         XLIBONLY = $(XONLYLIB)
+
+      XEXTLIBSRC = $(LIBSRC)/Xext
+
+SOXEXTREV = 6.4
+DEPEXTENSIONLIB =
+EXTENSIONLIB =  -lXext
+
+LINTEXTENSION = $(LINTLIBDIR)/llib-lXext.ln
+
+LINTEXTENSIONLIB = $(LINTEXTENSION)
+          DEPXLIB = $(DEPEXTENSIONLIB) $(DEPXONLYLIB)
+             XLIB = $(EXTENSIONLIB) $(XONLYLIB)
+         LINTXLIB = $(LINTXONLYLIB)
+
+         XAUTHSRC = $(LIBSRC)/Xau
+
+DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
+XAUTHLIB =  -lXau
+
+LINTXAUTH = $(LINTLIBDIR)/llib-lXau.ln
+
+      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
+
+DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
+XDMCPLIB =  -lXdmcp
+
+LINTXDMCP = $(LINTLIBDIR)/llib-lXdmcp.ln
+
+           XMUSRC = $(LIBSRC)/Xmu
+
+DEPXMULIB = $(USRLIBDIR)/libXmu.a
+XMULIB =  -lXmu
+
+LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
+
+       OLDXLIBSRC = $(LIBSRC)/oldX
+
+SOOLDXREV = 6.0
+DEPOLDXLIB =
+OLDXLIB =  -loldX
+
+LINTOLDX = $(LINTLIBDIR)/llib-loldX.ln
+
+         XPLIBSRC = $(LIBSRC)/Xp
+
+SOXPREV = 6.2
+DEPXPLIB =
+XPLIB =  -lXp
+
+LINTXP = $(LINTLIBDIR)/llib-lXp.ln
+
+       TOOLKITSRC = $(LIBSRC)/Xt
+
+DEPXTOOLONLYLIB = $(USRLIBDIR)/libXt.a
+XTOOLONLYLIB =  -lXt
+
+LINTXTOOLONLY = $(LINTLIBDIR)/llib-lXt.ln
+
+      DEPXTOOLLIB = $(DEPXTOOLONLYLIB) $(DEPSMLIB) $(DEPICELIB)
+         XTOOLLIB = $(XTOOLONLYLIB) $(SMLIB) $(ICELIB)
+     LINTXTOOLLIB = $(LINTXTOOLONLYLIB)
+
+       XALIBSRC = $(LIBSRC)/Xa
+
+SOXAREV = 1.0
+DEPXALIB =
+XALIB =  -lXa
+
+LINTXA = $(LINTLIBDIR)/llib-lXa.ln
+
+       AWIDGETSRC = $(LIBSRC)/Xaw
+
+DEPXAWLIB = $(USRLIBDIR)/libXaw.a
+XAWLIB =  -lXaw
+
+LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
+
+         XILIBSRC = $(LIBSRC)/Xi
+
+SOXINPUTREV = 6.0
+DEPXILIB =
+XILIB =  -lXi
+
+LINTXI = $(LINTLIBDIR)/llib-lXi.ln
+
+      XTESTLIBSRC = $(LIBSRC)/Xtst
+
+SOXTESTREV = 6.1
+DEPXTESTLIB =
+XTESTLIB =  -lXtst
+
+LINTXTEST = $(LINTLIBDIR)/llib-lXtst.ln
+
+        PEXLIBSRC = $(LIBSRC)/PEX5
+
+SOPEXREV = 6.0
+DEPPEXLIB =
+PEXLIB =  -lPEX5
+
+LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
+
+        XIELIBSRC = $(LIBSRC)/XIE
+
+SOXIEREV = 6.0
+DEPXIELIB =
+XIELIB =  -lXIE
+
+LINTXIE = $(LINTLIBDIR)/llib-lXIE.ln
+
+      PHIGSLIBSRC = $(LIBSRC)/PHIGS
+
+DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
+PHIGSLIB =  -lphigs
+
+LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
+
+DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
+XBSDLIB =  -lXbsd
+
+LINTXBSD = $(LINTLIBDIR)/llib-lXbsd.ln
+
+           ICESRC = $(LIBSRC)/ICE
+
+SOICEREV = 6.3
+DEPICELIB =
+ICELIB =  -lICE
+
+LINTICE = $(LINTLIBDIR)/llib-lICE.ln
+
+            SMSRC = $(LIBSRC)/SM
+
+SOSMREV = 6.0
+DEPSMLIB =
+SMLIB =  -lSM
+
+LINTSM = $(LINTLIBDIR)/llib-lSM.ln
+
+           XKEYSRC = $(LIBSRC)/Xkey
+
+SOXKEYREV = 6.0
+DEPXKEYLIB =
+XKEYLIB =  -lXkey
+
+LINTXKEY = $(LINTLIBDIR)/llib-lXkey.ln
+
+         FSLIBSRC = $(LIBSRC)/FS
+
+DEPFSLIB = $(USRLIBDIR)/libFS.a
+FSLIB =  -lFS
+
+LINTFS = $(LINTLIBDIR)/llib-lFS.ln
+
+         FONTLIBSRC = $(LIBSRC)/font
+
+DEPFONTLIB = $(USRLIBDIR)/libfont.a
+FONTLIB =  -lfont
+
+LINTFONT = $(LINTLIBDIR)/llib-lfont.ln
+
+    XKBFILELIBSRC = $(LIBSRC)/xkbfile
+
+DEPXKBFILELIB = $(USRLIBDIR)/libxkbfile.a
+XKBFILELIB =  -lxkbfile
+
+LINTXKBFILE = $(LINTLIBDIR)/llib-lxkbfile.ln
+
+     XKBCOMPCMD = $(BINDIR)/xkbcomp
+
+          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
+
+         DEPLIBS1 = $(DEPLIBS)
+         DEPLIBS2 = $(DEPLIBS)
+         DEPLIBS3 = $(DEPLIBS)
+         DEPLIBS4 = $(DEPLIBS)
+         DEPLIBS5 = $(DEPLIBS)
+         DEPLIBS6 = $(DEPLIBS)
+         DEPLIBS7 = $(DEPLIBS)
+         DEPLIBS8 = $(DEPLIBS)
+         DEPLIBS9 = $(DEPLIBS)
+         DEPLIBS10 = $(DEPLIBS)
+
+XMULIBONLY = -lXmu
+XMULIB = $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
+
+        CONFIGDIR = $(LIBDIR)/config
+
+    USRLIBDIRPATH = $(USRLIBDIR)
+        LDPRELIBS = -L$(USRLIBDIR)
+       LDPOSTLIBS =
+     TOP_INCLUDES = -I$(INCROOT) $(TOP_X_INCLUDES)
+  PROJECT_DEFINES =
+
+CXXPROJECT_DEFINES =
+
+# ----------------------------------------------------------------------
+# start of Imakefile
+
+#
+#
+# Copyright (C) 1989-95 GROUPE BULL
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files
+# (the "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to permit
+# persons to whom the Software is furnished to do so, subject to the
+# following conditions:
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN 0 EVENT SHALL GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+# DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of GROUPE BULL shall not be
+# used in advertising or otherwise to promote the sale, use or other
+# dealings in this Software without prior written authorization from
+# GROUPE BULL.
+#
+
+#
+# XPM Imakefile - Arnaud LE HORS
+#
+
+# default locations
+
+      XPMLIBDIR = $(USRLIBDIR)
+      XPMBINDIR = $(BINDIR)
+      XPMMANDIR = $(MANDIR)
+      XPMINCDIR = $(BUILDINCTOP)
+
+         XPMLIB = -lXpm
+       INCLUDES = -I$(BUILDINCDIR) -I$(XPMINCDIR)
+        DEPLIBS = $(DEPXTOOLLIB) $(DEPXLIB)
+
+LOCAL_LIBRARIES = -L../lib -L$(XPMLIBDIR) $(XPMLIB) $(XTOOLLIB) $(XLIB)
+
+# try hard to set things so we'll find the shared lib once installed
+LD_RUN_PATH = $(USRLIBDIR):$(XPMLIBDIR)
+USRLIBDIRPATH = $(USRLIBDIR):$(XPMLIBDIR)
+
+OS_NAME_DEFINES =
+
+          SRCS = sxpm.c
+          OBJS = sxpm.o
+
+all:: sxpm.exe
+
+all:: sxpm.exe
+sxpm.exe: $(OBJS) $(DEPLIB)
+	$(RM) $@
+	$(CCLINK) -o $@ $(LDOPTIONS) $(OBJS) $(LOCAL_LIBRARIES) $(LDLIBS)  $(EXTRA_LOAD_FLAGS)
+
+clean::
+	$(RM) sxpm.exe
+
+install:: sxpm.exe
+	@if [ -d $(DESTDIR)$(XPMBINDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMBINDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTPGMFLAGS)  sxpm.exe $(DESTDIR)$(XPMBINDIR)/sxpm.exe
+
+install.man:: sxpm.man
+	@if [ -d $(DESTDIR)$(XPMMANDIR) ]; then set +x; \
+	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XPMMANDIR)); fi
+	$(INSTALL) $(INSTALLFLAGS) $(INSTMANFLAGS) sxpm.man $(DESTDIR)$(XPMMANDIR)/sxpm.$(MANSUFFIX)
+
+depend::
+	$(DEPEND) $(DEPENDFLAGS) -- $(ALLDEFINES) $(DEPEND_DEFINES) -- $(SRCS)
+
+lint:
+	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
+lint1:
+	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
+
+clean::
+	$(RM) sxpmout.xpm
+
+# ----------------------------------------------------------------------
+# common rules for all Makefiles - do not edit
+
+.c.i:
+	$(RM) $@
+	 $(CC) -E $(CFLAGS) $(_NOOP_) $*.c > $@
+
+emptyrule::
+
+clean::
+	$(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut  "#"*
+
+Makefile::
+	-@if [ -f Makefile ]; then set -x; \
+	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
+	else exit 0; fi
+	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
+
+tags::
+	$(TAGS) -w *.[ch]
+	$(TAGS) -xw *.[ch] > TAGS
+
+man_keywords::
+
+# ----------------------------------------------------------------------
+# empty rules for directories that do not have SUBDIRS - do not edit
+
+install::
+	@echo "install in $(CURRENT_DIR) done"
+
+install.man::
+	@echo "install.man in $(CURRENT_DIR) done"
+
+install.linkkit::
+	@echo "install.linkkit in $(CURRENT_DIR) done"
+
+Makefiles::
+
+includes::
+
+depend::
+
+# ----------------------------------------------------------------------
+# dependencies generated by makedepend
+
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Makefile.noX rxvt-2.7.2/W11/xpm-3.4k/sxpm/Makefile.noX
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/Makefile.noX	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/Makefile.noX	Mon May 14 08:23:10 2001
@@ -0,0 +1,69 @@
+#
+#  Copyright (C) 1989-95 GROUPE BULL
+#
+#  Permission is hereby granted, free of charge, to any person obtaining a copy
+#  of this software and associated documentation files (the "Software"), to
+#  deal in the Software without restriction, including without limitation the
+#  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+#  sell copies of the Software, and to permit persons to whom the Software is
+#  furnished to do so, subject to the following conditions:
+#
+#  The above copyright notice and this permission notice shall be included in
+#  all copies or substantial portions of the Software.
+#
+#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#  GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+#  AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+#  Except as contained in this notice, the name of GROUPE BULL shall not be
+#  used in advertising or otherwise to promote the sale, use or other dealings
+#  in this Software without prior written authorization from GROUPE BULL.
+#
+
+#
+# XPM Makefile - Arnaud LE HORS
+#
+
+# where the program will be installed
+DESTBINDIR=/usr/local/bin/X11
+# where the man page will be installed
+MANDIR=/usr/local/man/manl
+
+# where the X11 libs are
+XLIBDIRS= -L/usr/X11/lib
+
+LIBDIRS= -L../lib
+LIBS= -lXpm -lXext -lXt -lX11
+
+CC = cc
+RM = rm -f
+# on sysV, define this as cp.
+INSTALL = install -c
+
+CDEBUGFLAGS= -O
+
+INCLUDES= -I..
+
+OBJS= sxpm.o
+
+CFLAGS= $(CDEBUGFLAGS) $(INCLUDES) $(DEFINES)
+
+all: sxpm
+
+clean: 
+	$(RM) *.o sxpm
+
+sxpm: sxpm.o
+	$(CC) $(CFLAGS) sxpm.o $(LIBDIRS) $(XLIBDIRS) $(LIBS) -o sxpm
+
+install:
+	$(INSTALL) -m 0755 sxpm $(DESTBINDIR)
+
+install.man:
+	$(INSTALL) -m 0644 sxpm.man $(MANDIR)/sxpm.l
+
+# Other dependencies.
+sxpm.o: ../lib/xpm.h
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/plaid.xpm rxvt-2.7.2/W11/xpm-3.4k/sxpm/plaid.xpm
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/plaid.xpm	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/plaid.xpm	Mon May 14 08:23:10 2001
@@ -0,0 +1,34 @@
+/* XPM */
+static char * plaid[] = {
+/* plaid pixmap 
+ * width height ncolors chars_per_pixel */
+"22 22 4 2 ",
+/* colors */
+"   c red 	m white  s light_color ",
+"Y  c green	m black  s lines_in_mix ",
+"+  c yellow	m white  s lines_in_dark ",
+"x 		m black  s dark_color ",
+/* pixels */
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"Y Y Y Y Y x Y Y Y Y Y + x + x + x + x + x + ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ",
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ", 
+"          x           x   x   x Y x   x   x ", 
+"x x x x x x x x x x x x x x x x x x x x x x ", 
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ", 
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ", 
+"          x           x   x   x Y x   x   x "
+} ;
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/plaid_ext.xpm rxvt-2.7.2/W11/xpm-3.4k/sxpm/plaid_ext.xpm
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/plaid_ext.xpm	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/plaid_ext.xpm	Mon May 14 08:23:10 2001
@@ -0,0 +1,43 @@
+/* XPM */
+static char * plaid[] = {
+/* plaid pixmap 
+ * width height ncolors chars_per_pixel */
+"22 22 4 2 XPMEXT",
+/* colors */
+"   c red 	m white  s light_color ",
+"Y  c green	m black  s lines_in_mix ",
+"+  c yellow	m white  s lines_in_dark ",
+"x 		m black  s dark_color ",
+/* pixels */
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"Y Y Y Y Y x Y Y Y Y Y + x + x + x + x + x + ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"  x   x   x   x   x   x x x x x x x x x x x ", 
+"x   x   x x x   x   x x x x x x + x x x x x ", 
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ",
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ", 
+"          x           x   x   x Y x   x   x ", 
+"x x x x x x x x x x x x x x x x x x x x x x ", 
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ", 
+"          x           x   x   x Y x   x   x ", 
+"          x             x   x   Y   x   x   ", 
+"          x           x   x   x Y x   x   x ",
+"XPMEXT ext1 data1",
+"XPMEXT ext2",
+"data2_1",
+"data2_2",
+"XPMEXT ext3",
+"data3",
+"XPMEXT",
+"data4",
+"XPMENDEXT"
+} ;
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/plaid_mask.xpm rxvt-2.7.2/W11/xpm-3.4k/sxpm/plaid_mask.xpm
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/plaid_mask.xpm	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/plaid_mask.xpm	Mon May 14 08:23:10 2001
@@ -0,0 +1,35 @@
+/* XPM */
+static char * plaid[] = {
+/* plaid pixmap 
+ * width height ncolors chars_per_pixel */
+"22 22 5 2",
+/* colors */
+".  c red 	m white  s light_color ",
+"Y  c green	m black  s lines_in_mix ",
+"+  c yellow	m white  s lines_in_dark ",
+"x  		m black  s dark_color ",
+"   c none		 s mask ",
+/* pixels */
+"                      x x x x x + x x x x x ", 
+"                    . x x x x x x x x x x x ", 
+"                  . x x x x x x + x x x x x ", 
+"                . x . x x x x x x x x x x x ", 
+"              . x . x x x x x x + x x x x x ", 
+"            Y Y Y Y Y + x + x + x + x + x + ", 
+"          x x . x . x x x x x x + x x x x x ", 
+"        . x . x . x . x x x x x x x x x x x ", 
+"      . x x x . x . x x x x x x + x x x x x ", 
+"    . x . x . x . x . x x x x x x x x x x x ", 
+"  . x . x x x . x . x x x x x x + x x x x x ", 
+". . . . . x . . . . . x . x . x Y x . x . x ", 
+". . . . . x . . . . . . x . x . Y . x . x . ",
+". . . . . x . . . . . x . x . x Y x . x . x ", 
+". . . . . x . . . . . . x . x . Y . x . x . ", 
+". . . . . x . . . . . x . x . x Y x . x . x ", 
+"x x x x x x x x x x x x x x x x x x x x x x ", 
+". . . . . x . . . . . x . x . x Y x . x . x ", 
+". . . . . x . . . . . . x . x . Y . x . x . ", 
+". . . . . x . . . . . x . x . x Y x . x . x ", 
+". . . . . x . . . . . . x . x . Y . x . x . ", 
+". . . . . x . . . . . x . x . x Y x . x . x "
+} ;
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/sxpm.c rxvt-2.7.2/W11/xpm-3.4k/sxpm/sxpm.c
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/sxpm.c	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/sxpm.c	Mon May 14 08:23:10 2001
@@ -0,0 +1,705 @@
+/*
+ * Copyright (C) 1989-95 GROUPE BULL
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of GROUPE BULL shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from GROUPE BULL.
+ */
+
+/*****************************************************************************\
+* sxpm.c:                                                                     *
+*                                                                             *
+*  Show XPM File program                                                      *
+*                                                                             *
+*  Developed by Arnaud Le Hors                                                *
+\*****************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <X11/StringDefs.h>
+#include <X11/Intrinsic.h>
+#include <X11/IntrinsicP.h>
+#include <X11/Shell.h>
+
+#ifdef VMS
+#include <X11/shape.h>
+#else
+#include <X11/extensions/shape.h>
+#endif
+
+#include <X11/xpm.h>
+
+/* XPM */
+/* plaid pixmap */
+static char *plaid[] = {
+    /* width height ncolors chars_per_pixel */
+    "22 22 4 2 XPMEXT",
+    /* colors */
+    "   c red 	m white  s light_color",
+    "Y  c green	m black  s lines_in_mix",
+    "+  c yellow	m white  s lines_in_dark",
+    "x 		m black  s dark_color",
+    /* pixels */
+    "x   x   x x x   x   x x x x x x + x x x x x ",
+    "  x   x   x   x   x   x x x x x x x x x x x ",
+    "x   x   x x x   x   x x x x x x + x x x x x ",
+    "  x   x   x   x   x   x x x x x x x x x x x ",
+    "x   x   x x x   x   x x x x x x + x x x x x ",
+    "Y Y Y Y Y x Y Y Y Y Y + x + x + x + x + x + ",
+    "x   x   x x x   x   x x x x x x + x x x x x ",
+    "  x   x   x   x   x   x x x x x x x x x x x ",
+    "x   x   x x x   x   x x x x x x + x x x x x ",
+    "  x   x   x   x   x   x x x x x x x x x x x ",
+    "x   x   x x x   x   x x x x x x + x x x x x ",
+    "          x           x   x   x Y x   x   x ",
+    "          x             x   x   Y   x   x   ",
+    "          x           x   x   x Y x   x   x ",
+    "          x             x   x   Y   x   x   ",
+    "          x           x   x   x Y x   x   x ",
+    "x x x x x x x x x x x x x x x x x x x x x x ",
+    "          x           x   x   x Y x   x   x ",
+    "          x             x   x   Y   x   x   ",
+    "          x           x   x   x Y x   x   x ",
+    "          x             x   x   Y   x   x   ",
+    "          x           x   x   x Y x   x   x ",
+    "bullshit",
+    "XPMEXT ext1 data1",
+    "XPMEXT ext2",
+    "data2_1",
+    "data2_2",
+    "XPMEXT",
+    "foo",
+    "",
+    "XPMEXT ext3",
+    "data3",
+    "XPMENDEXT"
+};
+
+#define win XtWindow(topw)
+#define dpy XtDisplay(topw)
+#define root XRootWindowOfScreen(XtScreen(topw))
+#define xrdb XtDatabase(dpy)
+static Colormap colormap;
+
+void Usage();
+void ErrorMessage();
+void Punt();
+void VersionInfo();
+
+#ifdef __STDC__
+void kinput(Widget widget, char *tag, XEvent *xe, Boolean *b);
+#else
+void kinput();
+#endif
+
+#define IWIDTH      50
+#define IHEIGHT     50
+
+typedef struct _XpmIcon {
+    Pixmap pixmap;
+    Pixmap mask;
+    XpmAttributes attributes;
+}        XpmIcon;
+
+static char **command;
+static Widget topw;
+static XpmIcon view, icon;
+static XrmOptionDescRec options[] = {
+    {"-hints", ".hints", XrmoptionNoArg, (XtPointer) "True"},
+    {"-icon", ".icon", XrmoptionSepArg, (XtPointer) NULL},
+};
+
+main(argc, argv)
+    int argc;
+    char **argv;
+{
+    int ErrorStatus;
+    unsigned int verbose = 0;		/* performs verbose output */
+    unsigned int stdinf = 1;		/* read from stdin */
+    unsigned int stdoutf = 0;		/* write to stdout */
+    unsigned int nod = 0;		/* no display */
+    unsigned int nom = 0;		/* no mask display */
+    unsigned int incResize = 0;
+    unsigned int resize = 0;
+    unsigned int w_rtn;
+    unsigned int h_rtn;
+    char *input = NULL;
+    char *output = NULL;
+    char *iconFile = NULL;
+    unsigned int numsymbols = 0;
+    XpmColorSymbol symbols[10];
+    char *stype;
+    XrmValue val;
+    unsigned long valuemask = 0;
+    int n;
+    Arg args[4];
+
+#ifdef Debug
+    char **data;
+    char *buffer;
+#endif
+
+    topw = XtInitialize(argv[0], "Sxpm",
+			options, XtNumber(options), &argc, argv);
+
+    if (!topw) {
+	fprintf(stderr, "Sxpm Error... [ Undefined DISPLAY ]\n");
+	exit(1);
+    }
+    colormap = XDefaultColormapOfScreen(XtScreen(topw));
+
+    /*
+     * geometry management
+     */
+
+    if (XrmGetResource(xrdb, NULL, "sxpm.geometry", &stype, &val)
+	|| XrmGetResource(xrdb, NULL, "Sxpm.geometry", &stype, &val)) {
+
+	int flags;
+	int x_rtn;
+	int y_rtn;
+	char *geo = NULL;
+
+	geo = (char *) val.addr;
+	flags = XParseGeometry(geo, &x_rtn, &y_rtn,
+			       (unsigned int *) &w_rtn,
+			       (unsigned int *) &h_rtn);
+
+	if (!((WidthValue & flags) && (HeightValue & flags)))
+	    resize = 1;
+
+    } else
+	resize = 1;
+
+    n = 0;
+    if (resize) {
+	w_rtn = 0;
+	h_rtn = 0;
+	XtSetArg(args[n], XtNwidth, 1);
+	n++;
+	XtSetArg(args[n], XtNheight, 1);
+	n++;
+    }
+    XtSetArg(args[n], XtNmappedWhenManaged, False);
+    n++;
+    XtSetArg(args[n], XtNinput, True);
+    n++;
+    XtSetValues(topw, args, n);
+
+    if ((XrmGetResource(xrdb, "sxpm.hints", "", &stype, &val)
+	 || XrmGetResource(xrdb, "Sxpm.hints", "", &stype, &val))
+	&& !strcmp((char *) val.addr, "True")) {
+	/* gotcha */
+	incResize = 1;
+	resize = 1;
+    }
+
+    /*
+     * icon management
+     */
+
+    if (XrmGetResource(xrdb, "sxpm.icon", "", &stype, &val)
+	|| XrmGetResource(xrdb, "Sxpm.icon", "", &stype, &val)) {
+	iconFile = (char *) val.addr;
+    }
+    if (iconFile) {
+
+	XColor color, junk;
+	Pixel bpix;
+	Window iconW;
+
+	if (XAllocNamedColor(dpy, colormap, "black", &color, &junk))
+	    bpix = color.pixel;
+	else
+	    bpix = XBlackPixelOfScreen(XtScreen(topw));
+
+	iconW = XCreateSimpleWindow(dpy, root, 0, 0,
+				    IWIDTH, IHEIGHT, 1, bpix, bpix);
+
+	icon.attributes.valuemask = XpmReturnAllocPixels;
+	ErrorStatus = XpmReadFileToPixmap(dpy, root, iconFile, &icon.pixmap,
+					  &icon.mask, &icon.attributes);
+	ErrorMessage(ErrorStatus, "Icon");
+
+	XSetWindowBackgroundPixmap(dpy, iconW, icon.pixmap);
+
+	n = 0;
+	XtSetArg(args[n], XtNbackground, bpix);
+	n++;
+	XtSetArg(args[n], XtNiconWindow, iconW);
+	n++;
+	XtSetValues(topw, args, n);
+    }
+
+    /*
+     * arguments parsing
+     */
+
+    command = argv;
+    for (n = 1; n < argc; n++) {
+	if (strcmp(argv[n], "-plaid") == 0) {
+	    stdinf = 0;
+	    continue;
+	}
+	if (argv[n][0] != '-') {
+	    stdinf = 0;
+	    input = argv[n];
+	    continue;
+	}
+	if ((strlen(argv[n]) == 1) && (argv[n][0] == '-'))
+	    /* stdin */
+	    continue;
+	if (strcmp(argv[n], "-o") == 0) {
+	    if (n < argc - 1) {
+		if ((strlen(argv[n + 1]) == 1) && (argv[n + 1][0] == '-'))
+		    stdoutf = 1;
+		else
+		    output = argv[n + 1];
+		n++;
+		continue;
+	    } else
+		Usage();
+	}
+	if (strcmp(argv[n], "-nod") == 0) {
+	    nod = 1;
+	    continue;
+	}
+	if (strcmp(argv[n], "-nom") == 0) {
+	    nom = 1;
+	    continue;
+	}
+	if (strcmp(argv[n], "-sc") == 0) {
+	    if (n < argc - 2) {
+		valuemask |= XpmColorSymbols;
+		symbols[numsymbols].name = argv[++n];
+		symbols[numsymbols++].value = argv[++n];
+		continue;
+	    } else
+		Usage();
+	}
+	if (strcmp(argv[n], "-sp") == 0) {
+	    if (n < argc - 2) {
+		valuemask |= XpmColorSymbols;
+		symbols[numsymbols].name = argv[++n];
+		symbols[numsymbols].value = NULL;
+		symbols[numsymbols++].pixel = atol(argv[++n]);
+		continue;
+	    }
+	}
+	if (strcmp(argv[n], "-cp") == 0) {
+	    if (n < argc - 2) {
+		valuemask |= XpmColorSymbols;
+		symbols[numsymbols].name = NULL;
+		symbols[numsymbols].value = argv[++n];
+		symbols[numsymbols++].pixel = atol(argv[++n]);
+		continue;
+	    }
+	}
+	if (strcmp(argv[n], "-mono") == 0) {
+	    valuemask |= XpmColorKey;
+	    view.attributes.color_key = XPM_MONO;
+	    continue;
+	}
+	if (strcmp(argv[n], "-gray4") == 0 || strcmp(argv[n], "-grey4") == 0) {
+	    valuemask |= XpmColorKey;
+	    view.attributes.color_key = XPM_GRAY4;
+	    continue;
+	}
+	if (strcmp(argv[n], "-gray") == 0 || strcmp(argv[n], "-grey") == 0) {
+	    valuemask |= XpmColorKey;
+	    view.attributes.color_key = XPM_GRAY;
+	    continue;
+	}
+	if (strcmp(argv[n], "-color") == 0) {
+	    valuemask |= XpmColorKey;
+	    view.attributes.color_key = XPM_COLOR;
+	    continue;
+	}
+	if (strncmp(argv[n], "-closecolors", 6) == 0) {
+	    valuemask |= XpmCloseness;
+	    view.attributes.closeness = 40000;
+	    continue;
+	}
+	if (strcmp(argv[n], "-rgb") == 0) {
+	    if (n < argc - 1) {
+		valuemask |= XpmRgbFilename;
+		view.attributes.rgb_fname = argv[++n];
+		continue;
+	    } else
+		Usage();
+
+	}
+	if (strncmp(argv[n], "-version", 4) == 0) {
+	    VersionInfo();
+	    exit(0);
+	}
+	if (strcmp(argv[n], "-v") == 0) {
+	    verbose = 1;
+	    continue;
+	}
+	if (strcmp(argv[n], "-pcmap") == 0) {
+	    valuemask |= XpmColormap;
+	    continue;
+	}
+	Usage();
+    }
+
+    XtRealizeWidget(topw);
+    if (valuemask & XpmColormap) {
+	colormap = XCreateColormap(dpy, win,
+				   DefaultVisual(dpy, DefaultScreen(dpy)),
+				   AllocNone);
+	view.attributes.colormap = colormap;
+	XSetWindowColormap(dpy, win, colormap);
+    }
+    view.attributes.colorsymbols = symbols;
+    view.attributes.numsymbols = numsymbols;
+    view.attributes.valuemask = valuemask;
+
+#ifdef Debug
+    /* this is just to test the XpmCreateDataFromPixmap function */
+
+    view.attributes.valuemask |= XpmReturnAllocPixels;
+    view.attributes.valuemask |= XpmReturnExtensions;
+    ErrorStatus = XpmCreatePixmapFromData(dpy, win, plaid,
+					  &view.pixmap, &view.mask,
+					  &view.attributes);
+    ErrorMessage(ErrorStatus, "Plaid");
+
+    ErrorStatus = XpmCreateDataFromPixmap(dpy, &data, view.pixmap, view.mask,
+					  &view.attributes);
+    ErrorMessage(ErrorStatus, "Data");
+    if (verbose && view.attributes.nextensions) {
+	unsigned int i, j;
+
+	for (i = 0; i < view.attributes.nextensions; i++) {
+	    fprintf(stderr, "Xpm extension : %s\n",
+		    view.attributes.extensions[i].name);
+	    for (j = 0; j < view.attributes.extensions[i].nlines; j++)
+		fprintf(stderr, "\t\t%s\n",
+			view.attributes.extensions[i].lines[j]);
+	}
+    }
+    XFreePixmap(dpy, view.pixmap);
+    if (view.mask)
+	XFreePixmap(dpy, view.mask);
+
+    XFreeColors(dpy, colormap,
+		view.attributes.alloc_pixels,
+		view.attributes.nalloc_pixels, 0);
+
+    XpmFreeAttributes(&view.attributes);
+    view.attributes.valuemask = valuemask;
+#endif
+
+    if (input || stdinf) {
+	view.attributes.valuemask |= XpmReturnInfos;
+	view.attributes.valuemask |= XpmReturnAllocPixels;
+	view.attributes.valuemask |= XpmReturnExtensions;
+
+#ifdef Debug
+	XpmFree(data);
+
+	/*
+	 * this is just to test the XpmCreatePixmapFromBuffer and
+	 * XpmCreateBufferFromPixmap functions
+	 */
+	ErrorStatus = XpmReadFileToBuffer(input, &buffer);
+	ErrorMessage(ErrorStatus, "CreateBufferFromFile");
+
+	ErrorStatus = XpmCreatePixmapFromBuffer(dpy, win, buffer,
+						&view.pixmap, &view.mask,
+						&view.attributes);
+	ErrorMessage(ErrorStatus, "CreatePixmapFromBuffer");
+	XpmFree(buffer);
+	ErrorStatus = XpmCreateBufferFromPixmap(dpy, &buffer,
+						view.pixmap, view.mask,
+						&view.attributes);
+	ErrorMessage(ErrorStatus, "CreateBufferFromPixmap");
+	ErrorStatus = XpmWriteFileFromBuffer("buffer_output", buffer);
+	ErrorMessage(ErrorStatus, "WriteFileFromBuffer");
+	XpmFree(buffer);
+	if (view.pixmap) {
+	    XFreePixmap(dpy, view.pixmap);
+	    if (view.mask)
+		XFreePixmap(dpy, view.mask);
+
+	    XFreeColors(dpy, colormap, view.attributes.alloc_pixels,
+			view.attributes.nalloc_pixels, 0);
+
+	    XpmFreeAttributes(&view.attributes);
+	}
+	ErrorStatus = XpmReadFileToData(input, &data);
+	ErrorMessage(ErrorStatus, "ReadFileToData");
+	ErrorStatus = XpmCreatePixmapFromData(dpy, win, data,
+					      &view.pixmap, &view.mask,
+					      &view.attributes);
+	ErrorMessage(ErrorStatus, "CreatePixmapFromData");
+	ErrorStatus = XpmWriteFileFromData("sxpmout.xpm", data);
+	ErrorMessage(ErrorStatus, "WriteFileFromData");
+	XpmFree(data);
+	XpmFreeAttributes(&view.attributes);
+#endif
+	ErrorStatus = XpmReadFileToPixmap(dpy, win, input,
+					  &view.pixmap, &view.mask,
+					  &view.attributes);
+	ErrorMessage(ErrorStatus, "Read");
+	if (verbose && view.attributes.nextensions) {
+	    unsigned int i, j;
+
+	    for (i = 0; i < view.attributes.nextensions; i++) {
+		fprintf(stderr, "Xpm extension : %s\n",
+			view.attributes.extensions[i].name);
+		for (j = 0; j < view.attributes.extensions[i].nlines; j++)
+		    fprintf(stderr, "\t\t%s\n",
+			    view.attributes.extensions[i].lines[j]);
+	    }
+	}
+    } else {
+#ifdef Debug
+	ErrorStatus = XpmCreatePixmapFromData(dpy, win, data,
+					      &view.pixmap, &view.mask,
+					      &view.attributes);
+	XpmFree(data);
+#else
+	ErrorStatus = XpmCreatePixmapFromData(dpy, win, plaid,
+					      &view.pixmap, &view.mask,
+					      &view.attributes);
+#endif
+	ErrorMessage(ErrorStatus, "Plaid");
+    }
+    if (output || stdoutf) {
+	ErrorStatus = XpmWriteFileFromPixmap(dpy, output, view.pixmap,
+					     view.mask, &view.attributes);
+	ErrorMessage(ErrorStatus, "Write");
+    }
+    if (!nod) {
+
+	/*
+	 * manage display if requested
+	 */
+
+	XSizeHints size_hints;
+	char *xString = NULL;
+
+	if (w_rtn && h_rtn
+	    && ((w_rtn < view.attributes.width)
+		|| h_rtn < view.attributes.height)) {
+	    resize = 1;
+	}
+	if (resize) {
+	    XtResizeWidget(topw,
+			   view.attributes.width, view.attributes.height, 1);
+	}
+	if (incResize) {
+	    size_hints.flags = USSize | PMinSize | PResizeInc;
+	    size_hints.height = view.attributes.height;
+	    size_hints.width = view.attributes.width;
+	    size_hints.height_inc = view.attributes.height;
+	    size_hints.width_inc = view.attributes.width;
+	} else
+	    size_hints.flags = PMinSize;
+
+	size_hints.min_height = view.attributes.height;
+	size_hints.min_width = view.attributes.width;
+	XSetWMNormalHints(dpy, win, &size_hints);
+
+	if (input) {
+	    xString = (char *) XtMalloc((sizeof(char) * strlen(input)) + 20);
+	    sprintf(xString, "Sxpm: %s", input);
+	    XStoreName(dpy, win, xString);
+	    XSetIconName(dpy, win, xString);
+	} else if (stdinf) {
+	    XStoreName(dpy, win, "Sxpm: stdin");
+	    XSetIconName(dpy, win, "Sxpm: stdin");
+	} else {
+	    XStoreName(dpy, win, "Sxpm");
+	    XSetIconName(dpy, win, "Sxpm");
+	}
+
+	XtAddEventHandler(topw, KeyPressMask, False,
+			  (XtEventHandler) kinput, NULL);
+	XSetWindowBackgroundPixmap(dpy, win, view.pixmap);
+
+	if (view.mask && !nom)
+	    XShapeCombineMask(dpy, win, ShapeBounding, 0, 0,
+			      view.mask, ShapeSet);
+
+	XClearWindow(dpy, win);
+	XtMapWidget(topw);
+	if (xString)
+	    XtFree(xString);
+	XtMainLoop();
+    }
+    Punt(0);
+}
+
+void
+Usage()
+{
+    fprintf(stderr, "\nUsage:  %s [options...]\n", command[0]);
+    fprintf(stderr, "Where options are:\n\
+\n\
+[-d host:display]            Display to connect to.\n\
+[-g geom]                    Geometry of window.\n\
+[-hints]                     Set ResizeInc for window.\n\
+[-icon filename]             Set pixmap for iconWindow.\n\
+[-plaid]                     Read the included plaid pixmap.\n\
+[filename]                   Read from file 'filename', and from standard\n\
+                             input if 'filename' is '-'.\n\
+[-o filename]                Write to file 'filename', and to standard\n\
+                             output if 'filename' is '-'.\n\
+[-pcmap]                     Use a private colormap.\n\
+[-closecolors]               Try to use `close' colors.\n\
+[-nod]                       Don't display in window.\n\
+[-nom]                       Don't use clip mask if any.\n\
+[-mono]                      Use the colors specified for a monochrome visual.\n\
+[-grey4]                     Use the colors specified for a 4 greyscale visual.\n\
+[-grey]                      Use the colors specified for a greyscale visual.\n\
+[-color]                     Use the colors specified for a color visual.\n\
+[-sc symbol color]           Override color defaults.\n\
+[-sp symbol pixel]           Override color defaults.\n\
+[-cp color pixel]            Override color defaults.\n\
+[-rgb filename]              Search color names in the rgb text file 'filename'.\n\
+[-v]                         Verbose - print out extensions.\n\
+[-version]                   Print out program's version number\n\
+                             and library's version number if different.\n\
+if no input is specified sxpm reads from standard input.\n\
+\n");
+    exit(0);
+}
+
+
+void
+ErrorMessage(ErrorStatus, tag)
+    int ErrorStatus;
+    char *tag;
+{
+    char *error = NULL;
+    char *warning = NULL;
+
+    switch (ErrorStatus) {
+    case XpmSuccess:
+	return;
+    case XpmColorError:
+	warning = "Could not parse or alloc requested color";
+	break;
+    case XpmOpenFailed:
+	error = "Cannot open file";
+	break;
+    case XpmFileInvalid:
+	error = "Invalid XPM file";
+	break;
+    case XpmNoMemory:
+	error = "Not enough memory";
+	break;
+    case XpmColorFailed:
+	error = "Failed to parse or alloc some color";
+	break;
+    }
+
+    if (warning)
+	fprintf(stderr, "%s Xpm Warning: %s.\n", tag, warning);
+
+    if (error) {
+	fprintf(stderr, "%s Xpm Error: %s.\n", tag, error);
+	Punt(1);
+    }
+}
+
+void
+Punt(i)
+    int i;
+{
+    if (icon.pixmap) {
+	XFreePixmap(dpy, icon.pixmap);
+	if (icon.mask)
+	    XFreePixmap(dpy, icon.mask);
+
+	XFreeColors(dpy, colormap,
+		    icon.attributes.alloc_pixels,
+		    icon.attributes.nalloc_pixels, 0);
+
+	XpmFreeAttributes(&icon.attributes);
+    }
+    if (view.pixmap) {
+	XFreePixmap(dpy, view.pixmap);
+	if (view.mask)
+	    XFreePixmap(dpy, view.mask);
+
+	XFreeColors(dpy, colormap,
+		    view.attributes.alloc_pixels,
+		    view.attributes.nalloc_pixels, 0);
+
+	XpmFreeAttributes(&view.attributes);
+    }
+    exit(i);
+}
+
+void
+kinput(widget, tag, xe, b)
+    Widget widget;
+    char *tag;
+    XEvent *xe;
+    Boolean *b;
+{
+    char c = '\0';
+
+    XLookupString(&(xe->xkey), &c, 1, NULL, NULL);
+    if (c == 'q' || c == 'Q')
+	Punt(0);
+}
+
+/*
+ * small function to extract various version numbers from the given global
+ * number (following the rule described in xpm.h).
+ */
+void
+GetNumbers(num, format_return, libmajor_return, libminor_return)
+    int num;
+    int *format_return;
+    int *libmajor_return;
+    char *libminor_return;
+{
+    *format_return = num / 10000;
+    *libmajor_return = (num % 10000) / 100;
+    *libminor_return = 'a' + (num % 10000) % 100 - 1;
+}
+
+void
+VersionInfo()
+{
+    int num;
+    int format, libmajor;
+    char libminor;
+
+    GetNumbers(XpmIncludeVersion, &format, &libmajor, &libminor);
+    fprintf(stderr, "sxpm version: %d.%d%c\n",
+	    format, libmajor, libminor);
+    /*
+     * if we are linked to an XPM library different from the one we've been
+     * compiled with, print its own number too.
+     */
+    if (XpmIncludeVersion != XpmLibraryVersion()) {
+	GetNumbers(XpmLibraryVersion(), &format, &libmajor, &libminor);
+	fprintf(stderr, "using the XPM library version: %d.%d%c\n",
+		format, libmajor, libminor);
+    }
+}
Binary files rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/sxpm.exe and rxvt-2.7.2/W11/xpm-3.4k/sxpm/sxpm.exe differ
diff -urN rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/sxpm.man rxvt-2.7.2/W11/xpm-3.4k/sxpm/sxpm.man
--- rxvt-2.7.2-orig/W11/xpm-3.4k/sxpm/sxpm.man	Wed Dec 31 16:00:00 1969
+++ rxvt-2.7.2/W11/xpm-3.4k/sxpm/sxpm.man	Mon May 14 08:23:10 2001
@@ -0,0 +1,131 @@
+.\"Copyright (C) 1989-95 GROUPE BULL
+.\"
+.\"Permission is hereby granted, free of charge, to any person obtaining a copy
+.\"of this software and associated documentation files (the "Software"), to
+.\"deal in the Software without restriction, including without limitation the
+.\"rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+.\"sell copies of the Software, and to permit persons to whom the Software is
+.\"furnished to do so, subject to the following conditions:
+.\"
+.\"The above copyright notice and this permission notice shall be included in
+.\"all copies or substantial portions of the Software.
+.\"
+.\"THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+.\"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+.\"FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+.\"GROUPE BULL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+.\"AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+.\"CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+.\"
+.\"Except as contained in this notice, the name of GROUPE BULL shall not be
+.\"used in advertising or otherwise to promote the sale, use or other dealings
+.\"in this Software without prior written authorization from GROUPE BULL.
+.\"
+.nr )S 12
+.TH SXPM 1
+.PD
+.ad b
+.SH NAME
+sxpm \- Show an XPM (X PixMap) file and/or convert XPM 1 or 2 files to XPM 3.
+.SH SYNOPSIS
+\fBsxpm\fR
+[\|\fB-d\fR displayname\|] 
+[\|\fB-g\fR geometry\|] 
+[\|\fB-hints\fR\|] 
+[\|\fB-icon\fR filename\|] 
+[\|\fB-plaid\| | \|\fRfilename\| | \|-\|]
+[\|\fB-o\fR filename\| | \|\fB-o\fR -\|] 
+[\|\fB-pcmap\fR\|] 
+[\|\fB-closecolors\fR\|] 
+[\|\fB-nod\fR\|] 
+[\|\fB-nom\fR\|] 
+[\|\fB-mono | -grey4 | -grey | -color\fR\|] 
+[\|\fB-sc\fR symbol color\|] 
+[\|\fB-sp\fR symbol pixel\|] 
+[\|\fB-cp\fR color pixel\|] 
+[\|\fB-rgb\fR filename\|] 
+[\|\fB-v\fR\|] 
+.SH DESCRIPTION
+.PP
+The \fIsxpm\fP program can be used to view any XPM (version 1, 2, or 3) file
+and/or to convert a file from XPM1 or XPM2 to XPM version 3. If \fIsxpm\fP is
+run with any dummy option specified, the usage is displayed. If no geometry is
+specified, the show window will have the size of the read pixmap. Pressing the
+key Q in the window will quit the program.
+.SH OPTIONS
+.TP 8
+.B \-d \fIdisplay\fP
+Specifies the display to connect to.
+.TP 8
+.B \-g \fIgeom\fP
+Window geometry (default is pixmap's size).
+.TP 8
+.B \-hints
+Set ResizeInc for window.
+.TP 8
+.B \-icon \fIfilename\fP
+Set icon to pixmap created from the file \fIfilename\fP.
+.TP 8
+.B \-plaid
+Show the plaid pixmap which is stored as data\fP.
+.TP 8
+.B \fIfilename\fP
+Read from the file \fIfilename\fP and from standard input if \fIfilename\fP is '-'.
+If no input is specified sxpm reads from standard input.
+.TP 8
+.B \-o \fIfilename\fP
+Write to the file \fIfilename\fP (overwrite if it already exists) and to
+standard output if \fIfilename\fP is '-'.
+.TP 8
+.B \-mono
+Use the colors specified for a monochrome visual.
+.TP 8
+.B \-grey4
+Use the colors specified for a 4 color greyscale visual.
+.TP 8
+.B \-grey
+Use the colors specified for a greyscale visual.
+.TP 8
+.B \-color
+Use the colors specified for a color visual.
+.TP 8
+.B \-pcmap
+Use a private colormap.
+.TP 8
+.B \-closecolors
+Try to use "close colors" before reverting to other visuals.
+.TP 8
+.B \-nod
+Do not display the pixmap in a window.  (Useful when using as converter)
+.TP 8
+.B \-nom
+Do not use the clipmask if there is any.
+.TP 8
+.B \-sc \fIsymbol colorname\fP
+Override default color to \fIsymbol\fP to \fIcolorname\fp.
+.TP 8
+.B \-sp \fIsymbol pixelvalue\fP
+Override default color to \fIsymbol\fP to \fIpixelvalue\fp.
+.TP 8
+.B \-cp \fIcolorname pixelvalue\fP
+Override default color to \fIcolorname\fP to \fIpixelvalue\fp.
+.TP 8
+.B \-rgb \fIfilename\fP
+Search color names in the file \fIfilename\fP and write them out instead of
+the rgb values.
+.TP 8
+.B \-v
+Verbose - to print out extensions (stderr).
+
+
+.SH KNOWN BUGS
+Some window managers may not accept a pixmap which is not a bitmap as icon
+because this does not respect ICCCM, many of the well known ones will accept
+it though.
+
+.SH AUTHOR
+Arnaud Le Hors    (lehors@sophia.inria.fr)
+.br
+Bull Research France
+.br
+Copyright (C) 1989-95 by Groupe Bull.
diff -urN rxvt-2.7.2-orig/configure rxvt-2.7.2/configure
--- rxvt-2.7.2-orig/configure	Sat Dec 18 19:23:22 1999
+++ rxvt-2.7.2/configure	Sat Apr 14 19:08:50 2001
@@ -5227,6 +5227,7 @@
 src/test/Makefile \
 src/rsizes.h \
 rclock/Makefile \
+W11/Makefile \
  config.h:autoconf/config.h.in" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
 cat >> $CONFIG_STATUS <<EOF
@@ -5353,6 +5354,7 @@
 src/test/Makefile \
 src/rsizes.h \
 rclock/Makefile \
+W11/Makefile \
 "}
 EOF
 cat >> $CONFIG_STATUS <<\EOF
diff -urN rxvt-2.7.2-orig/src/command.c rxvt-2.7.2/src/command.c
--- rxvt-2.7.2-orig/src/command.c	Sat Dec 18 19:18:04 1999
+++ rxvt-2.7.2/src/command.c	Sat Apr 14 18:09:52 2001
@@ -363,7 +363,7 @@
 	}
 #endif
 #if defined(HAVE_GRANTPT) && defined(HAVE_UNLOCKPT)
-# if defined(PTYS_ARE_GETPT) || defined(PTYS_ARE_PTMX)
+# if defined(PTYS_ARE_GETPT) || defined(PTYS_ARE_PTMX) || defined(__CYGWIN32__)
     {
 	extern char    *ptsname();
 
